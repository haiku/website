+++
type = "article"
title = "Ideas"
date = "2013-02-24T21:35:54.000Z"
tags = []
+++

<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below) between April 22nd and May 3rd, 2013.
For details about how to apply, please check out <a href="http://www.haiku-os.org/community/gsoc/2013/students">Students: How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>According to other mentor organizations, the most successful <i>Google Summer of Code</i> projects are the ones proposed by the students themselves.
The following list represents our ideas and wishes of our project. However, suggesting your own idea is encouraged!</p>
</div>

<p>Be aware: API design requires a higher level of skill. A significantly more convincing proposal is required</p>

<p>If you find an idea marked as "big" interesting but feel you cannot completed in time, feel free to suggest splitting it into smaller parts in your proposal.
Also, many of these ideas are not sufficient as stand-alone projects and would need to be combined with others on this list or of your own suggestion.</p>

<p>Students, who intend to submit applications on ideas that are part of other accepted mentoring organizations, need to contact both Haiku and the other mentoring organization.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User interface</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<h4 class="icon-app-medium">Updating and Extending WebPositive</h4>

Haiku uses a WebKit based browser called WebPositive. This task would involve:

<ul>
<li>Native network backend. Currently we use the Curl backend, which is slow and has some other problems. Use the (unfinished) "Services Kit" instead.</li>
<li>various webpositive tickets.</li>
</ul>
<ul><li>
Skill set: userland development, kernel development, possibly x86 assembly
</li></ul>

<h4 class="icon-app-medium">VirtualBox port to Haiku</h4>

A port of VirtualBox to Haiku, would allow developers and users to run another operating system within Haiku.  <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">Preliminary VirtualBox port to Haiku</a>
<ul><li>
Skill set: userland development, kernel development, possibly x86 assembly
</li></ul>


<h4 class="icon-app-medium">Calendar application</h4>

<p>Create a native calendar application or port an existing calendar application to Haiku. The app should support creating events and saving them to event files augmented with attributes similar to how People file work for contacts. Additional features of the calendar app might also include support for recurring events, integration with other calendaring software such as Google Calendar or Microsoft Outlookâ„¢, and vCalendar support</p>

<p>Some applications to look at for inspiration/examples:</p>
<ul>
<li>http://www.pulkomandy.tk/~beosarchive/?file=archive/source/utils/Organizer.zip</li>
<li>http://haikuware.com/directory/view-details/info-management/personal-information-managers/a-book</li>
</ul>
<ul><li>
Skill set: userland development
</li></ul>

<h4 class="icon-app-medium">Updating Mail</h4>

Haiku's built in Mail application is in need of various improvements. Some of the issues include from re-writing code to adhere to style guidelines, utilizing the Layout API, utilizing proper object oriented programming concepts, addressing race conditions, and GUI improvements
<ul>
<li><a href="https://dev.haiku-os.org/ticket/1431">#1431: Mail codebase needs a cleanup to fix several issues</a></li>
<li><a href="https://dev.haiku-os.org/ticket/5140">#5140: Mail GUI enhancements</a></li>
<li><a href="https://dev.haiku-os.org/ticket/5141">#5141: Generating queries for related mails in Mail</a></li>
</ul>


<h4 class="icon-app-medium">Other applications</h4>
There are many open source 3rd party applications for Haiku that coud use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale Kit and Layout API, or anything else imaginable!

<ul>
<li><a href="http://dev.osdrawer.net/projects/caya">Caya</a></li>
<li><a href="http://haikuware.com/directory/view-details/internet-network/clients/torrentor">Torrentor!</a> (<a href="https://github.com/Prodito/Torrentor">source</a>)</li>
<li>http://dev.osdrawer.net/projects</li>
<li>http://pulkomandy.lexinfo.fr/projects</li>
<li>http://wwww.haikuware.com</li>
</ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>


<h4 class="icon-app-medium">
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has Acpi Video Extentions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
AV/1394 support
</h4>

<p>Our Firewire stack supports DV receiving, but not controlling the A/V device (ie play/stop). This requires to modify the Firewire stack for FCP frame support. See AV/C Digital Interface Command Set General Specification for reference.</p>

<ul>
<li>Requirements: a DV camera, a machine with a Firewire port.</li>
<li>Skill set: kernel development, API design, general C/C++, userland development</li>
</ul>

<h4 class="icon-app-medium">TTY Layer</h4>
<p>
    The TTY layer is needed for proper serial port support in Haiku.
    Until now the serial port was reserved for kernel debugging,
    but it is now time for proper userland support.
    Rewrite the API that was available in BeOS R5,
    and make sure it can be used with a real serial port.
    USB to serial converter may or may not be included.
</p>
<p>
    Currently, the TTY layer is written mostly with the usb_serial
    in mind, so it uses stuff that might not be easy or possible at all to
    use in more low-level drivers (like pc_serial).
    The API could use improvements. Locking issues exist.
    Also the generic module is not yet in the image due to these.
</p>
<ul>
	<li>
	    Skill set: kernel, and driver development
	</li>
	<li>
        Tickets: <a href="https://dev.haiku-os.org/ticket/35">#35</a>, <a href="https://dev.haiku-os.org/ticket/3232">#3232</a>
	</li></ul>



<h4 class="icon-app-medium">LibUSB port</h4>

<p>LibUSB is a portable library to access USB devices from userland.
Make it work on Haiku and port applications such as sane, avrdude, and more to test the port.
</p>

<h4 class="icon-app-medium">Nouveau / PSCNV port</h4>
<p>
Nouveau is a graphics driver for NVidia video cards. There is a fork called PSCNV which might have less dependencies on Linux.
cf. https://github.com/pathscale/pscnv/wiki
</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4 class="icon-app-medium">
File Systems: general improvements (BIG)
</h4>
Haiku has great support for its own file system, but most others are only available read-only, or not at all. It is way better for interoperability with other systems to be able to read and write to these disks.
<ol>
<li>ReiserFS, BTRFS, exFAT: write support</li>
<li>UFS2, ZFS: Read (& Write) support</li>
<li>SMB, Windows shares: Read (& Write) support</li>
<li>HAMMER FS: Read (& Write) support</li>
<li>SquashFS: To support booting Haiku off SquashFS on a CD/DVD</li>
</ol>
<ul><li>
Skill set: kernel, and driver development
</li></ul>

<h4 class="icon-app-medium">
IMAP FS: File system access to an IMAP account
</h4>

<p>In Haiku emails are stored as individual file with extended attributes. Mounting an IMAP account as a local file system is therefore a natural fit. The file system should have full read and write support (deleting mails (files), creating folders, and moving mails between folders, etc.) with local caching for better performance.</p>
<ul><li>
Skill set: kernel and file system (driver) development, network development
</li></ul>

<h4 class="icon-app-medium">x86-64: Support for 32 bit userland</h4>

Since Google Summer of Code 2012 there's a x86-64 port of Haiku. The kernel only supports a 64 bit userland, though. A compatibility mode should be added, so that 32 bit programs can be run as well.

<ul><li>
Skill set: kernel development, x86 architecture/assembly
</li></ul>

<h4 class="icon-app-medium">Unify File System Caches</h4>

The Haiku kernel provides two kinds of caches for use by file system implementations: the file cache and the block cache. The file cache uses physical memory pages directly and it is linked with the VM subsystem, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the slab allocator) and freeing memory in low memory situations is handled via the low resource manager. Using different mechanisms to deal with low free memory situations leads to a caching imbalance in favor of the block cache. Furthermore the block cache uses large amounts of kernel address space, which can be problematic on 32 bit architectures. The goal is to create a common underlying mechanism (using `VMCache`) to unify both caches. Solutions must be found to interesting problems like how to deal with different block sizes (not necessarily matching the page size) and how to map support for transactions to `VMCache` hierarchies.

<ul><li>
Skill set: kernel development
</li></ul>


<a id="network" name="network"></a>
<h3>Network</h3>

<h4 class="icon-app-medium">
Bluetooth Stack Improvements
</h4>
<p>Haiku Bluetooth Stack implements basic functionality on lower and middle layers, this functionality needs to be completed and Bluetooth 2.X possibilities explored.</p>

<ul>
<li>Requirements: Bluetooth enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge(optional)</li>
<li>Tasks: RemoteDevices Database, UserLand tools(Preferences), Pairing/Auth/Encryption use cases, etc.</li>
</ul>

<h4 class="icon-app-medium">
Integrate our PPP implementation
</h4>
<p>Port the PPP implementation to our new network stack. Add phone-line modem support, including HDLC framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT). Implement CHAP authentication. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
</ul>


<h4 class="icon-app-medium">
IPv6 Polish
</h4>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project. Even so, there remains a lot of smaller cleanup/polish tasks that can be done as a project.

<ul>
<li>Tickets:
<ul>
<li><a href="https://dev.haiku-os.org/ticket/8293>#8293</a> -- BNetworkAddress needs to check if there is an available IPv6 connection.</li>
<li><a href="https://dev.haiku-os.org/ticket/7228>#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/6489>#6489</a> -- ifconfig needs to validate availability of ipv6 module prior to utilization</li>
<li><a href="https://dev.haiku-os.org/ticket/2632>#2632</a> -- Possible redefinition for struct sockaddr_in, related to IPv6</li>
<li><a href="https://dev.haiku-os.org/ticket/8319>#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/8317>#8317</a> -- Haiku needs IPv6 global scope Auto Configuration (router advertisement + DHCPv6)</li>
</ul>
</li>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development
</ul>

<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<h4 class="icon-app-medium">
Preflet GUI refactoring
</h4>
Several preference applications (aka preflets) could be redesigned. This includes (but not limited to) :
<ol>
<li>combining Keymap and Keyboard</li>
<li>combining Mouse and Touchpad</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Printer</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet</li>
<li>Shortcuts</li>
<li>Notifications</li>
</ol>
<ul>
<li>Skill set: c++, UI development, usability basics</li>
</ul>

<h4 class="icon-app-medium">
Modular edit view (BIG)
</h4>
<p>
Many Haiku applications are using their own edit view to provide basic editor functionalities. All these implementations work a little bit different and create an inconsistent user experience.
One solution is to provide a modular and powerful editor view that could be used in various Haiku applications.</p>
<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:</p>
<ul>
<li>syntax highlighting</li>
<li>spell checker</li>
<li>code completion, word completion</li>
<li>line numbers, ruler, 80 character limit line, hyper links</li>
<li>working on an input stream rather than on a input file e.g. to be able to open files ~100Mb without loading them into memory in one go.</li>
<li>interface to external applications e.g. to jump from a compiler error to the according line in the code</li>
</ul>
<ul>
<li>
Skill set: C++, UI development
</li>
</ul>


<a id="media" name="media"></a>
<h3>Media</h3>

<h4 class="icon-app-medium">
Merge CDPlayer into MediaPlayer
</h4>
<p>
The functionality of CDPlayer could be migrated into MediaPlayer, allowing the play back of audio cd's. An alternative to CDPlayer's way of controlling the device in a low-level fashion would be to make it use the wave files as presented by the cdda-fs, subscribe to volume mounts via BVolumeRoster, present a menuitem for the CD similar to one for DVDs in the VLC Media Player, having this option populate a playlist and start playing.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
Streaming support for Media Kit and applications
</h4>
The media kit and related applications in Haiku relies a lot on the BMediaFile being seekable. This makes it difficult to use with non-seekable media sources such as internet streams or DVD media. Rework what's needed to get them working properly.

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>


<a id="other" name="other"></a>
<h3>Other</h3>

<h4 class="icon-app-medium">
Fix and improve Haiku's mail system
</h4>
Haiku features an integrated mail management system allowing to manage your mail using Tracker, the file explorer. This system needs some improvements and updates. See this <a href="http://www.freelists.org/post/haiku-commits/r40398-in-haikutrunksrc-addonsmail-daemon-addonsmail-daemoninbound-filters-addonsmail-daemoninbound-filtersmatch-header-addonsmail-daemoninbound-filtersnotifier-addonsmail-daemoninbound-filtersspam-filter,2">mailing list post</a> for a list of TODO and related ideas

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
Trac Plugin: "Test and Commit Patch" functionality
</h4>
<p>
Several developers have requested the ability to simply press a button that would trigger an automatic system to test and (conditionally commit) a supplied patch.
</p>
<ul>
<li>Skill set: Python</li>
</ul>

<h4 class="icon-app-medium">
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library, it has support for BeOS/Zeta/Haiku in the 4.4 branch, but they dropped BeOS from the 5.x branch. Now that Haiku is in a usable state it would be nice to get the latest builds of Allegro 5.0 working on Haiku. It's still unclear if Allegro will be applying for GSoC but they do have a developer who'd be willing to co-mentor this with a Haiku mentor.</p>

<ul>
<li>Skill set: C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
Graphical project manager tool
</h4>
BeOS had CodeWarrior IDE built-in, which makes it easy to create a new project and get started on development. Haiku currently only provide make and jam in the default installation, which is far less easy to use for starting developpers. The makefile engine is somewhat simpler, but more limited. All of these tools are to be used in text mode, not so good for beginners. Create some graphical tool to easily get started on 3rd party development in a few clicks. No need for a full-blown IDE.

<ul>
<li>Skill set: C++, userland development</li>
</ul>

<h4 class="icon-app-medium">
Tracker add-on for source control
</h4>
Windows has TortoiseSVN and TortoiseGIT. Do something similar with Haiku Tracker.
<ul>
<li>Write a Tracker add-on that has the functionality</li>
<li>Extend support in Tracker itself where needed : icon overlays, ...</li>
</ul>

<h4 class="icon-app-medium">
Modify the app_server to support compositing
</h4>
This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows and window animations. There's lots of info on what would need to be done and how to go about it in this article: https://www.haiku-os.org/articles/2011-06-15_how_transform_app_server_code_use_compositing .
<ul>
<li>Skill set: C++, graphics development</li>
</ul>

<h4 class="icon-app-medium">
Evaluate Qt as a potential Haiku R2 API
</h4>
While in comparison with other frameworks the BeOS API was quite nice back in the day, save for a few additions (like layout management, an improved archiving mechanism, tool tips) very little has changed since. Particularly the interface kit leaves a lot to be desired these days, both in general design and completeness. The Qt toolkit on the other hand has evolved quite nicely over time and now presents a very complete and well designed API. This project shall evaluate Qt as a potential native Haiku R2 API, replacing partially or even completely the previous BeOS/Haiku API.
<ul>
<li>Analyze the current state of the <a href="http://qt-haiku.ru/">Qt port</a> and add/complete what is missing/incomplete.</li>
<li>Add extension in or on top of the Qt API to provide access to Haiku specific functionality (attributes, entry_refs, resources, translators, etc.)</li>
<li>As a proof of concept port an existing Haiku application (e.g. StyledEdit) over to the extended Qt API.</li>
</ul>
<ul>
<li>Skill set: C++, API development</li>
</ul>
