+++
type = "article"
title = "Ideas"
date = "2017-01-17"
tags = []
+++

<p>For information about Haiku's participation in GSoC this year, please see <a href="/community/gsoc/2017">this page</a>.</p>
<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below).
For details about how to apply, please check out <a href="/community/gsoc/2017/students">Students: How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>According to other mentor organizations, the most successful <i>Google Summer of Code</i> projects are often those proposed by the students themselves.
The following list represents some of our ideas and wishes for the project. However, suggesting your own idea is always encouraged!</p>
</div>

<p>Be aware: API and user interface design requires a higher level of skill. A
significantly more convincing proposal is required for tasks involving those.
Getting started with the design early (before the coding period starts) is
recommended, to maximize your chances of being selected, and allow a larger part
of the coding period dedicated to coding tasks.</p>

<p>If you find one of the "big" ideas interesting, but feel that you cannot
complete it within the allotted coding time, feel free to suggest splitting it
into smaller parts for your proposal.</p>

<p>Students that intend to submit applications on ideas which are also part of
other accepted mentoring organizations must coordinate with both Haiku and the
other mentoring organization beforehand.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File Systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User Interface</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<h4 class="icon-app-medium">Updating and Extending WebPositive</h4>
<p>
Haiku uses a WebKit based browser called WebPositive. The browser is still quite simple and can be improved in multiple ways. Some of the missing features are:
</p>
<ul>
<li>Advanced session management. There is minimal support for restoring tabs from the last closed window, but a more complete solution is desirable. The web browser should be able to store its whole state (multiple windows and tabs) to a session file, and restore the state from that file.</li>
<li>Management of broken HTTPS certificates. There should be a way to remember exceptions to the system-wide certificate list.</li>
<li>Support for browser extensions, such as ad-block. This could be done either reusing extensions from other browsers (if possible), or using the native add-ons system.</li>
<li>Skill set: userland development, user interface design and programming</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">Extending and improving the Services Kit network backend</h4>
<p>
The WebKit browser and some other Haiku applications such as HaikuDepot use the Services Kit as a network backend. This is a library similar to <a href="http://curl.haxx.se/">curl</a> or <a href="https://wiki.gnome.org/action/show/Projects/libsoup">soup</a>, but nicely integrated into the Haiku API for easy use in native applications. The Services Kit is still a work in progress, however, and can be improved in several ways. The work on this task could include:</p>
<ul>
<li>Reworking the Service Kit to avoid spawning one thread for each network request. The requests should be allowed to run in an existing thread, or to be grouped together (by use of select() or poll() to wait for activity on their sockets, then dispatching events to the BNetworkRequest objects). This would remove some of the overhead of creating a request and solve some design issues in the Services Kit API.</li>
<li>Implementing HTTP 1.1 support, allowing the reuse of the connection to an HTTP server to perform multiple requests. BHttpRequest objects should be reworked to be able to use an existing HTTP 1.1 connection, and a way to store existing connections should be added.</li>
<li>A caching layer for HTTP requests. There currently is no cache which means some requests are made again and again to the same server. The cache should keep the result of these requests on disk and/or in memory, making it possible to reuse them and load web pages faster.</li>
<li>Complete support for HTTP proxies. While there is currently limited support, it is not possible to do HTTPS requests through a proxy. This should be added, as well as a system-wide user interface to configure and manage proxies.</li>
<li>Implementing FTP support. The services kit is designed to support multiple protocols, but currently only HTTP and Gopher are supported (as well as the local "file" and "data" protocols). FTP support in the web browser would be helpful.</li>

<li>Skill set: userland development, network programming, threads.</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, Jessica Hamilton</li>
</ul>

<h4 class="icon-app-medium">Improving Haiku's WebKit1 port</h4>

<p>Haiku has a native WebKit port which uses the WebKit1 API. This port is not complete and there are several bugs and minor problems which needs to be fixed.</p>

<ul>
<li>There are rendering problems on many web pages. Most of these happen because of missing features both in the WebCore graphics implementation and in the Haiku app_server. This includes missing or incomplete support for dashed lines, shadows, perspective transforms, and probably some bugs in already implemented features. These should be implemented so websites look closer to how they were designed.</li>
<li>Another missing feature is the ability to load fonts into app_server dynamically. Currently the Haiku API only allows using existing fonts installed in specific system directories. This should be extended so WebKit can make use of fonts it downloads from the web. Some websites use these as pictograms, and not having the correct font results in unuseable websites.</li>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">Migrating Haiku WebKit port to WebKit2</h4>
<p>
Haiku has a native WebKit port which uses the WebKit1 API. Since this port was made, the WebKit project migrated to WebKit2, which provides several new features and separates the work in several processes to limit the impact of crashes in one or the other.
</p><p>
The goal of this task is to get WebKit2 to run on Haiku. This involves implementing the required inter-process communication primitives in WTF (first reusing the UNIX socket support used on Linux ports, then migrating to BMessages if this is relevant/useful), and writing a WebKit2-style API for WebKit, which can be used in native Haiku  applications. Proof of concepts could be a minimal browser, an update to the existing WebPositive, or adding a web view to existing applications such as Mail or fRiSS.</p>
<ul>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">VirtualBox port to Haiku</h4>

<p>VirtualBox is a virtual machine allowing to run an operating system inside of another. Porting it to Haiku would allow Haiku user to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Starting from <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">this preliminary work</a>, continue and complete the port. This includes writing a native GUI for VirtualBox, getting it to run, and more importantly, work on the virtualization driver which will allow virtualbox to run the emulated machine using the native CPU. This makes the emulated system run at close-to-native speed, whereas a software emulation would be unbearably slow.</p>

<ul><li>Skill set: userland development, kernel development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man</li>
</ul>

<h4 class="icon-app-medium">KVM acceleration for Haiku's QEmu port</h4>

<p>QEmu is a virtual machine allowing to run an operating system inside of another. While there already is an Haiku port, it currently does not support any acceleration system through native virtualization (KVM/KQemu). This makes it too slow for many uses. Fixing this would allow Haiku user to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<ul>
<li>Work on the virtualization driver which will allow QEmu to run the emulated machine using the native CPU.</li>
<li>Skill set: kernel development, userland development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man</li>
</ul>


<h4 class="icon-app-medium">Calendar application</h4>

<p>Create a native calendar application or port an existing calendar application to Haiku. The app should support creating events and saving them to event files augmented with attributes similar to how People file work for contacts. Additional features of the calendar app might also include support for recurring events, integration with other calendaring software such as Google Calendar or Microsoft Outlookâ„¢, and vCalendar support ; CalDAV synchronization, import of iCal files, and more.</p>

<p>You should review existing calendar applications on Haiku/BeOS and other operating system to find out the key features for such an application. Then, decide if one of the applications linked below may be used as a starting point, or if it is better to start from scratch. Aside writting the application itself, it may be useful to improve the BDate, BTime and BDateTime in Haiku to make it possible to do date math easily, work with different timezones, and format dates represented using these classes, as well as relative durations ("Today", "2 days ago", ...), in a localized way.</p>

<p>Some applications to look at for inspiration/examples:</p>
<ul>
<li>http://www.pulkomandy.tk/~beosarchive/?file=archive/source/utils/Organizer.zip</li>
<li>https://github.com/HaikuArchives/Eventual (for screenshots, see: http://sourceforge.net/projects/eventual/)</li>
<li>https://github.com/HaikuArchives/A-Book</li>
</ul>
<ul><li>
Skill set: userland development, user interface design, possibly network development.
</li></ul>

<h4 class="icon-app-medium">Other applications</h4>
<p>There are many open source 3rd party applications for Haiku that could use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale and Layout Kits, or anything else imaginable! Writing applications from scratch is also possible.</p>

<ul>
<li><a href="https://github.com/Barrett17/Caya">Caya</a> (IM client)</li>
<li><a href="https://github.com/HaikuArchives/Torrentor">Torrentor!</a></li>
<li>https://github.com/HaikuArchives</li>
<li>http://pulkomandy.tk/~beosarchive/</li>
</ul>
<ul><li>
Skill set: userland development, user interface design, exploring an existing code base, others depending on the application retained.
</li>
<li>Possible mentors/knowledgeable people (depends on chosen application): PulkoMandy</li>
</ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>

<h4 class="icon-app-medium">
USB Support for FreeBSD network compatibility layer
</h4>

<p>Haiku uses a FreeBSD network compatibility layer to support many network devices (ethernet and wireless) using drivers written for the FreeBSD project. This allows reusing network drivers with very little changes, considerably decreasing the effort needed to get good hardware support in Haiku.</p>
<p>However, this layer only supports PCI devices, and doesn't work with USB ones. Adding support for USB to the compatibility layer would bring us support for a range of devices like so-called USB tethering, as well as USB to Ethernet and WiFi dongles.</p>

<p>This project consists in importing one or more USB network drivers from FreeBSD into Haiku sources. The compatibility layer should then be extended to expose the FreeBSD USB APIs to the drivers, and forwarding the calls to Haiku's USB stack. Other parts of the compatibility layers may need to be extended as well.
</p>
<p>This should be tested either with real hardware or an emulated device in a virtual machine.</p>

<ul>
<li>Requirements: an Ethernet USB device for testing (most smartphones can do this).</li>
<li>Skill set: kernel and driver development, USB, general C and C++ development</li>
</ul>


<h4 class="icon-app-medium">
USB stack improvements (USB3, isochronous transfers)
</h4>
<p>Like any other operating system, Haiku has drivers for all types of USB interfaces: OHCI and EHCI for USB1, UHCI for USB2, and XHCI for USB3. However, most of these still need some improvements to improve compatibility and add full support of the USB specification.</p>
<p>The XHCI support is still not complete. On several machines it will not detect devices, generate a lot of hardware interrupts, or even prevent the whole system from booting. Work on XHCI support must be continued so Haiku gets more reliable and complete support for USB3.</p>
<p>USB allows 3 different ways of exchanging data with a device: bulk, interrupt, and isochronous. In bulk mode, the data is transferred when the bus is idle. Interrupt mode has higher priority. Finally, isochronous mode guarantees a minimal rate. This last mode is used for example by USB audio cards and webcams, as they need a constant flow of data at a fixed rate. The UHCI and EHCI drivers are missing support for isochronous USB transfers. This makes it impossible to use most USB sound cards and webcams in Haiku.</p>
<p>The USB tasks consist in implementing either complete USB3 support, or isochronous transfers for USB1 and USB2 devices. This can be complemented with porting a webcam or audio card driver from FreeBSD or Linux (FreeBSD is preferred because of the software license used, we prefer to avoid GPL code if possible).
<ul>
<li>Requirements: an USB webcam or audio device for testing (most laptops have an embedded webcam using USB).</li>
<li>Skill set: kernel and driver development, USB, general C and C++ development</li>
</ul>


<h4 class="icon-app-medium">
virtio network and balloon drivers
</h4>

<p>virtio ("virtual input and output") is a technology used in virtual machines to reduce overhead of emulation. Instead of simulating an existing device, virtual machines expose a simplified "virtio" device, which is designed to make interfacing between the guest and host system easier. The technology is currently applied to disks, memory, and network.</p>

<p>The virtio memory driver allows to implement "ballooning", that is, the virtual machine can increase or decrease its memory use (just like a balloon is inflated or deflated) when the guest system allocates or releases memory. This makes it easier to share the memory between several virtual machines more efficiently.</p>

<p>Haiku already has a virtio bus driver, and a virtio disk driver. The addition of a virtio network card driver and a virtio memory balloon driver would enable Haiku to take advantage of emulation speedups using the lightweight virtio bus. Haiku could also be deployed in environments such as Amazon S3 or OpenStack.  To complete this task, a fully stable virtio network card driver would need to be completed and tested as functional as well as a working virtio balloon memory driver.</p>

<ul>
<li>Requirements: qemu or virtualbox with the virtio network card selected.</li>
<li>Skill set: kernel and driver development, general C development.</li>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/9800">#9800 virtio network driver</a>, <a href="https://dev.haiku-os.org/ticket/9803">#9803 virtio balloon memory driver</a></li>
<li>Existing code: <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/drivers/network/virtio">virtio network driver (target of this task)</a>, <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/busses/virtio">virtio bus driver (should be mostly complete)</a>, <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/drivers/disk/virtual/virtio_block">virtio block (functional, example usage of virtio bus)</a></li>
</ul>

<h4 class="icon-app-medium">
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has ACPI Video Extensions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
SD Host Controller support
</h4>
<p>Haiku has currently no support for SD Host Controller.</p>
<p>Implementing a stack with support for SDHC PCI devices would be a good start.
<a href="https://www.sdcard.org/downloads/pls/pdf/index.php?p=partA2_300-1.jpg&f=partA2_300.pdf&e=EN_SSA2">Specifications for SDHC</a>
<a href="https://www.sdcard.org/downloads/pls/pdf/index.php?p=part1_410-1.jpg&f=part1_410.pdf&e=EN_SS1">Specifications for MMC</a></p>
<p>To develop and test, QEmu (from 2.3) provides an emulation for SDHC on PCI:
-device sdhci-pci -sd my-test-drive</p>
<a href="http://lists.gnu.org/archive/html/qemu-devel/2014-11/msg03244.html">QEmu references</a>
<p>This would involve designing and developing a SDHC PCI bus driver, a MMC bus module and a MMC SD disk driver. 
<ul>
<li>Skill set: kernel and driver development, general C and C++ development</li>
</ul>


<!-- REMOVED; need investigation, possibly easier to use DragonFlyBSD's compatibility layer to get all drivers from Linux
<h4 class="icon-app-medium">Nouveau / PSCNV port</h4>
<p>
Haiku currently doesn't have a driver for NVidia video cards, and falls back to VESA for those. While our VESA driver is reasonably fast, it can't set the native display resolution on all systems, leading to a suboptimal Haiku experience.</p>
<p>
Nouveau is a graphics driver for NVidia video cards. There is a fork called PSCNV which might have less dependencies on Linux.
cf. https://github.com/pathscale/pscnv/wiki
</p>
<p>Port (parts of) Nouveau to a Haiku graphic driver, allowing at least setting the native video mode. Hardware 3D acceleration may also be investigated, but requires more work on Haiku (see the next project idea).</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>
-->


<h4 class="icon-app-medium">3D acceleration support</h4>
<p>
Haiku does not currently support hardware acceleration of 3D rendering. Using the Gallium infrastructure from Mesa, the goal of this project is to make the existing Mesa renderer allow 3D rendering and not just software. This involves extending the API used by our video drivers (which is currently 2D oriented only), and making Gallium uses that API. Parts of the DRI/DRM model used on Linux may be reusable, but cooperation with the app_server must be possible.</p>

<ul><li>
        Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4 class="icon-app-medium">
Power Management
</h4>

<p>Haiku already has some power management support in the form of a CPU idling driver. This is however clearly not sufficient, and there is room for improvements in several areas in order to make Haiku use less power and make laptops running Haiku last longer on battery.</p>
<p>Some investigation is required to identify the main issues in Haiku leading to suboptimal performance. There are however a few already known problems:</p>
<ul>
<li>Some subsystems such as the network and wireless stack wake up the system at regular intervals (10 or 100 times per second) to perform some tasks. Whenever possible they should be modified to trigger these tasks in anevent-driven way (triggering them from hardware interrupts for example).</li>
<li>Some applications (such as the always-running DeskBar) are polling for events in a similar way. The APIs should be adjusted where possible to make those applications wait on notifications instead.</li>
<li>None of the device drivers in Haiku include powersaving modes. When a device is idle, it should be put to sleep and powered off until it is needed again.</li>

<li>Skill set: kernel development, general C/C++, userland development, debugging, power management / measurement</li>
</ul>

<h4 class="icon-app-medium">
Add write support for more filesystems (BIG)
</h4>
<p>Haiku has great support for its own file system, but most others are only available read-only. It is way better for interoperability with other systems to be able to write to these disks from Haiku.</p>
<p>The goal of this project is to complete the existing support for one of the following filesystems in Haiku, working from the existing code base:</p>
<ol>
<li>ReiserFS <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/reiserfs">existing sources</a>, <a href="http://web.archive.org/web/20070717210450/http://www.namesys.com/X0reiserfs.html">official specifications</a>, <a href="http://p-nand-q.com/download/rfstool/reiserfs_docs.html">extra documentation on the FS layout</a></li>
<li>BTRFS: <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/btrfs">existing code</a>, <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">homepage</a></li>
</ol>
<p>A good warm-up task would be to get one of these filesystem to build and run in "userlandfs" mode, as this allows much easier development and testing during the project.</p>
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">
File Systems: general improvements and new filesystems.
</h4>
<p>Haiku has great support for its own file system, but is completely missing support for some other fielsystems. It is way better for interoperability with other systems to be able to read and write to these disks.</p>
<p>The goal of this project is to port one of the following filesystems to Haiku:</p>
<ol>
<li>ext4: extend the <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/ext2">existing ext2 driver</a> to support new ext3 and ext4 features</li>

<li><a href="http://en.wikipedia.org/wiki/Unix_File_System">UFS2</a> (as used in *BSD): <a href="http://fxr.watson.org/fxr/source/ufs/">FreeBSD implementation</a>, <a href="http://sourceforge.net/p/ufs2tools/code/HEAD/tree/trunk/ufs2tools/">u2fstools for windows</a> (BSD licensed, source can be reused)</li>

<li>HAMMER FS: <a href="http://www.dragonflybsd.org/hammer/">homepage</a>, <a href="http://fxr.watson.org/fxr/source/vfs/hammer/?v=DFBSD">sourcecode</a> (3-clause BSD, a port of the existing code is ok)</li>

<li><a href="http://en.wikipedia.org/wiki/JFS_(file_system)">JFS</a>: existing code in Linux is under the GPL, a rewrite under the MIT license is preferred. The <a href="http://jfs.sourceforge.net/project/pub/jfslayout.pdf">filesystem design and disk structures</a> are well documented.</li>

<li><a href="http://en.wikipedia.org/wiki/Xfs">XFS</a>: <a href="http://xfs.org/index.php/Main_Page">Development community</a>, <a href="http://oss.sgi.com/projects/xfs/index.html">homepage</a>  (existing code in Linux is under the GPL, a rewrite under the MIT license is preferred)</li>

<li><a href="http://en.wikipedia.org/wiki/Zfs">ZFS</a>: <a href="http://www.open-zfs.org/wiki/Main_Page">main page</a>, <a href="https://github.com/illumos/illumos-gate/tree/master/usr/src/uts/common/fs/zfs">existing code</a> (Existing code is under the CDDL, a rewrite is preferred)</li>
<li><a href="http://en.wikipedia.org/wiki/Server_Message_Block">SMB</a>, Windows shares: <a href="http://fxr.watson.org/fxr/source/fs/smbfs/?v=FREEBSD10">smbfs from FreeBSD</a> (2-clause BSD, code can be ported to Haiku)</li>
</ol>
It's okay to port over the code from other systems, although we prefer code that can be distributed under the MIT license.
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">
IMAP FS: File system access to an IMAP account
</h4>

<p>In Haiku emails are stored as individual <a href="http://www.haiku-os.org/docs/userguide/en/workshop-email.html">file with extended attributes</a>. The <a href="http://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">IMAP</a> protocol exposes mails in a folder hierarchy and makes it possible to "browse" a remote mail box. Mounting an IMAP account as a local file system is therefore a natural fit. The file system should have full read and write support (deleting mails (files), creating folders, and moving mails between folders, etc.) with local caching for better performance. The design of <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/netfs">netfs</a> and <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/nfs4">nfs4</a> implementations for Haiku, as well as the simpler <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/googlefs">googlefs</a> can serve as a reference on how to implement a network file system.</p>
<ul><li>
Skill set: kernel and file system (driver) development, network development
</li></ul>


<h4 class="icon-app-medium">x86-64: Support for 32 bit userland</h4>

<p>
Haiku is currently available in both 32 and 64 bit versions. However, the 64-bit version is currently unable to run 32-bit applications, forcing application developers to provide a 64-bit version of their applications. This is reducing the adoption of 64bit versions of Haiku for lack of available applications.</p>
<p>The goal of this task is to add a compatibility mode to the 64-bit kernel so it is able to run 32-bit programs. The issues in doing that involve adjusting syscall parameters, and mainly converting pointers from the 32bit userland to the 64-bit addressing used on the kernel side. 32-bit applications compiled for Haiku "x86" architecture should be supported. Handling of gcc2-compiled legacy BeOS applications may also be considered as an extended goal, but not as much important.</p>

<ul><li>
Skill set: kernel development, x86 architecture/assembly language
</li></ul>


<h4 class="icon-app-medium">ARM port / device tree support</h4>

<p>Unlike x86 systems which have a PCI bus, most ARM devices have peripherals at hardcoded addresses. This means automatic hardware discovery is not possible. The Linux kernel developers designed a solution called "flattened device tree". It is a static description of the hardware, telling the kernel where devices are located and which driver to use.</p>

<p>Haiku plans to use device trees to support several ARM devices with the same kernel. This requires updating our drivers and driver infrastructure to not rely so much on the PCI bus. This work should start with the USB EHCI driver, in order to provide at least one mass storage solution to the ARM port of Haiku.</p>

<p>The ARM port of Haiku is currently in an early state. This project may involve debugging of other issues in the port to get it running further, so the device tree part can be tested. Several parts of the early boot code should be reviewed to make use of the device tree and remove hardcoded addresses (RAM mapping, framebuffer, serial port, etc).</p>

<ul><li>
Skill set: kernel development, ARM architecture/assembly
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">Unify File System Caches</h4>

<p>
The Haiku kernel provides two kinds of caches for use by file system implementations: the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/file_cache.cpp">file cache</a> and the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/block_cache.cpp">block cache</a>. The file cache caches data at the "file" level, while the block cache is used at the "block" level and is used for on-disk structures as well as file data.</p>

<p>The file cache uses physical memory pages directly and it is linked with the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/vm">VM subsystem</a>, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/slab">slab allocator</a>) and freeing memory in low memory situations is handled via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/low_resource_manager.cpp">low resource manager</a>.</p>

<p>The first problem with the current implementation is caching imbalance in favor of the block cache: it tends grow more than needed and prevent the file cache to get enough memory.</p>
<p>Another problem is the use of large amounts of kernel address space by the block cache, which can be problematic on 32 bit architectures. This makes the block cache constrained to the 2GB of memory available for the kernel in Haiku, and sometimes makes the kernel run out of address space for other uses.</p>

<p>The goal of this project is to create a common underlying mechanism (using `VMCache`) to unify both caches and move the block cache out of the kernel address space. The following problems need to be investigated and solved:
<ul>
<li>How to deal with heterogenous block sizes (not necessarily matching the page size): each mounted filesystem volume may have a different block size, and the block cache must be able to efficiently cache blocks of these different sizes,
<li>How to map support for transactions to `VMCache` hierarchies,
<li>Balancing of the memory allocation between the block and the file cache and between multiple mounted filesystem volumes.
</ul>
</p>
<ul><li>
Skill set: kernel development
</li></ul>


<a id="network" name="network"></a>
<h3>Network</h3>

<h4 class="icon-app-medium">
Bluetooth Stack Improvements
</h4>
<p>Haiku Bluetooth Stack implements only basic functionality on lower and middle layers. This functionality needs to be completed and Bluetooth 2.X and later possibilities explored. This task involves investigating the current state of the Bluetooth code, checking that the basic functionality is still working (pairing devices, etc), and improving the stack to make it more useful by implementing drivers for a Bluetooth device of your choice (audio, HID, networking, etc).</p>

<ul>
<li>Requirements: Bluetooth enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge(optional)</li>
<li>Tasks: RemoteDevices Database, Userland tools(Preferences), Pairing/Auth/Encryption use cases, etc.</li>
</ul>

<h4 class="icon-app-medium">
Integrate our PPP implementation
</h4>
<p>Port the PPP implementation to our new network stack. Add phone-line modem support, including HDLC framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT). Implement CHAP authentication. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
</ul>


<h4 class="icon-app-medium">
Stream Control Transmission Protocol (SCTP)
</h4>
<p>Implement and test SCTP, a message based transport layer protocol similar to TCP and UDP. It should comply with current IP and IPv6 implementations and provide similar programming API as BSD.</p>
<ul>
<li>Skill set: network protocols, kernel and network stack development</li>
</ul>

<h4 class="icon-app-medium">
IPv6 Finalization
</h4>
<p>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project. Even so, there remains a lot of smaller cleanup/finalization tasks that can be done as a project.
</p>
<ul>
<li>Tickets:
<ul>
<li><a href="https://dev.haiku-os.org/ticket/8293">#8293</a> -- BNetworkAddress needs to check if there is an available IPv6 connection.</li>
<li><a href="https://dev.haiku-os.org/ticket/7228">#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/6489">#6489</a> -- ifconfig needs to validate availability of ipv6 module prior to utilization</li>
<li><a href="https://dev.haiku-os.org/ticket/2632">#2632</a> -- Possible redefinition for struct sockaddr_in, related to IPv6</li>
<li><a href="https://dev.haiku-os.org/ticket/8319">#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/8317">#8317</a> -- Haiku needs IPv6 global scope Auto Configuration (router advertisement + DHCPv6)</li>
<li><a href="https://dev.haiku-os.org/ticket/11862">#11862</a> -- Net server multi-protocol rework</li>
</ul>

<ul>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development</li>
<li>Possible mentors: jua</li>
</ul>


<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<h4 class="icon-app-medium">
Preferences GUI refactoring
</h4>
<p>
Haiku is an operating system designed for ease of use on desktop computers. A key part of this work is an easy to use set of preference applications. Some of the currently available preference panels could be merged or improved in several ways. Some examples are:</p>
<p>
Several preference applications (aka preflets) could be redesigned. Furthermore, there might still be code that does not yet use our layout API. This work may include (but is not limited to):</p>
<ol>
<li>combining Keymap, Keyboard, Mouse and Touchpad in a single "Input devices" preferences panel,</li>
<li>adding support for joysticks and touch screens support to it,</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Reworking the Printer preferences to look better and be more intuitive.</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet, and provide a live preview for all of the settings available in this window</li>
<li>Improving the user interface of the shortcuts preference to make it easier to setup custom shortcuts</li>
<li>Improving and extending the notifications preferences to allow easy control of allowed notifications, browsing of the notification history.</li>
<li>Research on how to improve the other preference panels further with the goal of making them easier to use.</li>
</ol>
<ul>
<li>Skill set: c++, UI development, usability basics</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">
Modular edit view (BIG)
</h4>
<p>
Many Haiku applications are using their own edit view to provide basic editor functionalities. All these implementations work a little bit different and create an inconsistent user experience.
One solution is to provide a modular and powerful editor view that could be used in various Haiku applications.</p>
<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:</p>
<ul>
<li>syntax highlighting</li>
<li>spell checker</li>
<li>code completion, word completion</li>
<li>line numbers, ruler, 80 character limit line, hyper links</li>
<li>working on an input stream rather than on a input file e.g. to be able to open files ~100Mb without loading them into memory in one go.</li>
<li>interface to external applications e.g. to jump from a compiler error to the according line in the code</li>
</ul>
<p>Reuse of existing syntax highlighting libraries may be possible, provided they can be connected to a native Haiku view. MIT license would be preferred for the external library. Scintilla is a good candidate and was already ported to Haiku.</p>
<ul>
<li>
Skill set: C++, UI development
</li>
</ul>


<a id="media" name="media"></a>
<h3>Media</h3>

<h4 class="icon-app-medium">Add subtitle support to the Media Kit</h4>

<p>Haiku "media" applications rely on a framework called the Media Kit. This
provides an unified API to handle audio and video streams, including codec
plugins to read and write the stream to files or other sources, as well as
transporting the data from one application to another, with a latency as low as
possible.</p>

<p>While our MediaPlayer has support for external subtitle files, the Media Kit
itself has not. The most obvious downside of that is that there is no support
for subtitle (text or bitmap) embedded in video files within the MediaPlayer or
other applications.</p>

<p>Your job would be to design the necessary API extensions to let subtitles fit
in with the rest of the Media Kit, and add native support for them, which will
then be available to all applications as part of the framework.</p>

<ul>
<li>implement the required code to extract the subtitles from source files
(either standalone .srt files or contained for example in mkv containers), with
proper handling of replay time and text encoding</li>

<li>integrate this in the existing API (probably as a new kind of BMediaTrack),
and update applications such as MediaPlayer and MediaConverter to make use of
the feature.</li>

<li>See <a href="/legacy-docs/bebook/TheMediaKit_Overview_Introduction.html" target="_blank">
the BeBook introduction for the Media Kit</a> to become familiar with its design.</li>

<li>Skill set: general C/C++, userland development, API design</li>
<li>Possible mentors: Barrett, jua, PulkoMandy</li>
</ul>

<h4 class="icon-app-medium">
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
<li>Possible mentors: jua</li>
</ul>


<h4 class="icon-app-medium">Improving Clockwerk</h4>

<p>Clockwerk is a video editing bench for Haiku. It works well, but it is a bit
unstable and the feature set is not that complete.</p>
<!-- TODO complete the description -->

<ul>
	<li>Possible mentors: jua</li>
</ul>


<a id="other" name="other"></a>
<h3>Other</h3>

<h4 class="icon-app-medium">
Trac Plugin: "Test and Commit Patch" functionality
</h4>
<p>
Several developers have requested the ability to simply press a button that would trigger an automatic system to test and (conditionally commit) a supplied patch.
</p>
<ul>
<li>Skill set: Python</li>
</ul>

<h4 class="icon-app-medium">
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library, it has support for BeOS/Zeta/Haiku in the 4.4 branch, but they dropped BeOS from the 5.x branch. Now that Haiku is in a usable state it would be nice to get the latest builds of Allegro 5.0 working on Haiku. It's still unclear if Allegro will be applying for GSoC but they do have a developer who'd be willing to co-mentor this with a Haiku mentor.</p>

<ul>
<li>Skill set: C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Graphical project manager tool
</h4>
BeOS had CodeWarrior IDE built-in, which makes it easy to create a new project and get started on development. Haiku currently only provide make and jam in the default installation, which is far less easy to use for starting developpers. The makefile engine is somewhat simpler, but more limited. All of these tools are to be used in text mode, not so good for beginners. Create some graphical tool to easily get started on 3rd party development in a few clicks. No need for a full-blown IDE.

<ul>
<li>Skill set: C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Tracker add-on for a version control system
</h4>
Windows has TortoiseSVN and TortoiseGIT. Choose your preferred VCS, and do something similar for Haiku's Tracker.
<ul>
<li>Write a Tracker add-on that has the functionality to let you carry out most daily needed tasks when using the VCS.</li>
<li>Extend support in Tracker itself where needed: icon overlays, custom file menus, ...</li>
</ul>


<!-- REMOVED: needs more thinking on Haiku side to decide on a plan for this.

<h4 class="icon-app-medium">
Modify the app_server to support compositing
</h4>
<p>This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows, transparent windows, content previews, and window animations.</p>
<p>There's lots of info on what would need to be done and how to go about it in this article: /articles/2011-06-15_how_transform_app_server_code_use_compositing .</p>
<ul>
<li>Skill set: C++, graphics development</li>
</ul>
-->


<h4 class="icon-app-medium">
Multiple monitors output in app_server
</h4>
<p>app_server is Haiku's graphics server and the equivalent of X11 or Wayland on other UNIX systems. It currently supports only one video output, but should be able to do more.</p>
<p>While the API already allows this for the most part (with the BScreen class), there is no actual implementation behind it and parts of the code assume only a single screen.</p>
<p>Some drivers implement minimal support for multiple displays, but not all of them. This task may involve updating the video drivers to handle multiple monitors correctly.</p>
<ul>
<li>Skill set: C++, graphics development</li>
<li>Possible mentors/knowledgeable people: jua, PulkoMandy</li>
</ul>


<h4 class="icon-app-medium">
RTL languages support in interface kit
</h4>
<p>The interface kit is the part of the API taking care of everything drawing related: windows, buttons, and other widgets. It is not currently able to display right-to-left languages (such as arabic) properly, making Haiku unusable for a lot of people.</p>
<p>Font rendering should be reworked to use the HarfBuzz library, instead of just Freetype, providing support for ligatures and bidirectional text output. The Layout Kit (which handles positionning widgets in a window) should be made to work as expected with these languages (possibly inverting left and right in the window layout).</p>
<p>This task can be extended with better support for font overlays (picking the correct font for each language automatically, probably using fontconfig), and work on input methods for some languages.</p>
<ul>
<li>Skill set: C++, graphics development, text rendering</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>
