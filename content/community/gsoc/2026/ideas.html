+++
type = "article"
title = "GSoC project ideas"
date = "2026-06-20"
tags = []
+++

<p>For information about Haiku's participation in GSoC this year, please see <a href="/community/gsoc/2026">this page</a>.</p>
<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below).
For details about how to apply, please check out <a href="/community/gsoc/2026/contributors">How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>The most successful <i>Google Summer of Code</i> projects are often those proposed by the participants themselves.
The following list represents some of our ideas and wishes for the project. However, suggesting your own idea is always encouraged!</p>
</div>

<p>Be aware: API design and kernel-related work requires a higher level of skill, and
user interface design usually involves a lot more thought than other work. A
significantly more convincing proposal is required for tasks involving those.
Getting started with the design early (before the application period ends) is
recommended, to maximize your chances of being selected, and allow a larger part
of the coding period dedicated to coding tasks.</p>

<p>If you find one of the "big" ideas interesting, but feel that you cannot
complete it within the allotted coding time, feel free to suggest splitting it
into smaller parts for your proposal.</p>

<p>Students that intend to submit applications on ideas which are also part of
other accepted mentoring organizations must coordinate with both Haiku and the
other mentoring organization beforehand.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File Systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User Interface</a></li>
<li><a href="#ports">Porting</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<!-- on hold until webkit2 is ready, there's little point otherwise
<h4><img src="/images/App_Generic_32.png"/>Updating and Extending WebPositive</h4>
<p>
Haiku uses a WebKit based browser called WebPositive. The browser is still quite
simple and can be improved in multiple ways. Some of the missing features are:
</p>
<ul>
<li>Advanced session management. There is minimal support for restoring tabs
from the last closed window, but a more complete solution is desirable. The web
browser should be able to store its whole state (multiple windows and tabs) to
a session file, and restore the state from that file.</li>
<li>Management of broken HTTPS certificates. There should be a way to remember
exceptions to the system-wide certificate list.</li>
<li>Support for browser extensions, such as ad-block. This could be done either
reusing extensions from other browsers (if possible), or using the native
add-ons system.</li>
<li>Skill set: userland development, user interface design and programming</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/apps/webpositive">Source code</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>Improving Haiku's WebKit video and audio support</h4>

<h5>Idea description</h5>

<p>The WebPositive browser bundled with Haiku uses the WebKit engine (shared with Apple's Safari
and a few other browsers) to render webpages. This engine allows several parts of the work to be
implemented using existing system libraries, allowing better integration with the existing
operating system and reduced overhead.</p>
<p>In particular, the audio and video support for Haiku should be implemented by using Haiku's
Media Kit, which is a framework designed for such tasks. This would allow WebPositive to play
audio and video on websites such as Youtube.</p>
<p>The current experimental code in WebKit uses the Game Kit and only some parts of the Media Kit,
it has problems such as blocking the web browser while downloading the video, out of sync audio and
video, and unability to seek inside a video.</p>

<ul>
<li>Project size: 175 hours with possible extensions for 350 hours (adding for example fullscreen video support, work on WebRTC, ...)</li>
<li>Difficulty: medium</li>
<li>Skill set: userland development, multimedia (audio/video) programming</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li>Expected outcome: working video and audio support, including fullscreen video, without freeze of the browser during media loading.</li>
<li><a href="https://github.com/haiku/haikuwebkit/">Sourcecode of WebKit ported to Haiku</a></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Improving Haiku's WebKit2 port</h4>

<h5>Idea description</h5>

<p>Haiku has a native WebKit port which uses the WebKit1 API. This port is not complete and there are several bugs and minor problems which need to be fixed.
The plan is to replace this with a more up to date port based on the WebKit2 API. Based on the work completed in GSoC 2024, WebKit2 on Haiku is now able to render web pages.
The goal of this project is to continue this work, making the WebKit2 port more reliable, handle input events, etc, and make it usable for the WebPositive browser.</p>

<h5>Why we need this</h5>

<p>The web browser is an important part of the operating system today. It is difficult to attract and retain users if we don't provide a good web browser.
When we started our efforts with WebKit, WebKit2 wasn't ready for our use yet, but today it is more mature and it is time to migrate to it.</p>

<h5>Further reading</h5>

<ul>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li>Project size: 175 or 350 hours, as there is always more things to do in WebKit</li>
<li>Difficulty: medium</li>
<li>Expected outcome: working version of WebPositive browser, able to load and render websites using WebKit2</li>
<li><a href="https://github.com/haiku/haikuwebkit/tree/haiku-webkit2">Sourcecode of WebKit2 work in progress</a></li>
<li><a href="https://www.haiku-os.org/blog/zardshard">GSoC 2024 blog</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Better XMPP instant messaging client for Haiku</h4>

<h5>Idea description</h5>

<p>XMPP is a modern communication protocol for instant messaging. It has open standards and several free software client and server implementations.</p>
<p>Currently, the available native clients for Haiku are quite simple and don't even allow to replace all IRC features. The goal of this project is
to improve <a href="https://github.com/haikuarchives/renga">Renga</a>, one of such clients, to make it possible to migrate Haiku discussion channels over to XMPP instead of IRC.</p>
<p>The main features to implement are more complete support for multi-user chat (in particular, moderation aspects, allowing to manage channel permissions, kick and ban users, etc)
as well as any other feature considered useful: message history browsing, message reactions, activity notification, pictures and file sharing, whiteboard collaboration, â€¦</p>

<h5>Why we need this</h5>

<p>Most of Haiku communication channels are currently hosted on IRC servers. IRC is a
simple protocol, but it lacks modern features and is difficult to use from unstable connections or using mobile phones.
As a result, IRC is less popular, and a part of the Haiku community doesn't use it anymore.</p>
<p>Since we prefer to support open source software and usage of Haiku, XMPP is a good candidate, if we can have a working native client allowing to use it.
We don't want people to instead use closed-source software or undocumented protocols.</p>

<h5>Further reading</h5>

<ul>
	<li>Skill set: userland development, user interface design</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
	<li>Project size: 175 hours or 350 hours depending on the XMPP feature set being implemented</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: improvements to the Renga XMPP client, implementing the full MUC (Multi-User Chat) XEP including moderation aspects, and/or a selection of XEPs (XMPP extensions specifications) to be determined during the GSoC application period.</li>
	<li><a href="https://pulkomandy.tk/projects/renga">Renga XMPP client for Haiku</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>VirtualBox port to Haiku</h4>

<p>VirtualBox is a virtual machine allowing to run an operating system inside of another. Porting it to Haiku would allow Haiku users to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Starting from <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">this preliminary work</a>, continue and complete the port. This includes writing a native GUI for VirtualBox, getting it to run, and more importantly, work on the virtualization driver which will allow virtualbox to run the emulated machine using the native CPU. This makes the emulated system run at close-to-native speed, whereas a software emulation would be unbearably slow.</p>

<ul><li>Skill set: userland development, kernel development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man</li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: hard</li>
	<li>Expected outcome: a version of Virtualbox that runs on Haiku and is able to run other operating systems.</li>
</ul>

<!--
<h4><img src="/images/App_Generic_32.png"/>Hardware acceleration for Haiku's QEMU port</h4>

<p>QEMU is a virtual machine which allows running an operating system inside of another. While there already is a Haiku port, it currently does not support any acceleration system through native virtualization (through Intel VT-x and AMD SVM.) This makes it too slow for many uses. Fixing this would allow Haiku users to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Various systems exist on other operating systems for this, such as <a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">KVM</a> on Linux, <a href="https://wiki.freebsd.org/bhyve">bhyve</a> on FreeBSD and recently (in 2019) <a href="https://blog.netbsd.org/tnf/entry/from_zero_to_nvmm">NVMM</a> was added to NetBSD. Intel also has a cross-platform framework called <a href="https://github.com/intel/haxm">HAXM</a> which only works on their CPUs. All of these work with QEMU, while only some work with other virtual machine technologies like VirtualBox. Of all these NVMM seems to be the easiest to port to Haiku. Bhyve might also be viable, and has been ported to MacOS and Illumos (a Solaris derivative.) A student interested in this project should research NVMM, bhyve and some of the other virtualization systems and describe how they would approach a port to Haiku. Many times these systems make use of kernel technologies that Haiku lacks and so much of this project might involve adding those to Haiku's kernel.</p>

<ul>
<li>Work on a virtualization driver which will allow QEMU to run the emulated machine using the native CPU.</li>
<li>Skill set: kernel development, userland development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man, waddlesplash</li>
<li><a href="https://github.com/mmlr/qemu-haiku">Sourcecode (QEMU for Haiku)</a></li>
<li><a href="https://nxr.netbsd.org/xref/src/sys/dev/nvmm/">NVMM Sourcecode</a></li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: medium/hard</li>
	<li>Expected outcome: NVMM driver ported to Haiku, demonstration of QEMU using said driver to accelerate virtual machines.</li>
</ul>
-->

<h4><img src="/images/Prefs_Devices.png"/>
Devices preferences/Hardware manager
</h4>
<p>Haiku is meant to be an easy to use graphical operating system. It should
provide a GUI to manage devices and drivers. This is currently implemented in
the "Devices" preferences, however it does little more than listing devices
found on the machine.</p>
<p>The goal of this project is to extend the functionality of Devices preferences
to make it a more complete and useful tool. This includes working on the following features:
<ul>
<li>Telling wether a driver is loaded for a given device and where the matching /dev entry is</li>
<li>Giving user readable information on the device type and subtype</li>
<li>Allowing to block/disable the driver for a given device</li>
<li>Support for bluetooth devices (currently not listed at all)</li>
<li>Improved support for USB devices, allowing to inspect interface descriptors (like listusb -v), HID report formats, ...)</li>
<li>Generation of a "compatibility report" to help populate a hardware compatibility database for Haiku</li>
</ul>
</p>
<p>Note that a lot of the work may be in making the required information available
from the drivers and existing device management infrastructure, and not just in
building the GUI itself.</p>

<ul>
	<li>Skill set: user interface, kernel and drivers interfacing (ioctl, devfs...)</li>
	<li>Possible mentors: PulkoMandy, waddlesplash</li>
	<li>Existing code: <a href="https://cgit.haiku-os.org/haiku/tree/src/apps/devices">"Devices"</a></li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: easy/medium</li>
	<li>Expected outcome: finalized version of Devices application, showing extra information about devices, including but not limited to the driver in use for each device.</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Other applications</h4>
<p>There are many open source 3rd party applications for Haiku that could use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale and Layout Kits, or anything else imaginable! Writing applications from scratch is also possible.</p>

<ul>
<li><a href="https://github.com/JadedCtrl/Chat-O-Matic">Chat-O-Matic</a> (IM client)</li>
<li><a href="https://github.com/HaikuArchives/Torrentor">Torrentor!</a> (bittorrent P2P client)</li>
<li><a href="https://github.com/HaikuArchives/Calendar">Calendar</a></li>
<li><a href="https://github.com/HaikuArchives">Many applications at HaikuArchives</a></li>
<li><a href="http://pulkomandy.tk/~beosarchive/">Lots of abandonned projects for BeOS looking for a maintainer</a></li>
</ul>
<ul>
	<li>Skill set: userland development, user interface design, exploring an existing code base, others depending on the application retained.</li>
	<li>Possible mentors/knowledgeable people (depends on chosen application): PulkoMandy, Scott McCreary, Sean Healy, waddlesplash</li>
	<li>Project size: 175 or 350 hours depending on the application being worked on</li>
	<li>Difficulty: easy, depending on the application chosen</li>
	<li>Expected outcome: new release of the chosen application, including fixes to existing tickets from the respective application bugtracker, and/or other features discussed with mentors and the Haiku community during the application period.</li>
</ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>

<h4><img src="/images/webcam.png"/>USB Webcam support</h4>

<p>Haiku lacks support for WebCams following the UVC (USB Video Class) specification. There is an
existing driver, but it is not working. The goal of this project is to investigate problems in the
WebCam driver and get webcams to work smoothly and reliably.</p>

<ul>
	<li>Requirements: USB webcam device (a laptop with built-in webcam should do)</li>
	<li>Skill set: kernel and driver development, USB, C and C++ development</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: medium</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>

<h4><img src="/images/webcam.png"/>USB Audio 2.0 support</h4>

<p>Haiku has a driver for USB Audio sound cards, but it implements only version 1 of the
specification. The goal of this project is to add support for USB Audio 2.0, allowing to handle
more USB Audio hardware.</p>

<ul>
	<li>Requirements: USB Audio compatible device for testing (for example, USB headset or soundcard)</li>
	<li>Skill set: kernel and driver development, USB, C and C++ development</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: medium</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>

<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has ACPI Video Extensions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>


-->


<!-- REMOVED; need investigation, possibly easier to use DragonFlyBSD's compatibility layer to get all drivers from Linux
<h4><img src="/images/App_Generic_32.png"/>Nouveau / PSCNV port</h4>
<p>
Haiku currently doesn't have a driver for NVidia video cards, and falls back to VESA for those. While our VESA driver is reasonably fast, it can't set the native display resolution on all systems, leading to a suboptimal Haiku experience.</p>
<p>
Nouveau is a graphics driver for NVidia video cards.
</p>
<p>Port (parts of) Nouveau to a Haiku graphic driver, allowing at least setting the native video mode. Hardware 3D acceleration may also be investigated, but requires more work on Haiku (see the next project idea).</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>
-->


<h4><img src="/images/Misc_OtherRenderer.png"/>GPU acceleration support</h4>
<p>
Haiku does not currently support GPU acceleration, for 3D or otherwise. Reusing
most of the DRM drivers from Linux, and Mesa's Gallium userspace components,
the goal of this project is to enable the use of GPU-accelerated OpenGL,
and eventually also OpenCL and Vulkan.</p>

<p>Haiku's current video drivers are mostly modesetting-only, and split in two parts: the driver itself, which is
quite minimal and only provides low level access to the video card, and the
"accelerant", which runs inside app_server and communicates with the driver
in order to configure the card and use its features.</p>

<p>Porting the DRM drivers from Linux will be a rather daunting task,
as they use a large subset of the Linux kernel APIs. It may be possible
to reuse OpenBSD's or DragonFlyBSD's work rather than writing our own
Linux API compatibilty layer; more investigation is needed here.</p>

<ul><li>
        Skill set: kernel and driver development, Mesa graphics stack
</li>
<li>Possible mentors/knowledgeable people: waddlesplash</li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: hard</li>
	<li>Expected outcome: proof of concept running an accelerated 3D rendering application based on the ported driver.</li>
</ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4><img src="/images/App_Generic_32.png"/>
Power Management
</h4>

<p>Haiku already has some power management support in the form of a CPU idling driver. This is however clearly not sufficient, and there is room for improvements in several areas in order to make Haiku use less power and make laptops running Haiku last longer on battery.</p>
<p>Some investigation is required to identify the main issues in Haiku leading to suboptimal performance. There are however a few already known problems:</p>
<ul>
<li>Some subsystems such as the network and wireless stack wake up the system at regular intervals (10 or 100 times per second) to perform some tasks. Whenever possible they should be modified to trigger these tasks in an event-driven way (triggering them from hardware interrupts for example).</li>
<li>Some applications (such as the always-running DeskBar) are polling for events in a similar way. The APIs should be adjusted where possible to make those applications wait on notifications instead.</li>
<li>None of the device drivers in Haiku include powersaving modes. When a device is idle, it should be put to sleep and powered off until it is needed again.</li>

<li>Skill set: kernel development, general C/C++, userland development, debugging, power management / measurement</li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: hard</li>
	<li>Expected outcome: improved power management in Haiku code (applications, drivers, ...) with benchmarks to measure the results (this may involve also developping the tools needed for benchmarking)</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Improving the btrfs filesystem
</h4>
<p>Haiku has great support for its own file system, but most others are only
available read-only. It is way better for interoperability with other systems
to be able to write to these disks from Haiku.</p>

<p>The goal of this project is to complete the btrfs filesystem, to allow it
to write btrfs volumes (reading works already). During GSoC 2017 and 2018, students
got as far as creating directories, but it is not possible yet to write
files. The first part of the work is to review the existing code, and report on
the current status and the work needed to get everything in place.</p>

<p>After completion of this project, it should be possible to read and write
files to btrfs volumes, making sure they are interoperable with Linux (mount
without errors, file data is accessible, fsck detects no problems). Stress-testing
should also be performed using bonnie++, and other test suites may also be used.</p>
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, Sean Healy, Hy Che</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/btrfs">Sourcecode</a></li>
<li><a href="https://www.haiku-os.org/blog/hyche">GSoC 2017 log</a></li>
<li><a href="https://www.haiku-os.org/blog/brj">GSoC 2018 log</a></li>
<li><a ref="https://review.haiku-os.org/q/status:open+btrfs">Existing btrfs patches to start from</a></li>
	<li>Project size: 175 or 350 hours depending on the number of features planned to implement</li>
	<li>Difficulty: medium</li>
	<li>Expected outcome: write support for the btrfs filesystem.</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Adding write support for more filesystems</h4>

<h5>Idea description</h5>

<p>Some filesystems can only be read, but not written, from Haiku. The goal of this idea is to add write support for one of these filesystems (of your choice, from the list below).</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Xfs">XFS</a> (<a href="http://xfs.org/index.php/Main_Page">Development community</a>, <a href="http://oss.sgi.com/projects/xfs/index.html">homepage</a>) is a filesystem originally developed for the IRIX operating system. Today it is commonly used by Haiku developers who build Haiku from Linux, because of its better support for extended filesystem attributes (unlike ext4). The read-only support is generally complete but does not use any caching yet. Adjusting the filesystem to use the block and file caches would be a good way to start this project.

<li><a href="http://en.wikipedia.org/wiki/Unix_File_System">UFS2</a> (<a href="https://github.com/freebsd/freebsd/tree/master/sys/ufs/ufs">FreeBSD implementation</a>, <a href="http://sourceforge.net/p/ufs2tools/code/HEAD/tree/trunk/ufs2tools/">u2fstools for windows</a>) is the default filesystem in FreeBSD, commonly used by some Haiku developers as well. It is closely based on the original Unix filesystem, which is implemented in many other operating system. The original design is quite simple, however the different implementations in various systems make it a bit more complex to handle all cases. Focusing specifically on the FreeBSD variant is acceptable for this project if needed. In its current state, the UFS2 driver works in fs_shell but crashes when used as an actual filesystem in Haiku, investigating and fixing this problem would be a good way to start this project.</li>
</ul>

<li>ExFAT is an improved version of Microsoft's FAT filesystem. It is designed for removable drives and used on large size USB thumb drives and SD cards. There is not yet any write support in Haiku's ExFAT driver.</li>

<h5>Why we need this</h5>

<p>In its current state, Haiku is rarely used as the single operating system on a computer. It is common to dual boot it with other systems such as Linux or FreeBSD. In this setup, it is
very convenient when each system can access and modify the other's files. Disk partitions and data can then be shared more easily.</p>

<h5>Further details</h5>

<ul><li>
Skill set: data structures, C++
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
	<li>Project size: 175 or 350 hours (in 175 hours only partial progress will be possible)</li>
	<li>Difficulty: medium</li>
	<li>Expected outcome: write support for the selected filesystem</li>
</ul>

<!-- Removed for now, we have enough filesystems
<h4><img src="/images/App_Generic_32.png"/>
Adding a new filesystem to Haiku
</h4>
<p>Haiku has great support for its own file system, but is completely missing support for some other filesystems. It is way better for interoperability with other systems to be able to read and write to these disks.</p>
<p>The goal of this project is to port one of the following filesystems to Haiku:</p>
<ol>

<li><a href="http://en.wikipedia.org/wiki/JFS_(file_system)">JFS</a>: existing code in Linux is under the GPL, a rewrite under the MIT license is preferred. The <a href="http://jfs.sourceforge.net/project/pub/jfslayout.pdf">filesystem design and disk structures</a> are well documented.</li>


<li>HAMMER FS: <a href="http://www.dragonflybsd.org/hammer/">homepage</a>, <a href="http://fxr.watson.org/fxr/source/vfs/hammer/?v=DFBSD">sourcecode</a> (3-clause BSD, a port of the existing code is ok)</li>

<li><a href="http://en.wikipedia.org/wiki/Zfs">ZFS</a>: <a href="http://www.open-zfs.org/wiki/Main_Page">main page</a>, <a href="https://github.com/illumos/illumos-gate/tree/master/usr/src/uts/common/fs/zfs">existing code</a> (Existing code is under the CDDL, a rewrite is preferred)</li>
</ol>
<p>It's okay to port over the code from other systems, although we prefer code that can be distributed under the MIT license.</p>
<p>It is recommended to start the work by getting an "fs_shell" building for the chosen filesystem. This is a userland tool that runs the filesystem code in a sandbox and provides a simple command prompt allowing to perform single, well controlled operations. Once the filesystem is usable in this mode, it can be integrated, first still running in userland with userland_fs, then later on running as a native kernel filesystem.</p>
-->


<h4><img src="/images/App_Generic_32.png"/>
Filesystems benchmarking and stress-test
</h4>

<p>Some of the filesystems (or specific features of them) in Haiku are
relatively new, and not considered perfectly tested and stable yet. The goal of
this project is to define a procedure for testing the filesystems and identifying
bugs (especially leading to on-disk data corruption) and performance bottlenecks.</p>

<p>Tools like <a href="https://en.wikipedia.org/wiki/Bonnie%2B%2B">bonnie++</a>, <a href="https://github.com/kdave/xfstests">xfstests</a>,
and the existing tests in src/tests/add-ons/kernel/file_systems in Haiku sources should be explored to determine their respective usefulness.
Then, an automated way to run the tests should be defined (unit tests, integration tests on a running system, etc.)</p>

<p>Then, the filesystems should be modified to fix the performance problems and/or bugs that were found in the process.</p>

<ul>
	<li>Skill set: C++ development, testing</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: benchmark results, analysis of bottlenecks, implementation of changes to improve the filesystem and related code (VFS, caches, ...) in Haiku.</li>
</ul>



<!-- Removed for now
<h4><img src="/images/App_Generic_32.png"/>x86-64: Implement support for Process Context Identifiers (PCID)</h4>

<p>on Intel CPUs. The feature tags TLB entries with the Id of the address space and allows to
avoid TLB invalidation on the context switch, it is available only on x86-64.</p>
<p>The goal of this task is to propose possible designs, implement the feature, extend the performance
logs to measure impacts when the feature is enabled, and potentially also to mitigate the
"Meltdown" vulnerability.</p>

<ul><li>
Skill set: kernel development, x86 architecture/assembly language
</li>
<li>Possible mentors/knowledgeable people: korli</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy</li>
</ul>
!-->


<h4><img src="/images/App_Generic_32.png"/>ARM MMU support</h4>

<p>The ARM ports of Haiku (for both 32 and 64 bit systems) are currently not bootable. The main issue appears to be missing or incorrect implementation of memory management.
Since the system is not booting, this blocks any other progress on the ARM port. The goal of this project is to investigate and fix these problems to get the ARM port booting further.</p>

<p>The ARM port of Haiku is currently in an early state. This project may involve debugging other issues in the port to get it running further.</p>

<ul><li>
Skill set: kernel development, ARM architecture/assembly
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, kallisti5</li>
	<li>Project size: 175 hours (just fixing the first issues) or 350 hours (attempt to boot to the desktp)</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: the ARM port of Haiku is bootable on at least one reference hardware (or emulated hardware).</li>
</ul>


<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>Unify File System Caches</h4>

<p>
The Haiku kernel provides two kinds of caches for use by file system implementations: the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/file_cache.cpp">file cache</a> and the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/block_cache.cpp">block cache</a>. The file cache caches data at the "file" level, while the block cache is used at the "block" level and is used for on-disk structures as well as file data.</p>

<p>The file cache uses physical memory pages directly and it is linked with the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/vm">VM subsystem</a>, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/slab">slab allocator</a>) and freeing memory in low memory situations is handled via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/low_resource_manager.cpp">low resource manager</a>.</p>

<p>The first problem with the current implementation is caching imbalance in favor of the block cache: it tends to grow more than needed preventing the file cache to get enough memory.</p>
<p>Another problem is the use of large amounts of kernel address space by the block cache, which can be problematic on 32 bit architectures. This makes the block cache constrained to the 2GB of memory available for the kernel in Haiku, and sometimes makes the kernel run out of address space for other uses.</p>

<p>The goal of this project is to create a common underlying mechanism (using `VMCache`) to unify both caches and move the block cache out of the kernel address space. The following problems need to be investigated and solved:
<ul>
<li>How to deal with heterogenous block sizes (not necessarily matching the page size): each mounted filesystem volume may have a different block size, and the block cache must be able to efficiently cache blocks of these different sizes,
<li>How to map support for transactions to `VMCache` hierarchies,
<li>Balancing the memory allocation between the block and the file cache and between multiple mounted filesystem volumes.
</ul>
</p>
<ul><li>
Skill set: kernel development
</li></ul>
-->


<a id="network" name="network"></a>
<h3>Network</h3>


<h4><img src="/images/App_Generic_32.png"/>
Bluetooth Stack Improvements
</h4>
<p>Haiku's Bluetooth stack implements a basic subset of general Bluetooth functionality. This functionality needs to be
completed and Bluetooth 2.X and later possibilities explored. This task involves investigating the current state of the
Bluetooth code, improving the existing code on newer devices (pairing, etc), and improving the stack
to make it more useful by implementing driver(s) for Bluetooth device(s) of your choice (file transfers, audio, HID,
networking, etc).</p>

<ul>
<li>Requirements: Bluetooth-enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge (optional)</li>
<li>Possible mentors/knowledgeable people: waddlesplash <!-- also possibly PulkoMandy --></li>
	<li>Project size: 175 hours or 350 hours (depending on how much of the stack is added)</li>
	<li>Difficulty: medium</li>
	<li>Expected outcome: the Bluetooth stack can be used for more than just pairing devices. For example, bluetooth audio or bluetooth HID drivers can be used.</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Integrate our PPP implementation
</h4>
<p>Finish porting the PPP implementation to our new network stack. Add phone-line modem support, including HDLC
framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT).
Implement CHAP authentication, and add support for configuring these to the new network preflet GUI. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: it is possible to connect Haiku to a PPP modem</li>
</ul>

<!--

<h4><img src="/images/App_Generic_32.png"/>
Stream Control Transmission Protocol (SCTP)
</h4>
<p>Implement and test SCTP, a message based transport layer protocol similar to TCP and UDP. It should comply with current IP and IPv6 implementations and provide similar programming API as BSD.</p>
<ul>
<li>Skill set: network protocols, kernel and network stack development</li>
</ul>
-->

<h4><img src="/images/App_Generic_32.png"/>
IPv6 finalization and stabilization
</h4>
<p>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project.
Even so, there remains a lot of smaller cleanup/finalization tasks that can be done as a project.
</p>
<ul>
<li>Tickets to be investigated as part of this project (non-exhaustive list):
<ul>
<li><a href="https://dev.haiku-os.org/query?status=!closed&component=Network+%26+Internet%2FIPv6">Trac tickets for IPv6</a></li>
<li><a href="https://dev.haiku-os.org/ticket/7228">#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/8319">#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/11862">#11862</a> -- Net server multi-protocol rework</li>
</ul>
</li>
</ul>

<ul>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development</li>
<li>Possible mentors: </li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: IPv6 auto-configuration works, and it is possible to access website and other internet services over IPv6</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>MDNS / Bonjour / Avahi network discovery</h4>

<h5>Idea description</h5>

<p>MDNS (known as Bonjour for Apple devices and usually implemented using Avahi on Linux) is a protocol allowing to discover devices in the local network and their capabilities. The goal of this project is to implement MDNS in Haiku and integrate it in our name resolution system and user interface.</p>

<h5>Why we need this</h5>

<p>MDNS is part of the IPP Everywhere and Airprint specifications, which allow to use networked printers with a single generic driver, instead of a specific driver for each printer. Having an implementation in Haiku would allow easier setup and use of printers, a required feature for a desktop operating system.</p>

<h5>Further details</h5>

<ul>
	<li>Skill set: network programming (UDP, IPv4, multicast)</li>
	<li>Possible mentors: PulkoMandy</li>
	<li>Project size: 175 hours (350 hours with extra goals such as UI integration, IPP printers support, etc)</li>
	<li>Difficulty: medium</li>
	<li>Expected outcome: proof of concept application listing MDNS machines and services as they are discovered. Other machines on the network can also see the Haiku machine as it advertises itself.</li>
</ul>

<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<!-- removed: needs to be thought out on the mailing list a little better
<h4><img src="/images/App_Generic_32.png"/>
Preferences GUI refactoring
</h4>
<p>
Haiku is an operating system designed for ease of use on desktop computers. A key part of this work is an easy to use set of preference applications. Some of the currently available preference panels could be merged or improved in several ways.</p>
<p>
Several preference applications (aka preflets) could be redesigned. Furthermore, there might still be code that does not yet use our layout API. This work may include (but is not limited to):</p>
<ol>
<li>Integrating keymap preferences into input preferences,</li>
<li>adding support for joysticks and touch screens to input preferences,</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Reworking the Printer preferences to look better and be more intuitive.</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet, and provide a live preview for all of the settings available in this window</li>
<li>Improving the user interface of the shortcuts preference to make it easier to setup custom shortcuts</li>
<li>Improving and extending the notifications preferences to allow easy control of allowed notifications, browsing of the notification history.</li>
<li>Research on how to improve the other preference panels further with the goal of making them easier to use.</li>
</ol>
<ul>
<li>Skill set: C++, UI development, usability basics</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>
-->

<h4><img src="/images/App_Generic_32.png"/>
Modular edit view (BIG)
</h4>

<p>The current solution for text editing in Haiku is the BTextView. It is a
rather simple view providing basic text editing features and limited styling.
This is, however, not powerful enough for most serious uses. The goal of this
project is to design a complete replacement for BTextView, which should be designed
to cover more use cases.</p>

<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:
<ul>
<li>Advanced text decorations and formatting: wavy underlines, strikethrough, exponents, ...</li>
<li>spell checker, line numbers, ruler</li>
<li>working on an input stream rather than on an input file, e.g. to be able to open files ~100Mb without loading them into memory in one go</li>
<li>Including pictures in the text flow</li>
<li>Automatic line breaks using locale specific rules (insertion of word breaks, handling of language with no whitespace between words)</li>
<li>Ability to load and save data in different formats such as RTF, ODT, ... (using the Translation Kit)</li>
</ul>
</p>

<h5>Existing work</h5>
<p>The HaikuDepot application includes <a href="https://cgit.haiku-os.org/haiku/tree/src/apps/haikudepot/textview">preliminary work on a rich text view</a>,
which it uses to provide the description of packages. This could be used as a
starting point for this work.</p>

<ul>
	<li>Skill set: C++, API design, UI development</li>
	<li>Possible mentors: waddlesplash, Sean Healy, scottmc</li>
	<li>Project size: 350 hours (175 hours if working only on a much smaller subset)</li>
	<li>Difficulty: hard</li>
	<li>The edit view is more widely available for Haiku applications, and implement a selection of the items outlined in the list above (to be selected during the application period after discussion with the mentors and community)</li>
</ul>


<!--
<a id="media" name="media"></a>
<h3>Media</h3>
-->

<!-- needs to be discussed more; working on a MediaKit2 may make more sense. (Didn't Dan0 have MediaKit2?)
<h4><img src="/images/App_Generic_32.png"/>Add subtitle support to the Media Kit</h4>

<p>Haiku "media" applications rely on a framework called the Media Kit. This
provides a unified API to handle audio and video streams, including codec
plugins to read and write the stream to files or other sources, as well as
transporting the data from one application to another, with a latency as low as
possible.</p>

<p>While our MediaPlayer has support for external subtitle files, the Media Kit
itself has not. The most obvious downside of that is that there is no support
for subtitle (text or bitmap) embedded in video files within the MediaPlayer or
other applications.</p>

<p>Your job would be to design the necessary API extensions to let subtitles fit
in with the rest of the Media Kit, and add native support for them, which will
then be available to all applications as part of the framework.</p>

<ul>
<li>implement the required code to extract the subtitles from source files
(either standalone .srt files or contained for example in mkv containers), with
proper handling of replay time and text encoding</li>

<li>integrate this in the existing API (probably as a new kind of BMediaTrack),
and update applications such as MediaPlayer and MediaConverter to make use of
the feature.</li>

<li>See <a href="/legacy-docs/bebook/TheMediaKit_Overview_Introduction.html" target="_blank">
the BeBook introduction for the Media Kit</a> to become familiar with its design.</li>

<li>Skill set: general C/C++, userland development, API design</li>
<li>Possible mentors: PulkoMandy</li>
</ul>
-->

<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>Complete and Finalize the MediaPlayer Plugin API</h4>

<p>The MediaPlayer app included in Haiku is able to play most of the media
formats around. To be able to do that it includes a monolithic framework that
uses most of the important features of the media_kit. To improve maintainability
and flexibility we are looking forward to include a plugin API and export or
implement as plugins certain functionalities.</p>

<p>
Some examples :
<ul>
	<li>Playlist</li>
	<li>Attributes editor</li>
	<li>Cover Art</li>
	<li>Web Remote Control</li>
</ul>
</p>

<p>
Some efforts have been already put and can be found <a href="https://github.com/Barrett17/haiku/tree/mediaplayer_plugin_api">here</a>.</p>

<p>Other Links:

<ul>
	<li><a href="https://www.haiku-os.org/legacy-docs/bebook/themediakit_overview">Media Kit overview (the Be Book)</a></li>
	<li><a href="https://api.haiku-os.org/group__media.html">Media Kit overview (the Haiku Book)</a></li>
</ul>
</p>

<ul>
	<li>Skill set: general C++, userland development, software design</li>
	<li>Possible mentors: </li>
</ul>
-->


<!--
<h4><img src="/images/App_Generic_32.png"/>
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
<li>Possible mentors: </li>
</ul>
-->


<a id="ports" name="ports"></a>
<h3>Ports</h3>


<h4><img src="/images/App_Generic_32.png"/>
Porting the Go Programming Language to Haiku
</h4>

<p>Go (or Golang) is a popular cross-platform general-purpose programming language which is known
for its direct compilation to static executables, concurrency model used in its goroutines and its
enforced standard style of programming. It has been used by many developers to create command-line
tools, static site generators, high-performance servers and many other applications requiring Go.

<h5>Existing work</h5>

There was a previous GSoC student who originally ported Go 1.3 to Haiku, but unfortunately it was
unmaintained and was broken over the years. In 2018, the port was later updated to Go 1.4.3 but
only for 64 bit. Work has been attempted in bootstrapping higher versions like 1.5 and 1.11 but
the bootstrap process have produced binaries that are broken and don't work.

An attempt with Go 1.18 went further, and is able to cross compile executables from Linux. Now,
this can be used to attempt to build Go itself so the tools (compiler and other related tools) run
on Haiku themselves.

<em>Please note that this port may require diving into the low-level components of the compiler and Haiku internals.</em>

<p>Links:
<ul>
	<li><a href="https://discuss.haiku-os.org/t/help-with-porting-golang/11185/11">Forum thread discussing the porting efforts</a></li>
	<li><a href="https://github.com/korli/go/tree/golang-1.18-haiku">Go 1.18 Haiku port (GitHub)</a></li>
	<li><a href="https://github.com/golang-haiku/go/tree/golang-1.11-haiku">Go 1.11 Haiku port (GitHub)</a></li>
	<li><a href="https://github.com/golang-haiku/go-1.4.3">Go 1.4.3 port (Bootstrapper)</a></li>
	<li><a href="https://bitbucket.org/zhuowei/go-1-3-haiku/src/default/">Previous GSoC Go port (Bitbucket)</a></li>
</ul>
</p>

<ul>
	<li>Skill set: C, Go, Go assembly, low-level programming, ELF-internals </li>
	<li>Possible mentors: return0e, BGA</li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: medium</li>
	<li>Expected outcome: an up to date version of Go running on Haiku and packaged in HaikuPorts</li>
</ul>

<a id="other" name="other"></a>
<h3>Other</h3>

<h4><img src="/images/App_Generic_32.png"/>
Improvements to Haiku-format coding style checker
</h4>
<p>Haiku has its own <a href="/development/coding-guidelines/">coding guidelines</a>
which describe how the code should be formatted. There is <a href="https://github.com/owenca/haiku-format">a tool</a> (based on clang-format) for reformatting
or checking if code follows these guidelines, used in the continuous integration and code review process.</p>
<p>However, the tool does not fully implement the coding style and currently suggests many changes that are, in fact, not correct.
The goal of this project is to improve the tool to get it closer to Haiku's code style.</p>
<ul>
	<li>Skill set: REST APIs, code formatting tools</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library. Older version (4.4) did support Haiku, but this
support was dropped from the newer versions (starting from 5.0). The library
should be ported to Haiku, allowing to run the bundled examples and possibly
port some other software using it.</p>

<ul>
	<li>Skill set: C++, userland development</li>
	<li>Possible mentors: scottmc</li>
	<li>Alternative projects: porting SFML or another similar library</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy</li>
	<li>Expected outcome: Allegro 5 running on Haiku with all features</li>
</ul>


<!-- REMOVED: needs more thinking on Haiku side to decide on a plan for this.

<h4><img src="/images/App_Generic_32.png"/>
Modify the app_server to support compositing
</h4>
<p>This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows, transparent windows, content previews, and window animations.</p>
<p>There's lots of info on what would need to be done and how to go about it in this article: /articles/2011-06-15_how_transform_app_server_code_use_compositing .</p>
<ul>
<li>Skill set: C++, graphics development</li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>
Multiple monitors output in app_server
</h4>
<p>app_server is Haiku's graphics server and the equivalent of X11 or Wayland on other UNIX systems. It currently supports only one video output, but should be able to do more.</p>
<p>While the API already allows this for the most part (with the BScreen class), there is no actual implementation behind it and parts of the code assume only a single screen.</p>
<p>Some drivers implement minimal support for multiple displays, but not all of them. This task may involve updating the video drivers to handle multiple monitors correctly.</p>
<ul>
<li>Skill set: C++, graphics development</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
	<li>Project size: 350 hours</li>
	<li>Difficulty: medium/hard</li>
	<li>Expected outcome: implementation of the needed changes in app_server APIs and accelerant APIs to properly support multiple displays. Reference implementation either in test_app_server or in one of the existing graphics drivers on real or emulated hardware.</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
	Complex font rendering in app_server
</h4>
<p>app_server is the graphics server in Haiku. It handles the rendering and
display of application windows, desktop, and everything that is shown on screen.</p>
<p>Freetype (in combination with agg) is used to render text. While it provides
good results for latin and cyrillic alphabets, Freetype is not enough
on its own to properly render other scripts with more complex rules, such as
Devanagari or Arabic.</p>
<p>The goal of this task is to integrate Harfbuzz into app_server, so that the
complex rules for text rendering are properly applied. This would allow rendering
of complex languages as mentioned above, as well as mixing different languages
(picking appropriate fonts automatically).</p>
<p>This task can be further extended with investigations of API changes required
in the interface kit (and in particular BView and BFont) to properly handle
right to left text.</p>

<ul>
	<li>Skill set: C++</li>
	<li>Possible mentors: stippi, PulkoMandy</li>
	<li>Project size: 175 hours</li>
	<li>Difficulty: easy/medium</li>
	<li>Expected outcome: working font rendering for arabic or devanagari or other script with "complex" rendering rules.</li>
</ul>

<!--
<h4><img src="/images/App_Generic_32.png"/>
RTL languages support in interface kit
</h4>
<p>The interface kit is the part of the API taking care of everything drawing related: windows, buttons, and other widgets. It is not currently able to display right-to-left languages (such as arabic) properly, making Haiku unusable for a lot of people.</p>
<p>Font rendering should be reworked to use the HarfBuzz library, instead of just Freetype, providing support for ligatures and bidirectional text output. The Layout Kit (which handles positioning widgets in a window) should be made to work as expected with these languages (possibly inverting left and right in the window layout).</p>
<p>This task can be extended with better support for font overlays (picking the correct font for each language automatically, probably using fontconfig), and work on input methods for some languages.</p>
<ul>
<li>Skill set: C++, graphics development, text rendering</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>
-->
