+++
type = "article"
title = "Ideas"
date = "2020-08-06"
tags = []
+++

<p>For information about Haiku's participation in GSoC this year, please see <a href="/community/gsoc/2021">this page</a>.</p>
<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below).
For details about how to apply, please check out <a href="/community/gsoc/2021/students">Students: How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>The most successful <i>Google Summer of Code</i> projects are often those proposed by the students themselves.
The following list represents some of our ideas and wishes for the project. However, suggesting your own idea is always encouraged!</p>
</div>

<p>Be aware: API design and kernel-related work requires a higher level of skill, and
user interface design usually involves a lot more thought than other work. A
significantly more convincing proposal is required for tasks involving those.
Getting started with the design early (before the application period ends) is
recommended, to maximize your chances of being selected, and allow a larger part
of the coding period dedicated to coding tasks.</p>

<p>If you find one of the "big" ideas interesting, but feel that you cannot
complete it within the allotted coding time, feel free to suggest splitting it
into smaller parts for your proposal.</p>

<p>Students that intend to submit applications on ideas which are also part of
other accepted mentoring organizations must coordinate with both Haiku and the
other mentoring organization beforehand.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File Systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User Interface</a></li>
<li><a href="#ports">Porting</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<!-- on hold until webkit2 is ready, there's little point otherwise
<h4><img src="/images/App_Generic_32.png"/>Updating and Extending WebPositive</h4>
<p>
Haiku uses a WebKit based browser called WebPositive. The browser is still quite
simple and can be improved in multiple ways. Some of the missing features are:
</p>
<ul>
<li>Advanced session management. There is minimal support for restoring tabs
from the last closed window, but a more complete solution is desirable. The web
browser should be able to store its whole state (multiple windows and tabs) to
a session file, and restore the state from that file.</li>
<li>Management of broken HTTPS certificates. There should be a way to remember
exceptions to the system-wide certificate list.</li>
<li>Support for browser extensions, such as ad-block. This could be done either
reusing extensions from other browsers (if possible), or using the native
add-ons system.</li>
<li>Skill set: userland development, user interface design and programming</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/apps/webpositive">Source code</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>Improving Haiku's WebKit2 port</h4>

<h5>Idea description</h5>

<p>Haiku has a native WebKit port which uses the WebKit1 API. This port is not complete and there are several bugs and minor problems which need to be fixed.
The plan is to replace this with a more up to date port based on the WebKit2 API. Based on the work completed in GSoC 2019, WebKit2 on Haiku is now able to render some web pages.
The goal of this project is to continue this work, making the WebKit2 port more reliable, render all pages, handle input events, etc, and make it usable for the WebPositive browser.</p>

<h5>Why we need this</h5>

<p>The web browser is an important part of the operating system today. It is difficult to attract and retain users if we don't provide a good web browser.
When we started our efforts with WebKit, WebKit2 wasn't ready for our use yet, but today it is more mature and it is time to migrate to it.</p>

<h5>Further reading</h5>

<ul>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://github.com/haiku/haikuwebkit/pull/4">Sourcecode of GSoC 2019 work</a></li>
<li><a href="https://www.haiku-os.org/blog/rajagopalan">GSoC 2019 blog</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Better XMPP instant messaging client for Haiku</h4>

<h5>Idea description</h5>

<p>XMPP is a modern communication protocol for instant messaging. It has open standards and several free software client and server implementations.</p>
<p>Currently, the available native clients for Haiku are quite simple and don't even allow to replace all IRC features. The goal of this project is
to improve <a href="https://github.com/haikuarchives/renga">Renga</a>, one of such clients, to make it possible to migrate Haiku discussion channels over to XMPP instead of IRC.</p>
<p>The main features to implement are more complete support for multi-user chat (in particular, moderation aspects, allowing to manage channel permissions, kick and ban users, etc)
as well as any other feature considered useful: activity notification, pictures and file sharing, whiteboard collaboration, â€¦</p>

<h5>Why we need this</h5>

<p>Most of Haiku communication channels are currently hosted on IRC servers. IRC is a
simple protocol, but it lacks modern features and is difficult to use from unstable connections or using mobile phones.
As a result, IRC is less popular, and a part of the Haiku community doesn't use it anymore.</p>
<p>Since we prefer to support open source software and usage of Haiku, XMPP is a good candidate, if we can have a working native client allowing to use it.
We don't want people to instead use closed-source software or undocumented protocols.</p>

<h5>Further reading</h5>

<ul>
	<li>Skill set: userland development, user interface design</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>VirtualBox port to Haiku</h4>

<p>VirtualBox is a virtual machine allowing to run an operating system inside of another. Porting it to Haiku would allow Haiku users to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Starting from <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">this preliminary work</a>, continue and complete the port. This includes writing a native GUI for VirtualBox, getting it to run, and more importantly, work on the virtualization driver which will allow virtualbox to run the emulated machine using the native CPU. This makes the emulated system run at close-to-native speed, whereas a software emulation would be unbearably slow.</p>

<ul><li>Skill set: userland development, kernel development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Hardware acceleration for Haiku's QEMU port</h4>

<p>QEMU is a virtual machine which allows running an operating system inside of another. While there already is a Haiku port, it currently does not support any acceleration system through native virtualization (through Intel VT-x and AMD SVM.) This makes it too slow for many uses. Fixing this would allow Haiku users to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Various systems exist on other operating systems for this, such as <a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">KVM</a> on Linux, <a href="https://wiki.freebsd.org/bhyve">bhyve</a> on FreeBSD and recently (in 2019) <a href="https://blog.netbsd.org/tnf/entry/from_zero_to_nvmm">NVMM</a> was added to NetBSD. Intel also has a cross-platform framework called <a href="https://github.com/intel/haxm">HAXM</a> which only works on their CPUs. All of these work with QEMU, while only some work with other virtual machine technologies like VirtualBox. Of all these NVMM seems to be the easiest to port to Haiku. Bhyve might also be viable, and has been ported to MacOS and Illumos (a Solaris derivative.) A student interested in this project should research NVMM, bhyve and some of the other virtualization systems and describe how they would approach a port to Haiku. Many times these systems make use of kernel technologies that Haiku lacks and so much of this project might involve adding those to Haiku's kernel.</p>

<ul>
<li>Work on a virtualization driver which will allow QEMU to run the emulated machine using the native CPU.</li>
<li>Skill set: kernel development, userland development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man, waddlesplash</li>
<li><a href="https://github.com/mmlr/qemu-haiku">Sourcecode (QEMU for Haiku)</a></li>
<li><a href="https://nxr.netbsd.org/xref/src/sys/dev/nvmm/">NVMM Sourcecode</a></li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
Devices preferences/Hardware manager
</h4>
<p>Haiku is meant to be an easy to use graphical operating system. It should
provide a GUI to manage devices and drivers. This is currently implemented in
the "Devices" preferences, however it does little more than listing devices
found on the machine.</p>
<p>The goal of this project is to extend the functionality of Devices preferences
to make it a more complete and useful tool. This includes working on the following features:
<ul>
<li>Telling wether a driver is loaded for a given device and where the matching /dev entry is</li>
<li>Giving user readable information on the device type and subtype</li>
<li>Allowing to block/disable the driver for a given device</li>
<li>Support for USB and bluetooth devices (currently not listed at all)</li>
<li>Generation of a "compatibility report" to help populate a hardware compatibility database for Haiku</li>
</ul>
</p>
<p>Note that a lot of the work may be in making the required information available
from the drivers and existing device management infrastructure, and not just in
building the GUI itself.</p>

<ul>
	<li>Skill set: user interface, kernel and drivers interfacing (ioctl, devfs...)</li>
	<li>Possible mentors: PulkoMandy, waddlesplash</li>
	<li>Existing code: <a href="https://cgit.haiku-os.org/haiku/tree/src/apps/devices">"Devices"</a></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Other applications</h4>
<p>There are many open source 3rd party applications for Haiku that could use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale and Layout Kits, or anything else imaginable! Writing applications from scratch is also possible.</p>

<ul>
<li><a href="https://github.com/Barrett17/Caya">Caya</a> (IM client)</li>
<li><a href="https://github.com/HaikuArchives/Torrentor">Torrentor!</a></li>
<li><a href="https://github.com/HaikuArchives/Calendar">Calendar</a></li>
<li><a href="https://github.com/HaikuArchives">Many applications at HaikuArchives</a></li>
<li><a href="http://pulkomandy.tk/~beosarchive/">Lots of abandonned projects for BeOS looking for a maintainer</a></li>
</ul>
<ul><li>
Skill set: userland development, user interface design, exploring an existing code base, others depending on the application retained.
</li>
<li>Possible mentors/knowledgeable people (depends on chosen application): PulkoMandy, Sean Healy, waddlesplash</li>
</ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>

<h4><img src="/images/Prefs_Devices.png"/>
	Improving intel video driver
</h4>

<p>Haiku comes with a video driver for intel chipsets. However, on many supposedly supported devices, the driver will
only produce a black screen with no output, confusing users and forcing them to fallback to VESA video modes.
</p>
<p>The goal of this project is to improve the driver and fix the different problems, making sure we get video output
working on all supported devices. This includes support for HDMI, DisplayPort and VGA outputs.</p>
<p>Intel provides documentation for each generation of device, a lot of the work is figuring out what the differences
between generations are, and which part the driver is currently not properly implementing.</p>

<ul><li>Skill set: drivers development</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
USB Support for FreeBSD network compatibility layer
</h4>

<p>Haiku uses a FreeBSD network compatibility layer to support many network devices (ethernet and wireless) using drivers written for the FreeBSD project. This allows reusing network drivers with very little changes, considerably decreasing the effort needed to get good hardware support in Haiku.</p>
<p>However, this layer only supports PCI devices, and doesn't work with USB ones. Adding support for USB to the compatibility layer would bring us support for a range of devices like so-called USB tethering, as well as USB to Ethernet and WiFi dongles.</p>

<p>This project consists in importing one or more USB network drivers from FreeBSD into Haiku sources. The compatibility layer should then be extended to expose the FreeBSD USB APIs to the drivers, and forward the calls to Haiku's USB stack. Other parts of the compatibility layers may need to be extended as well.
</p>
<p>This should be tested either with real hardware or an emulated device in a virtual machine.</p>

<ul>
<li>Skill set: kernel and driver development, USB, general C and C++ development</li>
<li>Possible mentors: waddlesplash, korli</li>
</ul>


<!-- USB isochronous appears to work well enough, to be revisited with more focus
	on the webcam and audio drivers
<h4><img src="/images/webcam.png"/>
Isochronous USB transfers (USB Webcam &amp; soundcard support)
</h4>
<p>Currently Haiku has very limited support for webcams and USB sound cards.
The goal of this task is to improve the WebCam or USB audio drivers, in order
to make them production ready. For both of these, the USB specification has a
well-documented standardized way to communicate with the devices. Haiku has a
working driver for sound cards, and an incomplete one for webcams.</p>

<p>The main area of work for this project would be getting isochronous USB
transfers to work in Haiku. The USB specification defines various types of
transfers on the USB bus, which affects the scheduling and how the data is
exchanged between the computer and USB devices. The isochronous mode is used
for low latency applications where a reliable and predictible timing is
required (as is the case for video and audio streams).</p>

<p>Unfortunately, Haiku implements these transfers completely only for some
USB1 controllers. There is partial support, but it is not fully working.</p>

<p>The first part of this task is to investigate the state of isochronous
transfers and what is missing to get them working. Then, of course, actually
making things work. Once this part is sorted out, the audio and webcam drivers
may also need some work to get everything running smoothly.</p>

<ul>
	<li>Requirements: USB audio or webcam device (a laptop with built-in webcam should do)</li>
	<li>Skill set: kernel and driver development, USB, C and C++ development</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>
-->


<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has ACPI Video Extensions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>


-->


<!-- REMOVED; need investigation, possibly easier to use DragonFlyBSD's compatibility layer to get all drivers from Linux
<h4><img src="/images/App_Generic_32.png"/>Nouveau / PSCNV port</h4>
<p>
Haiku currently doesn't have a driver for NVidia video cards, and falls back to VESA for those. While our VESA driver is reasonably fast, it can't set the native display resolution on all systems, leading to a suboptimal Haiku experience.</p>
<p>
Nouveau is a graphics driver for NVidia video cards.
</p>
<p>Port (parts of) Nouveau to a Haiku graphic driver, allowing at least setting the native video mode. Hardware 3D acceleration may also be investigated, but requires more work on Haiku (see the next project idea).</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>
-->


<h4><img src="/images/Misc_OtherRenderer.png"/>GPU acceleration support</h4>
<p>
Haiku does not currently support GPU acceleration, for 3D or otherwise. Reusing
most of the DRM drivers from Linux, and Mesa's Gallium userspace components,
the goal of this project is to enable the use of GPU-accelerated OpenGL,
and eventually also OpenCL and Vulkan.</p>

<p>Haiku's current video drivers are mostly modesetting-only, and split in two parts: the driver itself, which is
quite minimal and only provides low level access to the video card, and the
"accelerant", which runs inside app_server and communicates with the driver
in order to configure the card and use its features.</p>

<p>Porting the DRM drivers from Linux will be a rather daunting task,
as they use a large subset of the Linux kernel APIs. It may be possible
to reuse OpenBSD's or DragonFlyBSD's work rather than writing our own
Linux API compatibilty layer; more investigation is needed here.</p>

<ul><li>
        Skill set: kernel and driver development, Mesa graphics stack
</li>
<li>Possible mentors/knowledgeable people: waddlesplash, PulkoMandy</li>
</ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4><img src="/images/App_Generic_32.png"/>
Power Management
</h4>

<p>Haiku already has some power management support in the form of a CPU idling driver. This is however clearly not sufficient, and there is room for improvements in several areas in order to make Haiku use less power and make laptops running Haiku last longer on battery.</p>
<p>Some investigation is required to identify the main issues in Haiku leading to suboptimal performance. There are however a few already known problems:</p>
<ul>
<li>Some subsystems such as the network and wireless stack wake up the system at regular intervals (10 or 100 times per second) to perform some tasks. Whenever possible they should be modified to trigger these tasks in an event-driven way (triggering them from hardware interrupts for example).</li>
<li>Some applications (such as the always-running DeskBar) are polling for events in a similar way. The APIs should be adjusted where possible to make those applications wait on notifications instead.</li>
<li>None of the device drivers in Haiku include powersaving modes. When a device is idle, it should be put to sleep and powered off until it is needed again.</li>

<li>Skill set: kernel development, general C/C++, userland development, debugging, power management / measurement</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Improving the btrfs filesystem
</h4>
<p>Haiku has great support for its own file system, but most others are only
available read-only. It is way better for interoperability with other systems
to be able to write to these disks from Haiku.</p>

<p>The goal of this project is to complete the btrfs filesystem, to allow it
to write btrfs volumes (reading works already). During GSoC 2017 and 2018, students
got as far as creating directories, but it is not possible yet to write
files. The first part of the work is to review the existing code, and report on
the current status and the work needed to get everything in place.</p>

<p>After completion of this project, it should be possible to read and write
files to btrfs volumes, making sure they are interoperable with Linux (mount
without errors, file data is accessible, fsck detects no problems). Stress-testing
should also be performed using bonnie++, and other test suites may also be used.</p>
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, Sean Healy, Hy Che</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/btrfs">Sourcecode</a></li>
<li><a href="https://www.haiku-os.org/blog/hyche">GSoC 2017 log</a></li>
<li><a href="https://www.haiku-os.org/blog/brj">GSoC 2018 log</a></li>
<li><a ref="https://review.haiku-os.org/q/status:open+btrfs">Existing btrfs patches to start from</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
Porting Apple NTFS driver to Haiku
</h4>

<p>Haiku currently supports NTFS using code from the NTFS-3G project, which is
distributed under the GPL license. We would prefer to use Apple implementation,
which is under 3 clause BSD, more suitable for us.</p>
<p>Investigate the code in Apple NTFS driver and see how to map it to Haiku
filesystem APIs, either by adding a compatibility wrapper (preferred, it makes
updates easier), or by adjusting the NTFS code.</p>

<ul><li>Skill set: filesystems, C, C++</li>
	<li>Possible mentors: waddlesplash, PulkoMandy</li>
	<li><a href="https://opensource.apple.com/source/ntfs/ntfs-94.200.1/">Apple NTFS sourcecode</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Adding write support for more filesystems</h4>

<h5>Idea description</h5>

<p>Some filesystems can only be read, but not written, from Haiku. The goal of this idea is to add write support for one of these filesystems (of your choice, from the list below).</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Xfs">XFS</a> (<a href="http://xfs.org/index.php/Main_Page">Development community</a>, <a href="http://oss.sgi.com/projects/xfs/index.html">homepage</a>) is a filesystem originally developed for the IRIX operating system. Today it is commonly used by Haiku developers who build Haiku from Linux, because of its better support for extended filesystem attributes (unlike ext4).

	Update: You are recommended to look at the current status of XFS. We are in the process of merging XFS v2. XFS v3 has been out for a long time and bringing read support for it could be a better idea before jumping to providing write support. This may require some discussion and we encourage you to reach out to us.</li>
<li><a href="http://en.wikipedia.org/wiki/Unix_File_System">UFS2</a> (<a href="https://github.com/freebsd/freebsd/tree/master/sys/ufs/ufs">FreeBSD implementation</a>, <a href="http://sourceforge.net/p/ufs2tools/code/HEAD/tree/trunk/ufs2tools/">u2fstools for windows</a>) is the default filesystem in FreeBSD, commonly used by some Haiku developers as well. It is closely based on the original Unix filesystem, which is implemented in many other operating system. The original design is quite simple, however the different implementations in various systems make it a bit more complex to handle all cases. Focusing specifically on the FreeBSD variant is acceptable for this project if needed.</li>
</ul>

<h5>Why we need this</h5>

<p>In its current state, Haiku is rarely used as the single operating system on a computer. It is common to dual boot it with other systems such as Linux or FreeBSD. In this setup, it is
very convenient when each system can access and modify the other's files. Disk partitions and data can then be shared more easily.</p>

<h5>Further details</h5>

<ul><li>
Skill set: data structures, C++
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash, Hy Che</li>
</ul>

<!-- Removed for now, we have enough filesystems
<h4><img src="/images/App_Generic_32.png"/>
Adding a new filesystem to Haiku
</h4>
<p>Haiku has great support for its own file system, but is completely missing support for some other filesystems. It is way better for interoperability with other systems to be able to read and write to these disks.</p>
<p>The goal of this project is to port one of the following filesystems to Haiku:</p>
<ol>

<li><a href="http://en.wikipedia.org/wiki/JFS_(file_system)">JFS</a>: existing code in Linux is under the GPL, a rewrite under the MIT license is preferred. The <a href="http://jfs.sourceforge.net/project/pub/jfslayout.pdf">filesystem design and disk structures</a> are well documented.</li>


<li>HAMMER FS: <a href="http://www.dragonflybsd.org/hammer/">homepage</a>, <a href="http://fxr.watson.org/fxr/source/vfs/hammer/?v=DFBSD">sourcecode</a> (3-clause BSD, a port of the existing code is ok)</li>

<li><a href="http://en.wikipedia.org/wiki/Zfs">ZFS</a>: <a href="http://www.open-zfs.org/wiki/Main_Page">main page</a>, <a href="https://github.com/illumos/illumos-gate/tree/master/usr/src/uts/common/fs/zfs">existing code</a> (Existing code is under the CDDL, a rewrite is preferred)</li>
</ol>
<p>It's okay to port over the code from other systems, although we prefer code that can be distributed under the MIT license.</p>
<p>It is recommended to start the work by getting an "fs_shell" building for the chosen filesystem. This is a userland tool that runs the filesystem code in a sandbox and provides a simple command prompt allowing to perform single, well controlled operations. Once the filesystem is usable in this mode, it can be integrated, first still running in userland with userland_fs, then later on running as a native kernel filesystem.</p>
-->


<h4><img src="/images/App_Generic_32.png"/>
Filesystems benchmarking and stress-test
</h4>

<p>Some of the filesystems (or specific features of them) in Haiku are
relatively new, and not considered perfectly tested and stable yet. The goal of
this project is to define a procedure for testing the filesystems and identifying
bugs (especially leading to on-disk data corruption) and performance bottlenecks.</p>

<p>Tools like <a href="https://en.wikipedia.org/wiki/Bonnie%2B%2B">bonnie++</a>, <a href="https://github.com/kdave/xfstests">xfstests</a>,
and the existing tests in src/tests/add-ons/kernel/file_systems in Haiku sources should be explored to determine their respective usefulness.
Then, an automated way to run the tests should be defined (unit tests, integration tests on a running system, etc.)</p>

<p>Then, the filesystems should be modified to fix the performance problems and/or bugs that were found in the process.</p>

<ul>
	<li>Skill set: C++ development, testing</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>



<h4><img src="/images/App_Generic_32.png"/>x86-64: Implement support for Process Context Identifiers (PCID)</h4>

<p>on Intel CPUs. The feature tags TLB entries with the Id of the address space and allows to
avoid TLB invalidation on the context switch, it is available only on x86-64.</p>
<p>The goal of this task is to propose possible designs, implement the feature, extend the performance
logs to measure impacts when the feature is enabled, and potentially also to mitigate the
"Meltdown" vulnerability.</p>

<ul><li>
Skill set: kernel development, x86 architecture/assembly language
</li>
<li>Possible mentors/knowledgeable people: korli</li>
</ul>


<!-- On hold because the kernel currently doesn't boot at all. If we can't figure it out, nor can we
guide students through it.
<h4><img src="/images/App_Generic_32.png"/>ARM port / device tree support</h4>

<p>Unlike x86 systems which have a PCI bus, most ARM devices have peripherals at hardcoded addresses. This means automatic hardware discovery is not possible. The Linux kernel developers designed a solution called "flattened device tree". It is a static description of the hardware, telling the kernel where devices are located and which driver to use.</p>

<p>Haiku plans to use device trees to support several ARM devices with the same kernel. This requires updating our drivers and driver infrastructure to not rely so much on the PCI bus. This work should start with the USB EHCI driver, in order to provide at least one mass storage solution to the ARM port of Haiku.</p>

<p>The ARM port of Haiku is currently in an early state. This project may involve debugging other issues in the port to get it running further, so that the device tree part can be tested. Several parts of the early boot code should be reviewed to make use of the device tree and remove hardcoded addresses (RAM mapping, framebuffer, serial port, etc).</p>

<ul><li>
Skill set: kernel development, ARM architecture/assembly
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, kallisti5</li>
</ul>
-->


<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>Unify File System Caches</h4>

<p>
The Haiku kernel provides two kinds of caches for use by file system implementations: the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/file_cache.cpp">file cache</a> and the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/block_cache.cpp">block cache</a>. The file cache caches data at the "file" level, while the block cache is used at the "block" level and is used for on-disk structures as well as file data.</p>

<p>The file cache uses physical memory pages directly and it is linked with the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/vm">VM subsystem</a>, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/slab">slab allocator</a>) and freeing memory in low memory situations is handled via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/low_resource_manager.cpp">low resource manager</a>.</p>

<p>The first problem with the current implementation is caching imbalance in favor of the block cache: it tends to grow more than needed preventing the file cache to get enough memory.</p>
<p>Another problem is the use of large amounts of kernel address space by the block cache, which can be problematic on 32 bit architectures. This makes the block cache constrained to the 2GB of memory available for the kernel in Haiku, and sometimes makes the kernel run out of address space for other uses.</p>

<p>The goal of this project is to create a common underlying mechanism (using `VMCache`) to unify both caches and move the block cache out of the kernel address space. The following problems need to be investigated and solved:
<ul>
<li>How to deal with heterogenous block sizes (not necessarily matching the page size): each mounted filesystem volume may have a different block size, and the block cache must be able to efficiently cache blocks of these different sizes,
<li>How to map support for transactions to `VMCache` hierarchies,
<li>Balancing the memory allocation between the block and the file cache and between multiple mounted filesystem volumes.
</ul>
</p>
<ul><li>
Skill set: kernel development
</li></ul>
-->


<a id="network" name="network"></a>
<h3>Network</h3>


<h4><img src="/images/App_Generic_32.png"/>
Bluetooth Stack Improvements
</h4>
<p>Haiku's Bluetooth stack implements a basic subset of general Bluetooth functionality. This functionality needs to be
completed and Bluetooth 2.X and later possibilities explored. This task involves investigating the current state of the
Bluetooth code, improving the existing code on newer devices (pairing, etc), and improving the stack
to make it more useful by implementing driver(s) for Bluetooth device(s) of your choice (file transfers, audio, HID,
networking, etc).</p>

<ul>
<li>Requirements: Bluetooth-enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge (optional)</li>
<li>Possible mentors/knowledgeable people: waddlesplash <!-- also possibly PulkoMandy --></li>
</ul>

<h4><img src="/images/App_Generic_32.png"\>
VPN Support
</h4>
<p>With the decline of internet freedoms (Government IP Blocks, Net Neutrality reductions), the usage of encrypted virtual
networks is increasing across all platforms.  Haiku's VPN implementation is severly lacking.  To improve global access
to Haiku as a desktop platform of choice, our VPN support needs a lot of work. OpenVPN or Wireguard are both great options.</p>

<ul>
<li>Requirements: Internet connected Haiku system</li>
<li>Skill set: C++, kernel development, userland development, TCP/IP stack understanding</li>
<li>Possible mentors/knowledgeable people: kallisti5 <!-- also possibly PulkoMandy, waddlesplash --></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Integrate our PPP implementation
</h4>
<p>Finish porting the PPP implementation to our new network stack. Add phone-line modem support, including HDLC
framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT).
Implement CHAP authentication, and add support for configuring these to the new network preflet GUI. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
</ul>

<!--

<h4><img src="/images/App_Generic_32.png"/>
Stream Control Transmission Protocol (SCTP)
</h4>
<p>Implement and test SCTP, a message based transport layer protocol similar to TCP and UDP. It should comply with current IP and IPv6 implementations and provide similar programming API as BSD.</p>
<ul>
<li>Skill set: network protocols, kernel and network stack development</li>
</ul>
-->

<h4><img src="/images/App_Generic_32.png"/>
IPv6 finalization
</h4>
<p>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project. Even so, there remains a lot of
smaller cleanup/finalization tasks that can be done as a project.
</p>
<ul>
<li>Tickets:
<ul>
<li><a href="https://dev.haiku-os.org/ticket/8293">#8293</a> -- BNetworkAddress needs to check if there is an available IPv6 connection.</li>
<li><a href="https://dev.haiku-os.org/ticket/7228">#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/6489">#6489</a> -- ifconfig needs to validate availability of ipv6 module prior to utilization</li>
<li><a href="https://dev.haiku-os.org/ticket/2632">#2632</a> -- Possible redefinition for struct sockaddr_in, related to IPv6</li>
<li><a href="https://dev.haiku-os.org/ticket/8319">#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/8317">#8317</a> -- Haiku needs IPv6 global scope Auto Configuration (router advertisement + DHCPv6)</li>
<li><a href="https://dev.haiku-os.org/ticket/11862">#11862</a> -- Net server multi-protocol rework</li>
</ul>
</li>
</ul>

<ul>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development</li>
<li>Possible mentors: </li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>MDNS / Bonjour / Avahi network discovery</h4>

<h5>Idea description</h5>

<p>MDNS (known as Bonjour for Apple devices and usually implemented using Avahi on Linux) is a protocol allowing to discover devices in the local network and their capabilities. The goal of this project is to implement MDNS in Haiku and integrate it in our name resolution system and user interface.</p>

<h5>Why we need this</h5>

<p>MDNS is part of the IPP Everywhere and Airprint specifications, which allow to use networked printers with a single generic driver, instead of a specific driver for each printer. Having an implementation in Haiku would allow easier setup and use of printers, a required feature for a desktop operating system.</p>

<h5>Further details</h5>

<ul>
	<li>Skill set: network programming (UDP, IPv4, multicast)</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>

<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<!-- removed: needs to be thought out on the mailing list a little better
<h4><img src="/images/App_Generic_32.png"/>
Preferences GUI refactoring
</h4>
<p>
Haiku is an operating system designed for ease of use on desktop computers. A key part of this work is an easy to use set of preference applications. Some of the currently available preference panels could be merged or improved in several ways.</p>
<p>
Several preference applications (aka preflets) could be redesigned. Furthermore, there might still be code that does not yet use our layout API. This work may include (but is not limited to):</p>
<ol>
<li>Integrating keymap preferences into input preferences,</li>
<li>adding support for joysticks and touch screens to input preferences,</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Reworking the Printer preferences to look better and be more intuitive.</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet, and provide a live preview for all of the settings available in this window</li>
<li>Improving the user interface of the shortcuts preference to make it easier to setup custom shortcuts</li>
<li>Improving and extending the notifications preferences to allow easy control of allowed notifications, browsing of the notification history.</li>
<li>Research on how to improve the other preference panels further with the goal of making them easier to use.</li>
</ol>
<ul>
<li>Skill set: C++, UI development, usability basics</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>
Modular edit view (BIG)
</h4>

<p>The current solution for text editing in Haiku is the BTextView. It is a
rather simple view providing basic text editing features and limited styling.
This is, however, not powerful enough for most serious uses. The goal of this
project is to design a complete replacement for BTextView, which should be designed
to cover more use cases.</p>

<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:
<ul>
<li>spell checker</li>
<li>line numbers, ruler, 80 character limit line, hyper links</li>
<li>working on an input stream rather than on an input file, e.g. to be able to open files ~100Mb without loading them into memory in one go</li>
<li>Including pictures in the text flow</li>
<li>Sourcecode editor: syntax highlighting, code completion</li>
<li>Ability to load and save data in different formats (using the Translation Kit)</li>
</ul>
</p>

<h5>Existing work</h5>
<p>The HaikuDepot application includes preliminary work on a rich text view,
which it uses to provide the description of packages. This could be used as a
starting point for this work.</p>

<ul>
	<li>Skill set: C++, API design, UI development</li>
	<li>Possible mentors: waddlesplash, Sean Healy, scottmc</li>
</ul>


<!--
<a id="media" name="media"></a>
<h3>Media</h3>
-->

<!-- needs to be discussed more; working on a MediaKit2 may make more sense. (Didn't Dan0 have MediaKit2?)
<h4><img src="/images/App_Generic_32.png"/>Add subtitle support to the Media Kit</h4>

<p>Haiku "media" applications rely on a framework called the Media Kit. This
provides a unified API to handle audio and video streams, including codec
plugins to read and write the stream to files or other sources, as well as
transporting the data from one application to another, with a latency as low as
possible.</p>

<p>While our MediaPlayer has support for external subtitle files, the Media Kit
itself has not. The most obvious downside of that is that there is no support
for subtitle (text or bitmap) embedded in video files within the MediaPlayer or
other applications.</p>

<p>Your job would be to design the necessary API extensions to let subtitles fit
in with the rest of the Media Kit, and add native support for them, which will
then be available to all applications as part of the framework.</p>

<ul>
<li>implement the required code to extract the subtitles from source files
(either standalone .srt files or contained for example in mkv containers), with
proper handling of replay time and text encoding</li>

<li>integrate this in the existing API (probably as a new kind of BMediaTrack),
and update applications such as MediaPlayer and MediaConverter to make use of
the feature.</li>

<li>See <a href="/legacy-docs/bebook/TheMediaKit_Overview_Introduction.html" target="_blank">
the BeBook introduction for the Media Kit</a> to become familiar with its design.</li>

<li>Skill set: general C/C++, userland development, API design</li>
<li>Possible mentors: PulkoMandy</li>
</ul>
-->

<!-- Mentors wanted
<h4><img src="/images/App_Generic_32.png"/>Complete and Finalize the MediaPlayer Plugin API</h4>

<p>The MediaPlayer app included in Haiku is able to play most of the media
formats around. To be able to do that it includes a monolithic framework that
uses most of the important features of the media_kit. To improve maintainability
and flexibility we are looking forward to include a plugin API and export or
implement as plugins certain functionalities.</p>

<p>
Some examples :
<ul>
	<li>Playlist</li>
	<li>Attributes editor</li>
	<li>Cover Art</li>
	<li>Web Remote Control</li>
</ul>
</p>

<p>
Some efforts have been already put and can be found <a href="https://github.com/Barrett17/haiku/tree/mediaplayer_plugin_api">here</a>.</p>

<p>Other Links:

<ul>
	<li><a href="https://www.haiku-os.org/legacy-docs/bebook/themediakit_overview">Media Kit overview (the Be Book)</a></li>
	<li><a href="https://api.haiku-os.org/group__media.html">Media Kit overview (the Haiku Book)</a></li>
</ul>
</p>

<ul>
	<li>Skill set: general C++, userland development, software design</li>
	<li>Possible mentors: </li>
</ul>
-->


<!--
<h4><img src="/images/App_Generic_32.png"/>
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
<li>Possible mentors: </li>
</ul>
-->


<!--
<h4><img src="/images/App_Generic_32.png"/>Improving Clockwerk</h4>

<p>Clockwerk is a video editing bench for Haiku. It works well, but it is a bit
unstable and the feature set is not that complete.</p>
- TODO complete the description -
<ul>
	<li>Possible mentors: n</li>
</ul>
-->

<a id="ports" name="ports"></a>
<h3>Ports</h3>


<h4><img src="/images/App_Generic_32.png"/>
Porting the Go Programming Language to Haiku
</h4>

<p>Go (or Golang) is a popular cross-platform general-purpose programming language which is known for its direct compilation to static executables, concurrency model used in its goroutines and its enforced standard style of programming. It has been used by many developers to create command-line tools, static site generators, high-performance servers and many other applications requiring Go.

<h5>Existing work</h5>

There was a previous GSoC student who originally ported Go 1.3 to Haiku, but unfortunately it was unmaintained and was broken over the years. In 2018, the port was later updated to Go 1.4.3 but only for 64 bit. Work has been attempted in bootstrapping higher versions like 1.5 and 1.11 but the bootstrap process have produced binaries that are broken and don't work.

The goal of this project is to identify the issue preventing the bootstrap process from completing and then attempt to fully build either a recent version (Go 1.11) or the latest version of Go only using Go 1.4.3 for 64 bit.

<em>Please note that this port may require diving into the low-level components of the compiler and Haiku internals rather than primarily programming in Go.</em>

<p>Links:
<ul>
	<li><a href="https://github.com/golang-haiku/go/tree/golang-1.11-haiku">Go 1.11 Haiku port (GitHub)</a></li>
	<li><a href="https://github.com/golang-haiku/go-1.4.3">Go 1.4.3 port (Bootstrapper)</a></li>
	<li><a href="https://bitbucket.org/zhuowei/go-1-3-haiku/src/default/">Previous GSoC Go port (Bitbucket)</a></li>
</ul>
</p>

<ul>
	<li>Skill set: C, Go, Go assembly, low-level programming, ELF-internals </li>
	<li>Possible mentors: return0e, BGA</li>
</ul>

<a id="other" name="other"></a>
<h3>Other</h3>


<h4><img src="/images/App_Generic_32.png"/>
Jam (build system) replacement/rewrite
</h4>
<p>Haiku uses Jam as its main build system. Unfortunately, Perforce is not actively
maintaining the tool anymore and the codebase is not very clean. Ingo Weinhold
started work on <a href="https://github.com/weinhold/ham">a complete rewrite</a> of the tool in C++, with the aim of being
compatible with the existing build files, but provide a cleaner codebase to
build upon and do away with most of the legacy stuff.</p>
<p>The goal of this project is to continue this work and make ham usable to build
Haiku, as well as other projects currently using Jam as a buildtool.</p>
<ul>
	<li>Skill set: C++, threading, build systems</li>
	<li>Possible mentors: waddlesplash</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Coding style checker bot for Gerrit
</h4>
<p>Haiku has its own <a href="/development/coding-guidelines/">coding guidelines</a>
which describe how the code should be formatted. There is <a href="https://github.com/owenca/haiku-format">a tool</a> for reformatting
or checking if code follows these guidelines, but it has to be compiled on the
developer machine and then run manually.</p>
<p>The goal of this project is to integrate this tool with Gerrit, the web app
we use for code reviews. It could then give quick feedback on the coding style
as soon as a patch is submitted, making the review process smoother and easier.</p>
<p>Ideally, the changes could be run through a specific concourse configuration,
which would run haiku-format, and then post the result as comments in Gerrit pointing out the lines that need to be fixed, and give a review score to the change.</p>
<ul>
	<li>Skill set: REST APIs, code formatting tools</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library. Older version (4.4) did support Haiku, but this
support was dropped from the newer versions (starting from 5.0). The library
should be ported to Haiku, allowing to run the bundled examples and possibly
port some other software using it.</p>

<ul>
	<li>Skill set: C++, userland development</li>
	<li>Possible mentors: scottmc</li>
	<li>Alternative projects: porting SFML or another similar library</li>
</ul>


<!-- REMOVED: needs more thinking on Haiku side to decide on a plan for this.

<h4><img src="/images/App_Generic_32.png"/>
Modify the app_server to support compositing
</h4>
<p>This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows, transparent windows, content previews, and window animations.</p>
<p>There's lots of info on what would need to be done and how to go about it in this article: /articles/2011-06-15_how_transform_app_server_code_use_compositing .</p>
<ul>
<li>Skill set: C++, graphics development</li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>
Multiple monitors output in app_server
</h4>
<p>app_server is Haiku's graphics server and the equivalent of X11 or Wayland on other UNIX systems. It currently supports only one video output, but should be able to do more.</p>
<p>While the API already allows this for the most part (with the BScreen class), there is no actual implementation behind it and parts of the code assume only a single screen.</p>
<p>Some drivers implement minimal support for multiple displays, but not all of them. This task may involve updating the video drivers to handle multiple monitors correctly.</p>
<ul>
<li>Skill set: C++, graphics development</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
	External font loading in app_server/interface kit
</h4>
<p>app_server is the graphics server in Haiku. It handles the rendering and
display of application windows, desktop, and everything that is shown on screen.</p>
<p>The Interface Kit is the API allowing apps to send commands to app_server and show things on
screen.</p>
<p>Currently the API for managing fonts is <a href="https://www.haiku-os.org/docs/api/classBFont.html">BFont</a>.
It only allows using fonts that are installed on disk in specific directories that are scanned by app_server.</p>
<p>Some applications need to render text using fonts that are not stored on disk, but downloaded as
needed (for example this is the case for web browsers supporting "web fonts"). The goal of this
project is to extend the BFont class to allow loading fonts from a memory buffer, and get it loaded
in app_server.</p>
<ul>
	<li>Skill set: C++</li>
	<li>Possible mentors: stippi, PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
	Complex font rendering in app_server
</h4>
<p>app_server is the graphics server in Haiku. It handles the rendering and
display of application windows, desktop, and everything that is shown on screen.</p>
<p>Freetype (in combination with agg) is used to render text. While it provides
good results for latin and cyrillic alphabets, Freetype is not enough
on its own to properly render other scripts with more complex rules, such as
Devanagari or Arabic.</p>
<p>The goal of this task is to integrate Harfbuzz into app_server, so that the
complex rules for text rendering are properly applied. This would allow rendering
of complex languages as mentioned above, as well as mixing different languages
(picking appropriate fonts automatically).</p>
<p>This task can be further extended with investigations of API changes required
in the interface kit (and in particular BView and BFont) to properly handle
right to left text.</p>

<ul>
	<li>Skill set: C++</li>
	<li>Possible mentors: stippi, PulkoMandy</li>
</ul>

<!--
<h4><img src="/images/App_Generic_32.png"/>
RTL languages support in interface kit
</h4>
<p>The interface kit is the part of the API taking care of everything drawing related: windows, buttons, and other widgets. It is not currently able to display right-to-left languages (such as arabic) properly, making Haiku unusable for a lot of people.</p>
<p>Font rendering should be reworked to use the HarfBuzz library, instead of just Freetype, providing support for ligatures and bidirectional text output. The Layout Kit (which handles positioning widgets in a window) should be made to work as expected with these languages (possibly inverting left and right in the window layout).</p>
<p>This task can be extended with better support for font overlays (picking the correct font for each language automatically, probably using fontconfig), and work on input methods for some languages.</p>
<ul>
<li>Skill set: C++, graphics development, text rendering</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>
-->
