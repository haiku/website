+++
type = "article"
title = "Ideas"
date = "2014-01-30T16:07:10.000Z"
tags = []
+++

<p>For information about Haiku's participation in GSoC this year, please see <a href="/community/gsoc/2014">this page</a>.</p>
<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below) between March 10th and March 21st, 2014.
For details about how to apply, please check out <a href="/community/gsoc/2014/students">Students: How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>According to other mentor organizations, the most successful <i>Google Summer of Code</i> projects are the ones proposed by the students themselves.
The following list represents our ideas and wishes of our project. However, suggesting your own idea is encouraged!</p>
</div>

<p>Be aware: API and user interface design requires a higher level of skill. A significantly more convincing proposal is required for tasks involving those. Getting started with the design early (before the coding period starts) is recommended, to maximize your chances of being selected, and allow a bigger part of the coding period to actually be dedicated to coding tasks.</p>

<p>If you find an idea marked as "big" interesting but feel you cannot completed in time, feel free to suggest splitting it into smaller parts in your proposal.</p>
<div class="alert alert-warning">
<p>Many of these ideas are not sufficient as stand-alone projects and would need to be combined with others on this list or of your own suggestion. We expect students to build on the ideas to make a complete project proposal.</p>
</div>

<p>Students, who intend to submit applications on ideas that are part of other accepted mentoring organizations, need to contact both Haiku and the other mentoring organization.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User interface</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<h4 class="icon-app-medium">Updating and Extending WebPositive</h4>

Haiku uses a WebKit based browser called WebPositive. This task could involve:

<ul>
<li>Improve the network backend. WebPositive has been switched to use Haiku's native network backend instead of cURL. The backend can be improved, one beneficial task would be to implement an efficient caching layer.</li>
<li>WebPositive has lots of room to improve as an application. For example it is lacking session management, where it can restore all open tabs from the last session.</li>
<li>The graphics platform port in WebCore is not complete due to missing features in the drawing related BView API. Fixing this involves implementing missing functionality in BView and app_server (line dashes, shadow effects, ...), then making use of it in WebKit.</li>
<li>There are various WebPositive related tickets.</li>
</ul>
<ul><li>Skill set: userland development, exploring a large code-base (WebCore)</li></ul>

<h4 class="icon-app-medium">VirtualBox port to Haiku</h4>

A port of VirtualBox to Haiku, would allow developers and users to run another operating system within Haiku. <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">Preliminary VirtualBox port to Haiku</a>
<ul><li>Skill set: userland development, kernel development, possibly x86 assembly</li></ul>


<h4 class="icon-app-medium">Calendar application</h4>

<p>Create a native calendar application or port an existing calendar application to Haiku. The app should support creating events and saving them to event files augmented with attributes similar to how People file work for contacts. Additional features of the calendar app might also include support for recurring events, integration with other calendaring software such as Google Calendar or Microsoft Outlookâ„¢, and vCalendar support ; CalDAV synchronization, import of iCal files, and more.</p>

<p>You should review existing calendar applications on Haiku/BeOS and other operating system to find out the key features for such an application. Then, decide if one of the applications linked above may be used as a starting point, or if it is better to start from scratch. Aside writting the application itself, it may be useful to improve the BDate, BTime and BDateTime in Haiku to make it possible to do date math easily, work with different timezones, and format dates represented using these classes, as well as relative durations ("Today", "2 days ago", ...), in a localized way.</p>

<p>Some applications to look at for inspiration/examples:</p>
<ul>
<li>http://www.pulkomandy.tk/~beosarchive/?file=archive/source/utils/Organizer.zip</li>
<li>https://github.com/HaikuArchives/Eventual (for screenshots, see: http://sourceforge.net/projects/eventual/)</li>
<li>http://haikuware.com/directory/view-details/info-management/personal-information-managers/a-book</li>
</ul>
<ul><li>
Skill set: userland development, user interface design, possibly network development.
</li></ul>

<h4 class="icon-app-medium">Updating Mail</h4>

<p>Haiku's built in Mail application is in need of various improvements. Some of the issues include from re-writing code to adhere to style guidelines, utilizing the Layout API, utilizing proper object oriented programming concepts, addressing race conditions, and GUI improvements.</p>
<p>In addition to that, you may have your own ideas how Mail could be improved to meet today's expectations of a great way to view and edit your mail.</p>
<ul>
<li><a href="https://dev.haiku-os.org/ticket/1431">#1431: Mail codebase needs a cleanup to fix several issues</a></li>
<li><a href="https://dev.haiku-os.org/ticket/5140">#5140: Mail GUI enhancements</a></li>
<li><a href="https://dev.haiku-os.org/ticket/5141">#5141: Generating queries for related mails in Mail</a></li>
</ul>
<ul><li>
Skill set: userland development, user interface design, possibly network development.
</li></ul>


<h4 class="icon-app-medium">Other applications</h4>
There are many open source 3rd party applications for Haiku that coud use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale Kit and Layout API, or anything else imaginable! Writing applications from scratch is also possible.

<ul>
<li><a href="https://github.com/Barrett17/Caya">Caya</a> (IM client)</li>
<li><a href="http://haikuware.com/directory/view-details/internet-network/clients/torrentor">Torrentor!</a> (<a href="https://github.com/Prodito/Torrentor">source</a>)</li>
<li>https://github.com/HaikuArchives</li>
<li>http://pulkomandy.tk/projects</li>
<li>http://pulkomandy.tk/~beosarchive/</li>
<li>http://wwww.haikuware.com</li>
</ul>
<ul><li>
Skill set: userland development, user interface design, exploring an existing code base, others depending on the application retained.
</li></ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>

<h4 class="icon-app-medium">
USB Support for FreeBSD network compatibility layer
</h4>

<p>Haiku uses a FreeBSD network compatibility layer to support many network devices (ethernet and wireless) using drivers written for the FreeBSD project. However, this layer only supports PCI devices, and doesn't work with USB ones. Adding support for USB to the compatibility layer would bring us support for a range of devices like so-called USB tethering, as well as USB to Ethernet and WiFi dongles.</p>

<p>Suggested work: Import USB drivers, implement the missing parts of the layer, test and validate with emulated or/and physical USB devices.</p>
<ul>
<li>Requirements: an Ethernet USB device for testing (most smartphones can do this).</li>
<li>Skill set: kernel and driver development, USB, general C and C++ development</li>
</ul>

<h4 class="icon-app-medium">
virtio network and balloon drivers
</h4>

<p>Haiku already has a virtio bus driver, and a virtio disk driver. The addition of a virtio network card driver and a virtio memory balloon driver would enable Haiku to take advantage of emulation speedups using the lightweight virtio bus. Haiku could also be deployed in environments such as Amazon s3 or OpenStack.  To complete this task, a fully stable virtio network card driver would need to be completed and tested as functional as well as a working virtio balloon memory driver.

<ul>
<li>Requirements: qemu or virtualbox with the virtio network card selected.</li>
<li>Skill set: kernel and driver development, general C development.</li>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/9800">#9800 virtio network driver</a>, <a href="https://dev.haiku-os.org/ticket/9803">#9803 virtio balloon memory driver</a></li>
<li>Existing code: <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/drivers/network/virtio">virtio network driver (target of this task)</a>, <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/busses/virtio">virtio bus driver (should be mostly complete)</a>, <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/drivers/disk/virtual/virtio_block">virtio block (functional, example usage of virtio bus)</a></li>
</ul>

<h4 class="icon-app-medium">
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has Acpi Video Extentions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
AV/1394 support
</h4>

<p>Our Firewire stack supports DV receiving, but not controlling the A/V device (ie play/stop). This requires to modify the Firewire stack for FCP frame support. See AV/C Digital Interface Command Set General Specification for reference.</p>

<ul>
<li>Requirements: a DV camera, a machine with a Firewire port.</li>
<li>Skill set: kernel development, API design, general C/C++, userland development</li>
</ul>


<h4 class="icon-app-medium">TTY Layer</h4>
<p>
    The TTY layer is needed for proper serial port support in Haiku.
    Until now the serial port was reserved for kernel debugging,
    but it is now time for proper userland support.
</p>
<p>
    Currently, the TTY layer is written mostly with the usb_serial
    in mind, so it uses stuff that might not be easy or possible at all to
    use in more low-level drivers (like pc_serial).
    The API could use improvements. Locking issues exist.
    Also the generic module is not yet in the image due to these, and the pc_serial driver itself is still untested.
</p>
<ul>
	<li>
	    Skill set: kernel, and driver development
	</li>
	<li>
        Tickets: <a href="https://dev.haiku-os.org/ticket/35">#35</a>, <a href="https://dev.haiku-os.org/ticket/3232">#3232</a>
	</li>
<li><a href="http://www.linusakesson.net/programming/tty/">The TTY demystified</a>, a good article about what a TTY is (not Haiku specific).</li>
</ul>



<h4 class="icon-app-medium">LibUSB port</h4>

<p>LibUSB is a portable library to access USB devices from userland.
The existing port isn't complete, and fails to work with almost all LibUSB based applications.
Make it work on Haiku and port applications such as sane, avrdude, and more to test the port. Haiku already provides similar functionality in the form of the USB Kit, but a LibUSB port would enable use of existing applications without modifications.
</p>

<p>You should study the existing libUSB code and get it to work with one of the applications that use libUSB. Examples applications are avrdude, dfu-uploader, openOCD, Sane. This task requires a compatible USB device for at least one application using libUSB for testing.</p>
<ul>
<li>Skill set: USB</li>
<li>Existing porting effort: https://github.com/pulkomandy/libusbx</li>
</ul>


<h4 class="icon-app-medium">Nouveau / PSCNV port</h4>
<p>
Haiku currently doesn't have a driver for NVidia video cards, and falls back to VESA for those. While our VESA driver is reasonably fast, it can't set the native resolution on all systems, leading to a suboptimal Haiku experience.
Nouveau is a graphics driver for NVidia video cards. There is a fork called PSCNV which might have less dependencies on Linux.
cf. https://github.com/pathscale/pscnv/wiki
</p>
<p>Port (parts of) Nouveau to an Haiku graphic driver, allowing at least setting the native video mode. Hardware 3D acceleration may also be investigated, but requires more work on Haiku</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4 class="icon-app-medium">UEFI Bootloader x86-64</h4>

<p>Haiku currently lacks a UEFI boot loader. The code for making Haiku build an UEFI application with the boot platform already exists. You will need to write the actual boot code that sets up the CPU to boot Haiku.
To your help you have the boot code for BIOS x86/x86-64 and serial debugging with printf. Development can be done in QEMU with UEFI firmware and serial output. UEFI API is very simple and learned quickly, major skill needed is booting x86-64 platform.
This does not have to include Secure Boot.</p>

<p>
Haiku code to load the kernel is located in src/boot/platform. You can see the
<a href="https://github.com/tqh/haiku/tree/efi_pm/src/system/boot/platform">different implementations.</a>
</p>
<p>
The EFI version in that tree builds the bootplatform code, can run as
a EFI application, can call EFI functions, but not much else. What
needs to be done is setup CPU, MMU, handle kernel args, load kernel,
some drivers (at least Vesa) that uses BIOS functions needs disabling.
Basically everything needed to setup and boot a x86_64 platform once
the EFI app is started is missing.
</p>
<p>
Userland tools for EFI is also missing, so modifying and viewing boot
options could
also be part of the project. It would need a driver for <a href="http://wiki.phoenix.com/wiki/index.php/EFI_RUNTIME_SERVICES">Runtime
services</a> and an application to set/get variables.</p>
<p>
If you are interested in this I suggest trying to set a time schedule
and see what parts you can fit in your GSoC. I rather see some parts
done well and properly tested than focusing on to much.
</p>

<h5>Possible extentions or alternative GSoC's</h5>
<ul>
<li>Application/driver to handle boot options and install bootloader similar to efibootmgr in Linux</li>
<li>Make 32 bit version of bootloader (target and most platforms are 64 bit)</li>
<li>Secure Boot</li>
</ul>

<h5>Additional information:</h5>
<ol>
<li>Our simplified GNU EFI (good for learning UEFI/QEMU): https://github.com/tqh/efi-example</li>
<li><a href="https://github.com/tqh/haiku/tree/efi_pm">Current EFI development tree</a>  (take a look at the commit history and 
<a href="https://github.com/tqh/haiku/commit/ae28c1e76c8754b25c5b887adc59b94fce050413">build instructions</a>)</li>
<li>UEFI API information: http://wiki.phoenix.com/wiki/index.php/Category:UEFI_2.1</li>
</ol>
<ul><li>
Skill set: kernel development, x86/x86-64 architecture/assembly, bootloaders, QEMU 
</li></ul>


<h4 class="icon-app-medium">
Power management
</h4>

<p>Improve power management in Haiku. Haiku has recently had improvements in CPU idling, but there is more to be done.
Investigate what is using power and what can be done to improve the situation.
This can be work on making Haiku tickless (used in networking/wifi atm), reducing interrupts (perhaps for polling), fixing bad code and adding power management for devices.
</p>

<ul>
<li>Skill set: kernel development, general C/C++, userland development, debugging, power management / measurement</li>
</ul>


<h4 class="icon-app-medium">
File Systems: general improvements (write support: BIG)
</h4>
Haiku has great support for its own file system, but most others are only available read-only, or not at all. It is way better for interoperability with other systems to be able to read and write to these disks. To give you some examples what you could work on:
<ol>
<li>ReiserFS, BTRFS, exFAT: write support</li>
<li>XFS, UFS2, ZFS: Read (& Write) support</li>
<li>SMB, Windows shares: Read (& Write) support</li>
<li>HAMMER FS: Read (& Write) support</li>
<li>SquashFS: To support booting Haiku off SquashFS on a CD/DVD</li>
</ol>
It's okay to port over the code from other systems, although we prefer code that can be distributed under the MIT license.
<ul><li>
Skill set: kernel, and driver development
</li></ul>


<h4 class="icon-app-medium">
IMAP FS: File system access to an IMAP account
</h4>

<p>In Haiku emails are stored as individual file with extended attributes. Mounting an IMAP account as a local file system is therefore a natural fit. The file system should have full read and write support (deleting mails (files), creating folders, and moving mails between folders, etc.) with local caching for better performance.</p>
<ul><li>
Skill set: kernel and file system (driver) development, network development
</li></ul>


<h4 class="icon-app-medium">x86-64: Support for 32 bit userland</h4>

<p>
Since Google Summer of Code 2012 there's a x86-64 port of Haiku. The kernel only supports a 64 bit userland, though. A compatibility mode should be added, so that 32 bit programs can be run as well.
</p>
<ul><li>
Skill set: kernel development, x86 architecture/assembly
</li></ul>


<h4 class="icon-app-medium">ARM port</h4>

<p>The ARM port of Haiku is currently not booting. Using the hardware of your choice (we can provide a development board if you don't have one), or an emulator such as QEMU, improve the port and make it boot further. This will involve fixing the kernel code, and writing drivers for the chosen hardware (serial port, mass storage to load the userland, then later on video and ethernet).</p>

<p>A preliminary task is getting Haiku bootstrap build to work, allowing you to build the required package files for a minimal Haiku system to work with.</p>

<ul><li>
Skill set: kernel development, ARM architecture/assembly
</li></ul>


<h4 class="icon-app-medium">Unify File System Caches</h4>

<p>
The Haiku kernel provides two kinds of caches for use by file system implementations: the file cache and the block cache. The file cache uses physical memory pages directly and it is linked with the VM subsystem, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the slab allocator) and freeing memory in low memory situations is handled via the low resource manager. Using different mechanisms to deal with low free memory situations leads to a caching imbalance in favor of the block cache. Furthermore the block cache uses large amounts of kernel address space, which can be problematic on 32 bit architectures. The goal is to create a common underlying mechanism (using `VMCache`) to unify both caches. Solutions must be found to interesting problems like how to deal with different block sizes (not necessarily matching the page size) and how to map support for transactions to `VMCache` hierarchies.
</p>
<ul><li>
Skill set: kernel development
</li></ul>


<a id="network" name="network"></a>
<h3>Network</h3>

<h4 class="icon-app-medium">
Bluetooth Stack Improvements
</h4>
<p>Haiku Bluetooth Stack implements basic functionality on lower and middle layers, this functionality needs to be completed and Bluetooth 2.X possibilities explored.</p>

<ul>
<li>Requirements: Bluetooth enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge(optional)</li>
<li>Tasks: RemoteDevices Database, UserLand tools(Preferences), Pairing/Auth/Encryption use cases, etc.</li>
</ul>

<h4 class="icon-app-medium">
Integrate our PPP implementation
</h4>
<p>Port the PPP implementation to our new network stack. Add phone-line modem support, including HDLC framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT). Implement CHAP authentication. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
</ul>


<h4 class="icon-app-medium">
Stream Control Transmission Protocol (SCTP)
</h4>
<p>Implement and test SCTP, a message based transport layer protocol similar to TCP and UDP. It should comply with current IP and IPv6 implementations and provide similar programming API as BSD.</p>
<ul>
<li>Skill set: network protocols, kernel and network stack development</li>
</ul>

<h4 class="icon-app-medium">
IPv6 Polish
</h4>
<p>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project. Even so, there remains a lot of smaller cleanup/polish tasks that can be done as a project.
</p>
<ul>
<li>Tickets:
<ul>
<li><a href="https://dev.haiku-os.org/ticket/8293">#8293</a> -- BNetworkAddress needs to check if there is an available IPv6 connection.</li>
<li><a href="https://dev.haiku-os.org/ticket/7228">#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/6489">#6489</a> -- ifconfig needs to validate availability of ipv6 module prior to utilization</li>
<li><a href="https://dev.haiku-os.org/ticket/2632">#2632</a> -- Possible redefinition for struct sockaddr_in, related to IPv6</li>
<li><a href="https://dev.haiku-os.org/ticket/8319">#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/8317">#8317</a> -- Haiku needs IPv6 global scope Auto Configuration (router advertisement + DHCPv6)</li>
</ul>
</li>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development
</ul>


<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<h4 class="icon-app-medium">
Preflet GUI refactoring
</h4>
Several preference applications (aka preflets) could be redesigned. Furthermore, there might still be code that does not yet use our layout API. This work may include (but is not limited to):
<ol>
<li>combining Keymap and Keyboard</li>
<li>combining Mouse and Touchpad</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Printer</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet</li>
<li>Shortcuts</li>
<li>Notifications</li>
</ol>
<ul>
<li>Skill set: c++, UI development, usability basics</li>
</ul>


<h4 class="icon-app-medium">
Modular edit view (BIG)
</h4>
<p>
Many Haiku applications are using their own edit view to provide basic editor functionalities. All these implementations work a little bit different and create an inconsistent user experience.
One solution is to provide a modular and powerful editor view that could be used in various Haiku applications.</p>
<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:</p>
<ul>
<li>syntax highlighting</li>
<li>spell checker</li>
<li>code completion, word completion</li>
<li>line numbers, ruler, 80 character limit line, hyper links</li>
<li>working on an input stream rather than on a input file e.g. to be able to open files ~100Mb without loading them into memory in one go.</li>
<li>interface to external applications e.g. to jump from a compiler error to the according line in the code</li>
</ul>
<p>Reuse of existing syntax highlighting libraries may be possible, provided they can be connected to a native Haiku view. MIT license would be preferred for the external library.</p>
<ul>
<li>
Skill set: C++, UI development
</li>
</ul>


<a id="media" name="media"></a>
<h3>Media</h3>

<h4 class="icon-app-medium">Add subtitle support to the Media Kit</h4>

<p>While our MediaPlayer has support for external subtitle files, the Media Kit itself has not. The most obvious downside of that is that there is no support for subtitle (text or bitmap) embedded in video files within the MediaPlayer or other applications.</p>
<p>Your job would be to design the necessary API extensions to let subtitles fit in with the rest of the Media Kit, and add native support for them, which will then be available to all applications as part of the framework.
</p>

<ul>
<li>See <a href="/legacy-docs/bebook/TheMediaKit_Overview_Introduction.html" target="_blank">the BeBook introduction for the Media Kit</a> to become familiar with its design.</li>
<li>Skill set: general C/C++, userland development, API design</li>
</ul>


<h4 class="icon-app-medium">
Merge CDPlayer into MediaPlayer
</h4>
<p>
The functionality of CDPlayer could be migrated into MediaPlayer, allowing the play back of audio cd's. An alternative to CDPlayer's (outdated) way of controlling the device in a low-level fashion would be to make it use the wave files as presented by the cdda-fs, subscribe to volume mounts via BVolumeRoster, present a menuitem for the CD similar to one for DVDs in the VLC Media Player, having this option populate a playlist and start playing.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Streaming support for Media Kit and applications
</h4>
<p>
The media kit and related applications in Haiku relies a lot on the BMediaFile being seekable. This makes it difficult to use with non-seekable media sources such as internet streams or DVD media. Rework what's needed to get them working properly.
</p>
<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>


<a id="other" name="other"></a>
<h3>Other</h3>
<!--
<h4 class="icon-app-medium">
Fix and improve Haiku's mail system
</h4>
Haiku features an integrated mail management system allowing to manage your mail using Tracker, the file explorer. This system needs some improvements and updates. See this <a href="http://www.freelists.org/post/haiku-commits/r40398-in-haikutrunksrc-addonsmail-daemon-addonsmail-daemoninbound-filters-addonsmail-daemoninbound-filtersmatch-header-addonsmail-daemoninbound-filtersnotifier-addonsmail-daemoninbound-filtersspam-filter,2">mailing list post</a> for a list of TODO and related ideas

<ul>
<li>Skill set: general C/C++, userland development</li>
</ul>
-->
<h4 class="icon-app-medium">
Trac Plugin: "Test and Commit Patch" functionality
</h4>
<p>
Several developers have requested the ability to simply press a button that would trigger an automatic system to test and (conditionally commit) a supplied patch.
</p>
<ul>
<li>Skill set: Python</li>
</ul>

<h4 class="icon-app-medium">
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library, it has support for BeOS/Zeta/Haiku in the 4.4 branch, but they dropped BeOS from the 5.x branch. Now that Haiku is in a usable state it would be nice to get the latest builds of Allegro 5.0 working on Haiku. It's still unclear if Allegro will be applying for GSoC but they do have a developer who'd be willing to co-mentor this with a Haiku mentor.</p>

<ul>
<li>Skill set: C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Graphical project manager tool
</h4>
BeOS had CodeWarrior IDE built-in, which makes it easy to create a new project and get started on development. Haiku currently only provide make and jam in the default installation, which is far less easy to use for starting developpers. The makefile engine is somewhat simpler, but more limited. All of these tools are to be used in text mode, not so good for beginners. Create some graphical tool to easily get started on 3rd party development in a few clicks. No need for a full-blown IDE.

<ul>
<li>Skill set: C++, userland development</li>
</ul>


<h4 class="icon-app-medium">
Tracker add-on for a version control system
</h4>
Windows has TortoiseSVN and TortoiseGIT. Choose your preferred VCS, and do something similar for Haiku's Tracker.
<ul>
<li>Write a Tracker add-on that has the functionality to let you carry out most daily needed tasks when using the VCS.</li>
<li>Extend support in Tracker itself where needed: icon overlays, custom file menus, ...</li>
</ul>


<h4 class="icon-app-medium">
Modify the app_server to support compositing
</h4>
<p>This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows, transparent windows, content previews, and window animations.</p>
<p>There's lots of info on what would need to be done and how to go about it in this article: /articles/2011-06-15_how_transform_app_server_code_use_compositing .</p>
<ul>
<li>Skill set: C++, graphics development</li>
</ul>


<h4 class="icon-app-medium">
Evaluate Qt as a potential Haiku R2 API
</h4>
While in comparison with other frameworks the BeOS API was quite nice back in the day, save for a few additions (like layout management, an improved archiving mechanism, tool tips) very little has changed since. Particularly the interface kit leaves a lot to be desired these days, both in general design and completeness. The Qt toolkit on the other hand has evolved quite nicely over time and now presents a very complete and for the most part well designed API. This project shall evaluate Qt as a potential native Haiku R2 API, replacing partially or even completely the previous BeOS/Haiku API.
<ul>
<li>Analyze the current state of the <a href="http://qt-haiku.ru/">Qt 4.x port</a>, update to 5.x, and add/complete what is missing/incomplete.</li>
<li>Add extension in or on top of the Qt API to provide access to Haiku specific functionality (attributes, entry_refs, resources, translators, etc.)</li>
<li>As a proof of concept port an existing Haiku application (e.g. StyledEdit) over to the extended Qt API.</li>
</ul>
<ul>
<li>Skill set: C++, API development</li>
</ul>


<h4 class="icon-app-medium">
Port the Go programming language to Haiku
</h4>
<a href="http://www.golang.org">The Go Programming Language</a> is a relatively new programming language that is open-source and was created by Google. It has been getting a lot of traction recently and it would be nice to have a Haiku port. 
<ul>
<li>Get Go's build system working under Haiku (there is actually code to do that already).</li>
<li>Implement Haiku specific code in the runtime and syscall packages.</li>
<li>Implement Haiku specific code for garbage collection and the runtime scheduler.</li>
<li>Get "Hello World" fully working.</li>
</ul>
<ul>
<li>Skill set: C, Go, Haiku syscall interface, Programming languages development</li>
<li><a href="http://lists.ports.haiku-files.org/pipermail/haikuports-devs-ports.haiku-files.org/2014-March/001768.html">Additional information</a>
</ul>