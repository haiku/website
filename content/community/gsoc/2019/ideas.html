+++
type = "article"
title = "Ideas"
date = "2019-01-07"
tags = []
+++

<p>For information about Haiku's participation in GSoC this year, please see <a href="/community/gsoc/2019">this page</a>.</p>
<p>
Qualifying students can apply for a Haiku project (see the list of <i>suggested</i> projects below).
For details about how to apply, please check out <a href="/community/gsoc/2019/students">Students: How to Apply for a Haiku Idea</a>.</p>

<div class="alert alert-info">
<p>The most successful <i>Google Summer of Code</i> projects are often those proposed by the students themselves.
The following list represents some of our ideas and wishes for the project. However, suggesting your own idea is always encouraged!</p>
</div>

<p>Be aware: API design and kernel-related work requires a higher level of skill, and
user interface design usually involves a lot more thought than other work. A
significantly more convincing proposal is required for tasks involving those.
Getting started with the design early (before the application period ends) is
recommended, to maximize your chances of being selected, and allow a larger part
of the coding period dedicated to coding tasks.</p>

<p>If you find one of the "big" ideas interesting, but feel that you cannot
complete it within the allotted coding time, feel free to suggest splitting it
into smaller parts for your proposal.</p>

<p>Students that intend to submit applications on ideas which are also part of
other accepted mentoring organizations must coordinate with both Haiku and the
other mentoring organization beforehand.</p>

<h3>Project Areas</h3>

<ul>
<li><a href="#applications">Applications</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#kernel">Kernel/File Systems</a></li>
<li><a href="#media">Media</a></li>
<li><a href="#network">Network</a></li>
<li><a href="#user-interface">User Interface</a></li>
<li><a href="#other">Other</a></li>
</ul>

<a id="applications" name="applications"></a>
<h3>Applications</h3>

<h4><img src="/images/App_Generic_32.png"/>Updating and Extending WebPositive</h4>
<p>
Haiku uses a WebKit based browser called WebPositive. The browser is still quite
simple and can be improved in multiple ways. Some of the missing features are:
</p>
<ul>
<li>Advanced session management. There is minimal support for restoring tabs
from the last closed window, but a more complete solution is desirable. The web
browser should be able to store its whole state (multiple windows and tabs) to
a session file, and restore the state from that file.</li>
<li>Management of broken HTTPS certificates. There should be a way to remember
exceptions to the system-wide certificate list.</li>
<li>Support for browser extensions, such as ad-block. This could be done either
reusing extensions from other browsers (if possible), or using the native
add-ons system.</li>
<li>Skill set: userland development, user interface design and programming</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/apps/webpositive">Source code</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Extending and improving the Services Kit network backend</h4>
<p>
The Haiku API includes a framework for performing requests to websites using
HTTP and other protocols. This is similar to 
<a href="http://curl.haxx.se/">curl</a> or <a href="https://wiki.gnome.org/action/show/Projects/libsoup">soup</a>
which are often used for that purpose on other systems.</p>

<p>This library is used by many Haiku applications, including the WebPositive
web browser, package manager, e-mail client, etc.</p>

<p>The goal of this task is to rework the implementation to improve performance
and fix design issues. As a result, the code would be cleaner, safer, and
faster.</p>

<ul>
<li>Reworking the Service Kit to avoid spawning one thread for each network request. The requests should be allowed to run in an existing thread, or to be grouped together (by use of select() or poll() to wait for activity on their sockets, then dispatching events to the BNetworkRequest objects). This would remove some of the overhead of creating a request and solve some design issues in the Services Kit API.</li>
<li>Implementing HTTP 1.1 support, allowing the reuse of the connection to an HTTP server to perform multiple requests. BHttpRequest objects should be reworked to be able to use an existing HTTP 1.1 connection, and a way to store existing connections should be added.</li>
<li>A caching layer for HTTP requests. There currently is no cache which means some requests are made again and again to the same server. The cache should keep the result of these requests on disk and/or in memory, making it possible to reuse them and load web pages faster.</li>
<li>Complete support for HTTP proxies. While there is currently limited support, it is not possible to do HTTPS requests through a proxy. This should be added, as well as a system-wide user interface to configure and manage proxies.</li>
<li>Implementing FTP support. The services kit is designed to support multiple protocols, but currently only HTTP and Gopher are supported (as well as the local "file" and "data" protocols). FTP support in the web browser would be helpful.</li>

<li>Skill set: userland development, network programming, threads.</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, jessicah, waddlesplash</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/kits/network/libnetapi">Sourcecode</a></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Improving Haiku's WebKit1 port</h4>

<p>Haiku has a native WebKit port which uses the WebKit1 API. This port is not complete and there are several bugs and minor problems which needs to be fixed.</p>

<ul>
<li>There are rendering problems on many web pages. Most of these happen because of missing features both in the WebCore graphics implementation and in the Haiku app_server. This includes missing or incomplete support for dashed lines, shadows, perspective transforms, and probably some bugs in already implemented features. These should be implemented so websites look closer to how they were designed.</li>
<li>Another missing feature is the ability to load fonts into app_server dynamically. Currently the Haiku API only allows using existing fonts installed in specific system directories. This should be extended so WebKit can make use of fonts it downloads from the web. Some websites use these as pictograms, and not having the correct font results in unuseable websites.</li>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://github.com/haiku/webkit">Sourcecode</a></li>
<li><a href="https://dev.haiku-os.org/query?status=assigned&status=in-progress&status=new&status=reopened&component=%5EApplications%2FWebPositive">Opened tickets</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>Migrating Haiku WebKit port to WebKit2</h4>
<p>
Haiku has a native WebKit port which uses the WebKit1 API. Since this port was made, the WebKit project migrated to WebKit2, which provides several new features and separates the work in several processes to limit the impact of crashes in one or the other.
</p><p>
The goal of this task is to get WebKit2 to run on Haiku. This involves implementing the required inter-process communication primitives in WTF (first reusing the UNIX socket support used on Linux ports, then migrating to BMessages if this is relevant/useful), and writing a WebKit2-style API for WebKit, which can be used in native Haiku  applications. Proof of concepts could be a minimal browser, an update to the existing WebPositive, or adding a web view to existing applications such as Mail or fRiSS.</p>
<ul>
<li>Skill set: userland development, exploring a large code-base (WebCore)</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
<li><a href="https://github.com/haiku/webkit">Sourcecode</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>better XMPP client for Haiku</h4>
<p>Most of Haiku communication channels are hosted on IRC servers. IRC is a
simple protocol, but it lacks modern features. As a result, people are migrating to other chat services such as keybase, Telegram, and many others.</p>
<p>We would prefer to use an open source solution, and XMPP is a good candidate. However, there exists no good native client on Haiku, so its use is limited.</p>
<p>The goal of this project is to either take one of the xisting XMPP clients (Caya or Jabber4Haiku) and improve it, or rewrite one from scratch if nothing from the existing clients is reusable.</p>
<p>Features could include automated account creation, basic messages (private and "conferences" group chats), file transfers, user avatars and moods, rich messages (colors, pictures, ...).</p>
<ul>
	<li>Skill set: userland development, XML, network programming</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>VirtualBox port to Haiku</h4>

<p>VirtualBox is a virtual machine allowing to run an operating system inside of another. Porting it to Haiku would allow Haiku user to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<p>Starting from <a href="http://article.gmane.org/gmane.comp.emulators.virtualbox.devel/3384">this preliminary work</a>, continue and complete the port. This includes writing a native GUI for VirtualBox, getting it to run, and more importantly, work on the virtualization driver which will allow virtualbox to run the emulated machine using the native CPU. This makes the emulated system run at close-to-native speed, whereas a software emulation would be unbearably slow.</p>

<ul><li>Skill set: userland development, kernel development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>KVM acceleration for Haiku's QEmu port</h4>

<p>QEmu is a virtual machine allowing to run an operating system inside of another. While there already is an Haiku port, it currently does not support any acceleration system through native virtualization (KVM/KQemu). This makes it too slow for many uses. Fixing this would allow Haiku user to run another system, such as Windows or Linux, when they need to run an application that is not yet available for Haiku. This would make using Haiku as their primary operating system a viable approach for more people.</p>

<ul>
<li>Work on the virtualization driver which will allow QEmu to run the emulated machine using the native CPU.</li>
<li>Skill set: kernel development, userland development, possibly x86 assembly</li>
<li>Possible mentors/knowledgeable people: mmu_man, waddlesplash</li>
<li><a href="https://github.com/mmlr/qemu-haiku">Sourcecode (QEmu for Haku)</a></li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
Unify input preferences
</h4>
<p>Haiku comes with multiple preference panels for input devices: keyboard, keymap, mouse, and touchpad. The goal of this project is to merge these into a single redesigned "Input devices" preference panel. It should allow having different settings for each device (for example, a different speed for a mouse and a touchpad on the same machine, or different keymaps for multiple keyboards). The panel can also be extended to support joysticks/gamepads and other USB HID input devices.</p>
<ul>
	<li>Skill set: user interface, C++</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
Devices preferences/Hardware manager
</h4>
<p>Haiku is meant to be an easy to use graphical operating system. It should
provide a GUI to manage devices and drivers. This is currently implemented in
the "Devices" preferences, however it does little more than listing devices
found on the machine.</p>
<p>The goal of this project is to extend the functionality of Devices preferences
to make it a more complete and useful tool. This includes working on the following features:
<ul>
<li>Telling wether a driver is loaded for a given device and where the matching /dev entry is</li>
<li>Giving user readable information on the device type and subtype</li>
<li>Allowing to blacklist/disable the driver for a given device</li>
<li>Support for USB and bluetooth devices (currently not listed at all)</li>
<li>Generation of a "compatibility report" to help populate an hardware compatibility database for Haiku</li>
</ul>
</p>
<p>Note that a lot of the work may be in making the required information available
from the drivers and existing device management infrastructure, and not just in
building the GUI itself.</p>

<ul>
	<li>Skill set: user interface, kernel and drivers interfacing (ioctl, devfs...)</li>
	<li>Possible mentors: PulkoMandy, waddlesplash</li>
	<li>Existing code: <a href="https://cgit.haiku-os.org/haiku/tree/src/apps/devices">"Devices"</a></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>Other applications</h4>
<p>There are many open source 3rd party applications for Haiku that could use improvements. Whether it is resolving bugs, adding features, updating the coding style, updating them to use the Locale and Layout Kits, or anything else imaginable! Writing applications from scratch is also possible.</p>

<ul>
<li><a href="https://github.com/Barrett17/Caya">Caya</a> (IM client)</li>
<li><a href="https://github.com/HaikuArchives/Torrentor">Torrentor!</a></li>
<li><a href="https://github.com/HaikuArchives/Calendar">Calendar</a></li>
<li><a href="https://github.com/HaikuArchives">Many applications at HaikuArchives</a></li>
<li><a href="http://pulkomandy.tk/~beosarchive/">Lots of abandonned projects for BeOS looking for a maintainer</a></li>
</ul>
<ul><li>
Skill set: userland development, user interface design, exploring an existing code base, others depending on the application retained.
</li>
<li>Possible mentors/knowledgeable people (depends on chosen application): PulkoMandy, Sean Healy, waddlesplash</li>
</ul>


<a id="drivers" name="drivers"></a>
<h3>Drivers</h3>

<h4><img src="/images/Prefs_Devices.png"/>
	Improving intel video driver
</h4>

<p>Haiku comes with a video driver for intel chipsets. However, on many supposedly supported devices, the driver will
only produce a black screen with no output, confusing users and forcing them to fallback to VESA video modes.
</p>
<p>The goal of this project is to improve the driver and fix the different problems, making sure we get video output
working on all supported devices. This includes support for HDMI, DisplayPort and VGA outputs.</p>
<p>Intel provides documentation for each generation of device, a lot of the work is figuring out what the differences
between generations are, and which part the driver is currently not properly implementing.</p>

<ul><li>Skill set: drivers development</li>
	<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
USB Support for FreeBSD network compatibility layer
</h4>

<p>Haiku uses a FreeBSD network compatibility layer to support many network devices (ethernet and wireless) using drivers written for the FreeBSD project. This allows reusing network drivers with very little changes, considerably decreasing the effort needed to get good hardware support in Haiku.</p>
<p>However, this layer only supports PCI devices, and doesn't work with USB ones. Adding support for USB to the compatibility layer would bring us support for a range of devices like so-called USB tethering, as well as USB to Ethernet and WiFi dongles.</p>

<p>This project consists in importing one or more USB network drivers from FreeBSD into Haiku sources. The compatibility layer should then be extended to expose the FreeBSD USB APIs to the drivers, and forwarding the calls to Haiku's USB stack. Other parts of the compatibility layers may need to be extended as well.
</p>
<p>This should be tested either with real hardware or an emulated device in a virtual machine.</p>

<ul>
<li>Skill set: kernel and driver development, USB, general C and C++ development</li>
<li>Possible mentors: waddlesplash, korli</li>
</ul>

<h4><img src="/images/Prefs_Devices.png"/>
NVMe driver
</h4>
<p>NVMe is a standard protocol for SSD attached to the PCI-express port. Unlike SATA and AHCI,
it is designed from the ground up to work with solid state drives (where SATA was first
designed for spinning hard disks). This allows NVMe to be an order of magnitude faster
and more flexible.</p>
<p>The goal of this project is to implement NVMe support and make Haiku able to boot from
such devices, without the need to go into AHCI mode. FreeBSD (or other *BSD) drivers
may be used for reference.</p>

<ul>
<li>Required hardware: computer or virtual machine with NVMe support</li>
<li>Skill set: kernel and driver development, general C and C++ development</li>
<li>Possible mentors: waddlesplash, kallisti5, jessicah, PulkoMandy</li>
</ul>



<h4><img src="/images/webcam.png"/>
Isochronous USB transfers (USB Webcam &amp; soundcard support)
</h4>
<p>Currently Haiku has very limited support for webcams and USB sound cards.
The goal of this task is to improve the WebCam or USB audio drivers, in order
to make them production ready. For both of these, the USB specification has a
well-documented standardized way to communicate with the devices. Haiku has a
working driver for sound cards, and an incomplete one for webcams.</p>

<p>The main area of work for this project would be getting isochronous USB
transfers to work in Haiku. The USB specification defines various types of
transfers on the USB bus, which affects the scheduling and how the data is
exchanged between the computer and USB devices. The isochronous mode is used
for low latency applications where a reliable and predictible timing is
required (as is the case for video and audio streams).</p>

<p>Unfortunately, Haiku implements these transfers completely only for some
USB1 controllers. There is partial support, but it is not fully working.</p>

<p>The first part of this task is to investigate the state of isochronous
transfers and what is missing to get them working. Then, of course, actually
making things work. Once this part is sorted out, the audio and webcam drivers
may also need some work to get everything running smoothly.</p>

<ul>
	<li>Requirements: USB audio or webcam device (a laptop with built-in webcam should do)</li>
	<li>Skill set: kernel and driver development, USB, C and C++ development</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>


<!--
<h4><img src="/images/App_Generic_32.png"/>
ACPI Video Extensions
</h4>

<p>ACPI Video Extensions, as specified in ACPI Spec 4.0a Appendix B, adds special support to handle multiple output devices such as panels and TV-out capabilities, brightness control as well as special power management features.</p>

<p>Suggested work: Detect attached devices for display adapters, implement a basic driver for a display, allow display switching and brightness control.</p>
<ul>
<li>Requirements: computer with ACPI that has ACPI Video Extensions (_DOS _DOD and so on)</li>
<li>Skill set: kernel development, general C/C++, userland development</li>
</ul>


-->


<!-- REMOVED; need investigation, possibly easier to use DragonFlyBSD's compatibility layer to get all drivers from Linux
<h4><img src="/images/App_Generic_32.png"/>Nouveau / PSCNV port</h4>
<p>
Haiku currently doesn't have a driver for NVidia video cards, and falls back to VESA for those. While our VESA driver is reasonably fast, it can't set the native display resolution on all systems, leading to a suboptimal Haiku experience.</p>
<p>
Nouveau is a graphics driver for NVidia video cards.
</p>
<p>Port (parts of) Nouveau to a Haiku graphic driver, allowing at least setting the native video mode. Hardware 3D acceleration may also be investigated, but requires more work on Haiku (see the next project idea).</p>

<ul><li>
        Skill set: kernel, and driver development
</li></ul>
-->


<h4><img src="/images/Misc_OtherRenderer.png"/>GPU acceleration support</h4>
<p>
Haiku does not currently support GPU acceleration, for 3D or otherwise. Reusing
most of the DRM drivers from Linux, and Mesa's Gallium userspace components,
the goal of this project is to enable the use of GPU-accelerated OpenGL,
and eventually also OpenCL and Vulkan.</p>

<p>Haiku's current video drivers are mostly modesetting-only, and split in two parts: the driver itself, which is
quite minimal and only provides low level access to the video card, and the
"accelerant", which runs inside app_server and communicates with the driver
in order to configure the card and use its features.</p>

<p>Porting the DRM drivers from Linux will be a rather daunting task,
as they use a large subset of the Linux kernel APIs. It may be possible
to reuse OpenBSD's or DragonFlyBSD's work rather than writing our own
Linux API compatibilty layer; more investigation is needed here.</p>

<ul><li>
        Skill set: kernel and driver development, Mesa graphics stack
</li>
<li>Possible mentors/knowledgeable people: waddlesplash, PulkoMandy</li>
</ul>


<a id="kernel" name="kernel"></a>
<h3>Kernel</h3>

<h4><img src="/images/App_Generic_32.png"/>
Power Management
</h4>

<p>Haiku already has some power management support in the form of a CPU idling driver. This is however clearly not sufficient, and there is room for improvements in several areas in order to make Haiku use less power and make laptops running Haiku last longer on battery.</p>
<p>Some investigation is required to identify the main issues in Haiku leading to suboptimal performance. There are however a few already known problems:</p>
<ul>
<li>Some subsystems such as the network and wireless stack wake up the system at regular intervals (10 or 100 times per second) to perform some tasks. Whenever possible they should be modified to trigger these tasks in anevent-driven way (triggering them from hardware interrupts for example).</li>
<li>Some applications (such as the always-running DeskBar) are polling for events in a similar way. The APIs should be adjusted where possible to make those applications wait on notifications instead.</li>
<li>None of the device drivers in Haiku include powersaving modes. When a device is idle, it should be put to sleep and powered off until it is needed again.</li>

<li>Skill set: kernel development, general C/C++, userland development, debugging, power management / measurement</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Improving the btrfs filesystem
</h4>
<p>Haiku has great support for its own file system, but most others are only
available read-only. It is way better for interoperability with other systems
to be able to write to these disks from Haiku.</p>

<p>The goal of this project is to complete the btrfs filesystem, to allow it
to write btrfs volumes (reading works already). During GSoC 2017, a student
already got as far as creating directories, but it is not possible yet to write
files. The first part of the work is to review the existing code, and report on
the current status and the work needed to get everything in place.</p>

<p>After completion of this project, it should be possible to read and write
files to btrfs volumes, making sure they are interoperable with Linux (mount
without errors, file data is accessible, fsck detects no problems). Stress-testing
should also be performed using bonnie++, and other test suites may also be used.</p>
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, Sean Healy</li>
<li><a href="https://git.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/btrfs">Sourcecode</a></li>
<li><a href="https://www.haiku-os.org/blog/hyche">GSoC 2017 log</a></li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
File Systems: general improvements and new filesystems.
</h4>
<p>Haiku has great support for its own file system, but is completely missing support for some other fielsystems. It is way better for interoperability with other systems to be able to read and write to these disks.</p>
<p>The goal of this project is to port one of the following filesystems to Haiku:</p>
<ol>
<li>ext4: extend the <a href="https://cgit.haiku-os.org/haiku/tree/src/add-ons/kernel/file_systems/ext2">existing ext2/ext3 driver</a> to support new ext3 and ext4 features</li>

<li><a href="http://en.wikipedia.org/wiki/Unix_File_System">UFS2</a> (as used in *BSD): <a href="http://fxr.watson.org/fxr/source/ufs/">FreeBSD implementation</a>, <a href="http://sourceforge.net/p/ufs2tools/code/HEAD/tree/trunk/ufs2tools/">u2fstools for windows</a> (BSD licensed, source can be reused)</li>

<li>HAMMER FS: <a href="http://www.dragonflybsd.org/hammer/">homepage</a>, <a href="http://fxr.watson.org/fxr/source/vfs/hammer/?v=DFBSD">sourcecode</a> (3-clause BSD, a port of the existing code is ok)</li>

<li><a href="http://en.wikipedia.org/wiki/JFS_(file_system)">JFS</a>: existing code in Linux is under the GPL, a rewrite under the MIT license is preferred. The <a href="http://jfs.sourceforge.net/project/pub/jfslayout.pdf">filesystem design and disk structures</a> are well documented.</li>

<li><a href="http://en.wikipedia.org/wiki/Xfs">XFS</a>: <a href="http://xfs.org/index.php/Main_Page">Development community</a>, <a href="http://oss.sgi.com/projects/xfs/index.html">homepage</a>  (existing code in Linux is under the GPL, a rewrite under the MIT license is preferred)</li>

<li><a href="http://en.wikipedia.org/wiki/Zfs">ZFS</a>: <a href="http://www.open-zfs.org/wiki/Main_Page">main page</a>, <a href="https://github.com/illumos/illumos-gate/tree/master/usr/src/uts/common/fs/zfs">existing code</a> (Existing code is under the CDDL, a rewrite is preferred)</li>
</ol>
It's okay to port over the code from other systems, although we prefer code that can be distributed under the MIT license.
<ul><li>
Skill set: kernel, and driver development
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>



<h4><img src="/images/App_Generic_32.png"/>x86-64: Implement support for Process Context Identifiers (PCID)</h4>

<p>on Intel CPUs. The feature tags TLB entries with the Id of the address space and allows to
avoid TLB invalidation on the context switch, it is available only on x86-64.</p>
<p>The goal of this task is to propose possible designs, implement the feature, extend the performance
logs to measure impacts when the feature is enabled, and potentially also to mitigate the
"Meltdown" vulnerability.</p>

<ul><li>
Skill set: kernel development, x86 architecture/assembly language
</li>
<li>Possible mentors/knowledgeable people: korli</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>ARM port / device tree support</h4>

<p>Unlike x86 systems which have a PCI bus, most ARM devices have peripherals at hardcoded addresses. This means automatic hardware discovery is not possible. The Linux kernel developers designed a solution called "flattened device tree". It is a static description of the hardware, telling the kernel where devices are located and which driver to use.</p>

<p>Haiku plans to use device trees to support several ARM devices with the same kernel. This requires updating our drivers and driver infrastructure to not rely so much on the PCI bus. This work should start with the USB EHCI driver, in order to provide at least one mass storage solution to the ARM port of Haiku.</p>

<p>The ARM port of Haiku is currently in an early state. This project may involve debugging of other issues in the port to get it running further, so the device tree part can be tested. Several parts of the early boot code should be reviewed to make use of the device tree and remove hardcoded addresses (RAM mapping, framebuffer, serial port, etc).</p>

<ul><li>
Skill set: kernel development, ARM architecture/assembly
</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, kallisti5</li>
</ul>


<!--
<h4><img src="/images/App_Generic_32.png"/>Unify File System Caches</h4>

<p>
The Haiku kernel provides two kinds of caches for use by file system implementations: the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/file_cache.cpp">file cache</a> and the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/cache/block_cache.cpp">block cache</a>. The file cache caches data at the "file" level, while the block cache is used at the "block" level and is used for on-disk structures as well as file data.</p>

<p>The file cache uses physical memory pages directly and it is linked with the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/vm">VM subsystem</a>, so that pages used for caching are freed automatically (in a least recently used order) when running low on free memory. The block cache, however, uses mapped memory (via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/slab">slab allocator</a>) and freeing memory in low memory situations is handled via the <a href="https://cgit.haiku-os.org/haiku/tree/src/system/kernel/low_resource_manager.cpp">low resource manager</a>.</p>

<p>The first problem with the current implementation is caching imbalance in favor of the block cache: it tends grow more than needed and prevent the file cache to get enough memory.</p>
<p>Another problem is the use of large amounts of kernel address space by the block cache, which can be problematic on 32 bit architectures. This makes the block cache constrained to the 2GB of memory available for the kernel in Haiku, and sometimes makes the kernel run out of address space for other uses.</p>

<p>The goal of this project is to create a common underlying mechanism (using `VMCache`) to unify both caches and move the block cache out of the kernel address space. The following problems need to be investigated and solved:
<ul>
<li>How to deal with heterogenous block sizes (not necessarily matching the page size): each mounted filesystem volume may have a different block size, and the block cache must be able to efficiently cache blocks of these different sizes,
<li>How to map support for transactions to `VMCache` hierarchies,
<li>Balancing of the memory allocation between the block and the file cache and between multiple mounted filesystem volumes.
</ul>
</p>
<ul><li>
Skill set: kernel development
</li></ul>
-->


<a id="network" name="network"></a>
<h3>Network</h3>


<h4><img src="/images/App_Generic_32.png"/>
Bluetooth Stack Improvements
</h4>
<p>Haiku's Bluetooth stack implements a basic subset of general Bluetooth functionality. This functionality needs to be
completed and Bluetooth 2.X and later possibilities explored. This task involves investigating the current state of the
Bluetooth code, improving the existing code on newer devices (pairing, etc), and improving the stack
to make it more useful by implementing driver(s) for Bluetooth device(s) of your choice (file transfers, audio, HID,
networking, etc).</p>

<ul>
<li>Requirements: Bluetooth-enabled Haiku system</li>
<li>Skill set: C++, kernel development, userland development, global bluetooth stack knowledge (optional)</li>
<li>Possible mentors/knowledgeable people: waddlesplash <!-- also possibly PulkoMandy --></li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Integrate our PPP implementation
</h4>
<p>Finish porting the PPP implementation to our new network stack. Add phone-line modem support, including HDLC
framing and VJC compression (porting both algorithms is sufficient, but make sure the license is compatible to MIT).
Implement CHAP authentication, and add support for configuring these to the new network preflet GUI. Find and fix bugs.</p>

<ul>
<li>Tickets: <a href="https://dev.haiku-os.org/ticket/812">#812</a>, <a href="https://dev.haiku-os.org/ticket/869">#869</a>, <a href="https://dev.haiku-os.org/ticket/873">#873</a>, <a href="https://dev.haiku-os.org/ticket/922">#922</a>, <a href="https://dev.haiku-os.org/ticket/923">#923</a>, <a href="https://dev.haiku-os.org/ticket/1059">#1059</a>, maybe: <a href="https://dev.haiku-os.org/ticket/1057">#1057</a>, <a href="https://dev.haiku-os.org/ticket/1058">#1058</a></li>
<li>Skill set: multi-threading basics, maybe network protocols and some kernel/drivers development, maybe UI development</li>
</ul>

<!--

<h4><img src="/images/App_Generic_32.png"/>
Stream Control Transmission Protocol (SCTP)
</h4>
<p>Implement and test SCTP, a message based transport layer protocol similar to TCP and UDP. It should comply with current IP and IPv6 implementations and provide similar programming API as BSD.</p>
<ul>
<li>Skill set: network protocols, kernel and network stack development</li>
</ul>
-->

<h4><img src="/images/App_Generic_32.png"/>
IPv6 finalization
</h4>
<p>
The base framework for IPv6 support was implemented as a Google Summer of Code 2010 project. Even so, there remains a lot of
smaller cleanup/finalization tasks that can be done as a project.
</p>
<ul>
<li>Tickets:
<ul>
<li><a href="https://dev.haiku-os.org/ticket/8293">#8293</a> -- BNetworkAddress needs to check if there is an available IPv6 connection.</li>
<li><a href="https://dev.haiku-os.org/ticket/7228">#7228</a> -- RFC: BNetworkInterfaceAddress needs to store auto-configuration flags</li>
<li><a href="https://dev.haiku-os.org/ticket/6489">#6489</a> -- ifconfig needs to validate availability of ipv6 module prior to utilization</li>
<li><a href="https://dev.haiku-os.org/ticket/2632">#2632</a> -- Possible redefinition for struct sockaddr_in, related to IPv6</li>
<li><a href="https://dev.haiku-os.org/ticket/8319">#8319</a> -- Haiku needs IPv6 duplicate address detection during link scope ip configuration.</li>
<li><a href="https://dev.haiku-os.org/ticket/8317">#8317</a> -- Haiku needs IPv6 global scope Auto Configuration (router advertisement + DHCPv6)</li>
<li><a href="https://dev.haiku-os.org/ticket/11862">#11862</a> -- Net server multi-protocol rework</li>
</ul>
</li>
</ul>

<ul>
<li>Skill set: IPv4 and IPv6 protocols, kernel and network stack development</li>
<li>Possible mentors: jua</li>
</ul>


<a id="user-interface" name="user-interface"></a>
<h3>User Interface</h3>

<!-- removed: needs to be thought out on the mailing list a little better
<h4><img src="/images/App_Generic_32.png"/>
Preferences GUI refactoring
</h4>
<p>
Haiku is an operating system designed for ease of use on desktop computers. A key part of this work is an easy to use set of preference applications. Some of the currently available preference panels could be merged or improved in several ways.</p>
<p>
Several preference applications (aka preflets) could be redesigned. Furthermore, there might still be code that does not yet use our layout API. This work may include (but is not limited to):</p>
<ol>
<li>combining Keymap, Keyboard, Mouse and Touchpad in a single "Input devices" preferences panel,</li>
<li>adding support for joysticks and touch screens support to it,</li>
<li><a href="https://dev.haiku-os.org/ticket/6983">#6983</a>Reworking the Printer preferences to look better and be more intuitive.</li>
<li><a href="https://dev.haiku-os.org/ticket/6206">#6206</a>integrate scrollbar options into a new Appearance preflet, and provide a live preview for all of the settings available in this window</li>
<li>Improving the user interface of the shortcuts preference to make it easier to setup custom shortcuts</li>
<li>Improving and extending the notifications preferences to allow easy control of allowed notifications, browsing of the notification history.</li>
<li>Research on how to improve the other preference panels further with the goal of making them easier to use.</li>
</ol>
<ul>
<li>Skill set: C++, UI development, usability basics</li>
<li>Possible mentors/knowledgeable people: PulkoMandy, waddlesplash</li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>
Modular edit view (BIG)
</h4>

<p>The current solution for text editing in Haiku is the BTextView. It is a
rather simple view providing basic text editing features and limited styling.
This is, however, not powerful enough for most serious uses. The goal of this
project is to design a complete replacement for BTexView, which should be designed
to cover more use cases.</p>

<p>The edit view design should be modular and extensible to make it easy to implement e.g. following features:
<ul>
<li>spell checker</li>
<li>line numbers, ruler, 80 character limit line, hyper links</li>
<li>working on an input stream rather than on a input file e.g. to be able to open files ~100Mb without loading them into memory in one go</li>
<li>Including pictures in the text flow</li>
<li>Sourcecode editor: syntax highlighting, code completion</li>
<li>Ability to load and save data in different formats (using the Translation Kit)</li>
</ul>
</p>

<h5>Existing work</h5>
<p>The HaikuDepot application includes preliminary work on a rich text view,
which it uses to provide the description of packages. This could be used as a
starting point for this work.</p>

<ul>
	<li>Skill set: C++, API design, UI development</li>
	<li>Possible mentors: waddlesplash, Sean Healy, scottmc</li>
</ul>


<a id="media" name="media"></a>
<h3>Media</h3>

<!-- needs to be discussed more; working on a MediaKit2 may make more sense. (Didn't Dan0 have MediaKit2?)
<h4><img src="/images/App_Generic_32.png"/>Add subtitle support to the Media Kit</h4>

<p>Haiku "media" applications rely on a framework called the Media Kit. This
provides an unified API to handle audio and video streams, including codec
plugins to read and write the stream to files or other sources, as well as
transporting the data from one application to another, with a latency as low as
possible.</p>

<p>While our MediaPlayer has support for external subtitle files, the Media Kit
itself has not. The most obvious downside of that is that there is no support
for subtitle (text or bitmap) embedded in video files within the MediaPlayer or
other applications.</p>

<p>Your job would be to design the necessary API extensions to let subtitles fit
in with the rest of the Media Kit, and add native support for them, which will
then be available to all applications as part of the framework.</p>

<ul>
<li>implement the required code to extract the subtitles from source files
(either standalone .srt files or contained for example in mkv containers), with
proper handling of replay time and text encoding</li>

<li>integrate this in the existing API (probably as a new kind of BMediaTrack),
and update applications such as MediaPlayer and MediaConverter to make use of
the feature.</li>

<li>See <a href="/legacy-docs/bebook/TheMediaKit_Overview_Introduction.html" target="_blank">
the BeBook introduction for the Media Kit</a> to become familiar with its design.</li>

<li>Skill set: general C/C++, userland development, API design</li>
<li>Possible mentors: Barrett, jua, PulkoMandy</li>
</ul>
-->

<h4><img src="/images/App_Generic_32.png"/>Complete and Finalize the MediaPlayer Plugin API</h4>

<p>The MediaPlayer app included in Haiku is able to play most of the media
formats around. To be able to do that it includes a monolithic framework that
uses most of the important features of the media_kit. To improve maintainability
and flexibility we are looking forward to include a plugin API and export or
implement as plugins certain functionalities.</p>

<p>
Some examples :
<ul>
	<li>Playlist</li>
	<li>Attributes editor</li>
	<li>Cover Art</li>
	<li>Web Remote Control</li>
</ul>
</p>

<p>
Some efforts have been already put and can be found <a href="https://github.com/Barrett17/haiku/tree/mediaplayer_plugin_api">here</a>.</p>

<p>Other Links:

<ul>
	<li><a href="https://www.haiku-os.org/legacy-docs/bebook/themediakit_overview">Media Kit overview (the Be Book)</a></li>
	<li><a href="https://api.haiku-os.org/group__media.html">Media Kit overview (the Haiku Book)</a></li>
</ul>
</p>

<ul>
	<li>Skill set: general C++, userland development, software design</li>
	<li>Possible mentors: Barrett</li>
</ul>


<!--
<h4><img src="/images/App_Generic_32.png"/>
Implement system wide and application level input/output chooser
</h4>
<p>
When more than one soundcard is attached to Haiku, you can only change the default input/output in the Media preferences, or reconnect media nodes manually via Cortex to another input/output device.
The Media Kit could support default nodes per application (either unset (system default), or set to a specific device), and the Media preferences could offer an UI to change this.
</p>
<p>
Additionally, applications like MediaPlayer, and SoundRecorder should be able to change the input/output device within the application, too (which would just be another way to alter the described Media Kit functionality).</p>
<p>This functionality should only be visible if there actually is more than one audio device attached to the system; if a device is not available, it should automatically use the default output instead.
</p>
<p>
Part of this work would be to implement non-volatile storage that the Media Kit uses for each application that is connected to it, and the ability to detect the application on next start. This storage could then also be used to remember other per application sound settings in the future (or if time permits) like the balance, and relative volume.
</p>

<ul>
<li>Skill set: general C/C++, userland development</li>
<li>Possible mentors: jua</li>
</ul>
-->


<!--
<h4><img src="/images/App_Generic_32.png"/>Improving Clockwerk</h4>

<p>Clockwerk is a video editing bench for Haiku. It works well, but it is a bit
unstable and the feature set is not that complete.</p>
- TODO complete the description -
<ul>
	<li>Possible mentors: jua</li>
</ul>
-->


<a id="other" name="other"></a>
<h3>Other</h3>


<h4><img src="/images/App_Generic_32.png"/>
Jam (build system) replacement/rewrite
</h4>
<p>Haiku uses Jam as its main build system. Unfortunately, Perforce is not actively
maintaining the tool anymore and the codebase is not very clean. Ingo Weinhold
started work on <a href="https://github.com/weinhold/ham">a complete rewrite</a> of the tool in C++, with the aim of being
compatible with the existing build files, but provide a cleaner codebase to
build upon and do away with most of the legacy stuff.</p>
<p>The goal of this project is to continue this work and make ham usable to build
Haiku, as well as other projects currently using Jam as a buildtool.</p>
<ul>
	<li>Skill set: C++, threading, build systems</li>
	<li>Possible mentors: waddlesplash</li>
</ul>

<h4><img src="/images/App_Generic_32.png"/>
Coding style checker bot for Gerrit
</h4>
<p>Haiku has its own <a href="/development/coding-guidelines/">coding guidelines</a>
which describe how the code should be formatted. There is <a href="https://github.com/owenca/haiku-format">a tool</a> for reformatting
or checking if code follows these guidelines, but it has to be compiled on the
developer machine and then run manually.</p>
<p>The goal of this project is to integrate this tool with Gerrit, the web app
we use for code reviews. It could then give quick feedback on the coding style
as soon as a patch is submitted, making the review process smoother and easier.</p>
<p>Ideally, the changes could be run through a specific buildbot configuration,
which would run haiku-format, and then post the result as comments in Gerrit pointing out the lines that need to be fixed, and give a review score to the change.</p>
<ul>
	<li>Skill set: REST APIs, code formatting tools</li>
	<li>Possible mentors: PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
Add Haiku support to Allegro 5.0
</h4>
<p>Allegro is a gaming library. Older version (4.4) did support Haiku, but this
support was dropped from the newer versions (starting from 5.0). The library
should be ported to Haiku, allowing to run the bundled examples and possibly
port some other software using it.</p>

<ul>
	<li>Skill set: C++, userland development</li>
	<li>Possible mentors: scottmc</li>
	<li>Alternative projects: porting SFML or another similar library</li>
</ul>


<!-- REMOVED: needs more thinking on Haiku side to decide on a plan for this.

<h4><img src="/images/App_Generic_32.png"/>
Modify the app_server to support compositing
</h4>
<p>This would be a step towards faster/smoother scrolling, window positioning and drawing. Once compositing is in place, it would also be possible to create Compiz-like effects in Haiku, eg. drop shadows, transparent windows, content previews, and window animations.</p>
<p>There's lots of info on what would need to be done and how to go about it in this article: /articles/2011-06-15_how_transform_app_server_code_use_compositing .</p>
<ul>
<li>Skill set: C++, graphics development</li>
</ul>
-->


<h4><img src="/images/App_Generic_32.png"/>
Multiple monitors output in app_server
</h4>
<p>app_server is Haiku's graphics server and the equivalent of X11 or Wayland on other UNIX systems. It currently supports only one video output, but should be able to do more.</p>
<p>While the API already allows this for the most part (with the BScreen class), there is no actual implementation behind it and parts of the code assume only a single screen.</p>
<p>Some drivers implement minimal support for multiple displays, but not all of them. This task may involve updating the video drivers to handle multiple monitors correctly.</p>
<ul>
<li>Skill set: C++, graphics development</li>
<li>Possible mentors/knowledgeable people: jua, PulkoMandy</li>
</ul>


<h4><img src="/images/App_Generic_32.png"/>
	Complex font rendering in app_server
</h4>
<p>app_server is the graphics server in Haiku. It handles the rendering and
display of application windows, desktop, and everything that is shown on screen.</p>
<p>Freetype (in combination with agg) is used to render text. While it provides
good results on its own for latin and cyrillic alphabets, Freetype is not enough
on its own to properly render other scripts with more complex rules, such as
Devanagari or Arabic.</p>
<p>The goal of this task is to integrate Harfbuzz into app_server, so that the
complex rules for text rendering are properly applied. This would allow rendering
of complex languages as mentioned above, as well as mixing different languages
(picking appropriate fonts automatically).</p>
<p>This task can be further extended with investigations of API changes required
in the interface kit (and in particular BView and BFont) to properly handle left
to right text.</p>

<ul>
	<li>Skill set: C++</li>
	<li>Possible mentors: stippi, PulkoMandy</li>
</ul>

<!--
<h4><img src="/images/App_Generic_32.png"/>
RTL languages support in interface kit
</h4>
<p>The interface kit is the part of the API taking care of everything drawing related: windows, buttons, and other widgets. It is not currently able to display right-to-left languages (such as arabic) properly, making Haiku unusable for a lot of people.</p>
<p>Font rendering should be reworked to use the HarfBuzz library, instead of just Freetype, providing support for ligatures and bidirectional text output. The Layout Kit (which handles positionning widgets in a window) should be made to work as expected with these languages (possibly inverting left and right in the window layout).</p>
<p>This task can be extended with better support for font overlays (picking the correct font for each language automatically, probably using fontconfig), and work on input methods for some languages.</p>
<ul>
<li>Skill set: C++, graphics development, text rendering</li>
<li>Possible mentors/knowledgeable people: PulkoMandy</li>
</ul>
-->
