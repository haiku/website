<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Storage Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheStorageKit.html" title="The Storage Kit" /><link rel="prev" href="BVolumeRoster.html" title="BVolumeRoster" /><link rel="next" href="TheStorageKit_Functions.html" title="Functions" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BVolumeRoster.html" title="BVolumeRoster"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheStorageKit.html" title="The Storage Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheStorageKit_Functions.html" title="Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Storage Kit</div></div><div id="headerB">Prev: <a href="BVolumeRoster.html">BVolumeRoster</a>  Up: <a href="TheStorageKit.html">The Storage Kit</a>  Next: <a href="TheStorageKit_Functions.html">Functions</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="The_Node_Monitor"></a>The Node Monitor</h2></div></div></div><p>Declared in: <code class="filename">storage/NodeMonitor.h</code></p><p>The Node Monitor is a service that lets you ask to be notified of certain
file system changes. You can ask to be told when a change is made to…</p><ul class="itemizedlist"><li><p>The contents of a specific directory.</p></li><li><p>The name of a specific entry.</p></li><li><p>Any stat field of a specific entry.</p></li><li><p>Any attribute of a specific entry.</p></li></ul><p>You can also ask to be notified when…</p><ul class="itemizedlist"><li><p>Volumes are mounted and unmounted.</p></li></ul><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Volume monitoring is also provided by the
<a class="link" href="BVolumeRoster.html" title="BVolumeRoster"><code class="classname">BVolumeRoster</code></a> class:
<a class="link" href="BVolumeRoster.html" title="BVolumeRoster"><code class="classname">BVolumeRoster</code></a>
can talk to the Node Monitor for you. The
<a class="link" href="BVolumeRoster.html" title="BVolumeRoster"><code class="classname">BVolumeRoster</code></a>
volume-watching API is more humane than that which you'll find here.</p></div></div></div><p>When something interesting happens, the Node Monitor lets you know by
sending a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
to the target of your choice.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1256724"></a>Node Monitor Functions</h3></div></div></div><p>There are two Node Monitor functions,
<code class="function">watch_node()</code> and
<code class="function">stop_watching()</code>.
The names are a wee bit misleading, so before we go on to the full
technical descriptions, let's nip some buds:</p><ul class="itemizedlist"><li><p><a class="link" href="The_Node_Monitor.html#watch_node" title="watch_node()"><code class="function">watch_node()</code></a>
tells the Node Monitor to start <span class="emphasis"><em>or stop</em></span> watching a
<span class="emphasis"><em>specific</em></span> node, or to watch for volumes being mounted and unmounted.
Memorize the emphasized words.</p></li><li><p><a class="link" href="The_Node_Monitor.html#stop_watching" title="stop_watching()"><code class="function">stop_watching()</code></a>
tells the Node Monitor to stop sending notifications to a particular target.</p></li></ul><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="watch_node"></a>watch_node()</h4></div></div></div><a id="id1256792" class="indexterm"></a><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">watch_node</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">node_ref* </span><span class="parameter">nref</span></span>,<br />                    <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span></span>,<br />                    <span class="methodparam"><span class="type"><a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> </span><span class="parameter">messenger</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">watch_node</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">node_ref* </span><span class="parameter">nref</span></span>,<br />                    <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span></span>,<br />                    <span class="methodparam"><span class="modifier">const </span><span class="type"><a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>* </span><span class="parameter">handler</span></span>,<br />                    <span class="methodparam"><span class="modifier">const </span><span class="type"><a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>* </span><span class="parameter">looper</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>
</div><p>
<code class="function">watch_node()</code> tells the Node Monitor to…
</p><ul class="itemizedlist"><li><p>
…start paying attention to the node specified by the
<a class="link" href="BNode.html#node_ref" title="node_ref"><span class="type">node_ref</span></a>
argument. If you're watching for volumes (only), <code class="parameter">nref</code> can be <code class="constant">NULL</code>. The
easiest way to get a
<a class="link" href="BNode.html#node_ref" title="node_ref"><span class="type">node_ref</span></a> is to invoke
<a class="link" href="BStatable.html#BStatable_GetNodeRef" title="GetNodeRef()"><code class="methodname">BStatable::GetNodeRef()</code></a> on
any <a class="link" href="BEntry.html" title="BEntry"><code class="classname">BEntry</code></a> or
<a class="link" href="BNode.html" title="BNode"><code class="classname">BNode</code></a> object.
</p></li><li><p>
The <code class="parameter">flags</code> argument lists the changes that you want the Monitor to pay
attention to. See below for details.
</p></li><li><p>
The target of the change notification messages is specified either as
a <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a>,
or as a <a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> /
<a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> pair. (The target
specification follows the
<a class="link" href="BInvoker.html#BInvoker_SetTarget" title="SetTarget(), Target(), IsTargetLocal(), Messenger()"><code class="methodname">BInvoker::SetTarget()</code></a> protocol; see the
<a class="link" href="BInvoker.html" title="BInvoker"><code class="classname">BInvoker</code></a> class for details.)
The notification shows up as a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> in
the target's
<a class="link" href="BHandler.html#BHandler_MessageReceived" title="MessageReceived()"><code class="methodname">MessageReceived()</code></a> function.
</p></li></ul><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>You can't tell the Node Monitor to send its notifications to another
application. Currently, the
<a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a>
that you specify must identify a target in the caller's team.</p></div></div></div><p>
Jumping ahead a bit, here's a sample function that tells the Node Monitor
to watch for name and attribute changes to a given entry. The Monitor's
notifications will be sent to the application's main loop:
</p><pre class="programlisting example cpp"><span class="type">status_t</span> <code class="methodname">WatchThis</code>(<code class="classname">BEntry</code> *<code class="parameter">entry</code>)
{
   <span class="type">node_ref</span> <code class="varname">nref</code>;
   <code class="varname">entry</code>-&gt;<code class="methodname">GetNodeRef</code>(&amp;<code class="varname">nref</code>);
   return (watch_node(&amp;<code class="varname">nref</code>,
            <code class="constant">B_WATCH_NAME</code> | <code class="constant">B_WATCH_ATTR</code>,
            <code class="varname">be_app_messenger</code>));
}</pre><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1257134"></a><a id="B_STOP_WATCHING"></a>
<a id="B_WATCH_NAME"></a>
<a id="B_WATCH_STAT"></a>
<a id="B_WATCH_ATTR"></a>
<a id="B_WATCH_DIRECTORY"></a>
<a id="B_WATCH_ALL"></a>
<a id="B_WATCH_MOUNT"></a>
Monitor Flags</h5></div></div></div><a id="id1257171" class="indexterm"></a><a id="id1257180" class="indexterm"></a><a id="id1257189" class="indexterm"></a><a id="id1257198" class="indexterm"></a><a id="id1257207" class="indexterm"></a><a id="id1257217" class="indexterm"></a><a id="id1257226" class="indexterm"></a><p><code class="function">watch_node()</code>'s <code class="parameter">flags</code>
argument is a combination of the following</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_WATCH_NAME</code></span></p></td><td><p>Watches for name changes. This includes moving the node
to a different directory, or removing the node altogether.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WATCH_STAT</code></span></p></td><td><p>Watches for any change to the node's <span class="type">stat</span> structure.
This includes changes to the size, modification date, owner, and so on.
See  "The stat Structure" in the
<a class="link" href="BStatable.html" title="BStatable"><code class="classname">BStatable</code></a> class for a
description of what's in the <span class="type">stat</span> structure.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WATCH_ATTR</code></span></p></td><td><p>Watches for changes to any of the node's attributes.
This includes adding and removing attributes.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WATCH_DIRECTORY</code></span></p></td><td><p>Only applies to nodes that are directories. The
flag tells the Monitor to watch for changes (new entries, entry
deletions, entries being renamed) to the directory. (You can apply the
other flags to a directory, as well). It's not an error to set
<code class="constant">B_WATCH_DIRECTORY</code> on a node that isn't a directory—but it doesn't
do anything for you.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WATCH_ALL</code>.</span></p></td><td><p>This is a convenience that combines all the above.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WATCH_MOUNT</code></span></p></td><td><p>Watches for volumes being mounted and unmounted. As
mentioned above, the <code class="parameter">nref</code> argument isn't
needed (it can be <code class="constant">NULL</code>) if all
you're doing is watching volumes. <code class="constant">B_WATCH_MOUNT</code> isn't included in
<code class="constant">B_WATCH_ALL</code>.</p></td></tr></tbody></table><p>There's one other constant, which lives in a class by itself:</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_STOP_WATCHING</code></span></p></td><td><p>Tells the Node Monitor to stop
watching the <code class="parameter">nref</code> argument.</p></td></tr></tbody></table><p>You can't combine <code class="constant">B_STOP_WATCHING</code> with any of the others in an attempt to
stop watching a specific category of changes. For example, if you call…</p><pre class="programlisting example cpp"><code class="function">watch_node</code>(&amp;<code class="varname">nref</code>, <code class="constant">B_WATCH_STAT</code>, <code class="varname">be_app_messenger</code>);
<code class="function">watch_node</code>(&amp;<code class="varname">nref</code>, <code class="constant">B_WATCH_ATTR</code>, <code class="varname">be_app_messenger</code>);</pre><p>…and then call…</p><pre class="programlisting example cpp"><code class="function">watch_node</code>(&amp;<code class="varname">nref</code>, <code class="constant">B_STOP_WATCHING</code>, <code class="varname">be_app_messenger</code>);</pre><p>…both of the previous Monitor calls are stopped.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p><code class="constant">B_STOP_WATCHING</code> does not apply to volume watching. The only way to stop
monitoring volume un/mounts is to call <code class="function">stop_watching()</code>.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1257527"></a>Combining Flags and the 4096 Limit</h5></div></div></div><p>If you can, you should combine as many flags as you're going to need in
single calls to <code class="function">watch_node()</code>. Recall the example used above:</p><pre class="programlisting example cpp"><code class="function">watch_node</code>(&amp;<code class="varname">nref</code>,
    <code class="constant">B_WATCH_NAME</code> | <code class="constant">B_WATCH_ATTR</code>,
    <code class="varname">be_app_messenger</code>);</pre><p>This is better than making separate <code class="function">watch_node()</code> calls (one to pass
<code class="constant">B_WATCH_NAME</code> and another to pass
<code class="constant">B_WATCH_ATTR</code>)—not only because the
single call is naturally more efficient than two, but also because the
Node Monitor can only monitor 4096 nodes per team at a time. Every call
to <code class="function">watch_node()</code> consumes a Node Monitor slot, even if you're already
monitoring the requested node.</p><p>If you want to watch all aspects of a node, just pass <code class="constant">B_WATCH_ALL</code> to
every <code class="function">watch_node()</code> call. This will consume only a single Node Monitor
slot.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheNodeMonitor_NotificationMessages"></a><a id="B_NODE_MONITOR"></a>Notification Messages</h5></div></div></div><p>A <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
notification sent by the Node Monitor looks like this:</p><ul class="itemizedlist"><li><p>The <code class="varname">what</code> value is <code class="constant">B_NODE_MONITOR</code>.</p></li><li><p>The field named <code class="varname">opcode</code> is an
<span class="type">int32</span> constant that tells you what
happened.</p></li><li><p>Additional fields give you information (device, node, name, and so
on) about the node (or volume) that it happened to.</p></li></ul><p>The <code class="varname">opcode</code> constants and additional fields are described in
"<a class="link" href="The_Node_Monitor.html#TheNodeMonitor_Opcode_Constants" title="Opcode Constants">Opcode Constants</a>."
In general, the opcodes correspond to the flags that you
passed to <code class="function">watch_node()</code>; however, this correspondence isn't always
one-to-one.</p><p>There are seven opcode constants:</p><ul class="itemizedlist"><li><p><code class="constant">B_ENTRY_CREATED</code></p></li><li><p><code class="constant">B_ENTRY_REMOVED</code></p></li><li><p><code class="constant">B_ENTRY_MOVED</code></p></li><li><p><code class="constant">B_STAT_CHANGED</code></p></li><li><p><code class="constant">B_ATTR_CHANGED</code></p></li><li><p><code class="constant">B_DEVICE_MOUNTED</code></p></li><li><p><code class="constant">B_DEVICE_UNMOUNTED</code></p></li></ul></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The Node Monitor is off and running.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Bad <code class="parameter">nref</code>
argument (not applicable to mount-only watches), or poorly formed target.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Couldn't allocate resources, or out of Node Monitor
slots.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code>.</span></p></td><td><p>Some cases of bad <code class="parameter">nref</code>
arguments erroneously return <code class="constant">B_ERROR</code>.
This will be fixed.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="stop_watching"></a>stop_watching()</h4></div></div></div><a id="id1257870" class="indexterm"></a><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span>(<span class="methodparam"><span class="type"><a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> </span><span class="parameter">messenger</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span>(<span class="methodparam"><span class="modifier">const </span><span class="type"><a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>* </span><span class="parameter">handler</span></span>,<br />          <span class="methodparam"><span class="modifier">const </span><span class="type"><a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>* </span><span class="parameter">looper</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>
</div><p>Tells the Node Monitor to stop sending notifications to the target
described by the arguments. All the Node Monitor "slots" that were
allocated to the target are freed. Keep in mind that are only 4096 slots
for the entire system.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The target is now out of the Node Monitor loop.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Badly formed target description.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheNodeMonitor_Opcode_Constants"></a>Opcode Constants</h3></div></div></div><p>The following sections describe the "opcode" constants; these are the
values that appear in the <code class="varname">opcode</code> field of the
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>s that are
generated by the Node Monitor. Note that in these descriptions, the use
of the terms "entry" and "node" is sometimes blurred.</p><p>Declared in: <code class="filename">storage/NodeMonitor.h</code></p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_ENTRY_CREATED"></a>B_ENTRY_CREATED</h4></div></div></div><a id="id1258331" class="indexterm"></a><p>A completely new entry was created in a monitored directory. (This
doesn't include entries that are moved into this directory from some
other directory—see
<a class="link" href="The_Node_Monitor.html#B_ENTRY_MOVED" title="B_ENTRY_MOVED"><code class="constant">B_ENTRY_MOVED</code></a>.)</p><p>You get this notification if you applied
<a class="link" href="The_Node_Monitor.html#B_WATCH_DIRECTORY"><code class="constant">B_WATCH_DIRECTORY</code></a>
to the directory in which the entry was created. The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td><code class="varname">opcode</code></td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_ENTRY_CREATED</code></td></tr><tr><td><code class="varname">name</code></td><td><code class="constant">B_STRING_TYPE</code></td><td>The name of the new entry.</td></tr><tr><td><code class="varname">directory</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> (node) number for the directory in
which the entry was created.</td></tr><tr><td><code class="varname">device</code></td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the device on which the new
entry resides.</td></tr><tr><td><code class="varname">node</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span>
number of the new entry itself. (More
accurately, it identifies the node that corresponds to the entry.)</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheNodeMonitor_ParsingAndTricks"></a>Parsing and Tricks</h5></div></div></div><p>In your code, you would parse a
<code class="constant">B_ENTRY_CREATED</code> message like this:</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">MyTarget</code>::<code class="methodname">MessageReceived</code>(<span class="type">BMessage *</span><code class="parameter">msg</code>)
{
   <span class="type">int32</span> <code class="varname">opcode</code>;
   <span class="type">dev_t</span> <code class="varname">device</code>;
   <span class="type">ino_t</span> <code class="varname">directory</code>;
   <span class="type">ino_t</span> <code class="varname">node</code>;
   <span class="type">const char *</span><code class="varname">name</code>;

   if (<code class="parameter">msg</code>-&gt;<code class="varname">what</code> == <code class="constant">B_NODE_MONITOR</code>) {
      if (<code class="parameter">msg</code>-&gt;<code class="methodname">FindInt32</code>("opcode", &amp;<code class="varname">opcode</code>) == <code class="constant">B_OK</code>) {
         switch (<code class="varname">opcode</code>) {
            case <code class="constant">B_ENTRY_CREATED</code>:
               <code class="parameter">msg</code>-&gt;<code class="methodname">FindInt32</code>("device", &amp;<code class="varname">device</code>);
               <code class="parameter">msg</code>-&gt;<code class="methodname">FindInt64</code>("directory", &amp;<code class="varname">directory</code>);
               <code class="parameter">msg</code>-&gt;<code class="methodname">FindInt64</code>("node", &amp;<code class="varname">node</code>);
               <code class="parameter">msg</code>-&gt;<code class="methodname">FindString</code>("name", &amp;<code class="varname">name</code>);
               break;
            ...</pre><p>So, what do you do with these fields?</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1258689"></a>Create an <span class="type">entry_ref</span> to the entry.</h6></div></div></div><p>The <code class="varname">device</code>, <code class="varname">directory</code>, and
<code class="varname">name</code> fields can be used to create an
<span class="type">entry_ref</span> to the new entry:</p><pre class="programlisting example cpp"><span class="type">entry_ref</span> <code class="varname">ref</code>;
<span class="type">const char *</span><code class="varname">name</code>;
...
<code class="parameter">msg</code>-&gt;<code class="methodname">FindInt32</code>("device", &amp;<code class="varname">ref</code>.<code class="varname">device</code>);
<code class="parameter">msg</code>-&gt;<code class="methodname">FindInt64</code>("directory", &amp;<code class="varname">ref</code>.<code class="varname">directory</code>);
<code class="parameter">msg</code>-&gt;<code class="methodname">FindString</code>("name", &amp;<code class="varname">name</code>);
<code class="varname">ref</code>.<code class="methodname">set_name</code>(<code class="varname">name</code>);</pre></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1258792"></a>Create a node_ref to the entry.</h6></div></div></div><p>If you want to start Node Monitoring the new entry (or, more accurately,
the node of the new entry), you stuff <code class="varname">device</code> and <code class="varname">directory</code> into a
<span class="type">node_ref</span>:</p><pre class="programlisting example cpp"><span class="type">node_ref</span> <code class="varname">nref</code>;
<span class="type">status_t</span> <code class="varname">err</code>;

...
<code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("device", &amp;<code class="varname">nref</code>.<code class="varname">device</code>);
<code class="varname">msg</code>-&gt;<code class="methodname">FindInt64</code>("node", &amp;<code class="varname">nref</code>.<code class="varname">node</code>);

<code class="varname">err</code> = <code class="function">watch_node</code>(&amp;<code class="varname">nref</code>, <code class="constant">B_WATCH_ALL</code>, <code class="varname">be_app_messenger</code>);</pre></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1258889"></a>Create a node_ref to the entry's parent.</h6></div></div></div><p>Note that the <code class="varname">directory</code> field is a node number. By combining this
number with the <code class="varname">device</code> field, you can create a <span class="type">node_ref</span> that points to
the entry's parent. From there, you're a
<a class="link" href="BDirectory.html#BDirectory_SetTo" title="SetTo(), Unset()"><code class="methodname">SetTo()</code></a>
away from a <a class="link" href="BDirectory.html" title="BDirectory"><code class="classname">BDirectory</code></a>
object:</p><pre class="programlisting example cpp"><span class="type">node_ref</span> <code class="varname">nref</code>;
<code class="classname">BDirectory</code> <code class="varname">dir</code>;
<span class="type">status_t</span> <code class="varname">err</code>;

...
<code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("device", &amp;<code class="varname">nref</code>.<code class="varname">device</code>);
<code class="varname">msg</code>-&gt;<code class="methodname">FindInt64</code>("directory", &amp;<code class="varname">nref</code>.<code class="varname">node</code>);
<code class="varname">err</code> = <code class="varname">dir</code>.<code class="methodname">SetTo</code>(&amp;<code class="varname">nref</code>);</pre></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_ENTRY_REMOVED"></a>B_ENTRY_REMOVED</h4></div></div></div><a id="id1259017" class="indexterm"></a><p>A node was removed (deleted) from a directory.</p><p>You get this if you applied
<a class="link" href="The_Node_Monitor.html#B_WATCH_NAME"><code class="constant">B_WATCH_NAME</code></a>
on the node itself, or
<a class="link" href="The_Node_Monitor.html#B_WATCH_DIRECTORY"><code class="constant">B_WATCH_DIRECTORY</code></a>
on the directory that the node lived in. The message's
fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td><code class="varname">opcode</code></td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_ENTRY_REMOVED indicates that an entry was removed.</code></td></tr><tr><td><code class="varname">directory</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> (node) number of the directory from
which the entry was removed.</td></tr><tr><td><code class="varname">device</code></td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the device that the removed
node used to live on.</td></tr><tr><td><code class="varname">node</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> number of the node that was removed.</td></tr></tbody></table></div><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Since this message is telling you that the node was removed, the "node"
value will be invalid. The node number can be useful (and sometimes
necessary) for comparison with cached node numbers (as demonstrated
below).</p></div></div></div><p>Parsing the message is the same as for
<a class="link" href="The_Node_Monitor.html#B_ENTRY_CREATED" title="B_ENTRY_CREATED"><code class="constant">B_ENTRY_CREATED</code></a>,
but without the <code class="varname">name</code> field. See
"<a class="xref" href="The_Node_Monitor.html#TheNodeMonitor_ParsingAndTricks" title="Parsing and Tricks">Parsing and Tricks</a>,"
above.</p><p>Note that the <code class="constant">B_ENTRY_REMOVED</code> message is sent as soon as the node's entry
is "unlinked" from its directory. The node itself may linger for while
after that. Follow this logic:</p><ul class="itemizedlist"><li><p>When a file (regardless of flavor) is removed, the entry for that
file is immediately removed ("unlinked") from the file hierarchy, and
the Node Monitor message is immediately sent—even if you have an
object that has opened the file's node.</p></li><li><p>The node isn't actually destroyed until the last open object (to that
node) is destroyed. (In POSIX speak, the node is destroyed when the
last file descriptor to the node is closed.)</p></li><li><p>Until the node is destroyed, the open objects (file descriptors) can
still access the node's data.</p></li></ul><p>You can take advantage of this to warn a user that a file is going to go
away, or to make a backup, or whatever. For example, let's say you have
an application that lets the user open files; each time a file is opened,
your <code class="function">OpenFile()</code> function creates a
<a class="link" href="BFile.html" title="BFile"><code class="classname">BFile</code></a>
object and starts the Node Monitor running:</p><pre class="programlisting example cpp"><span class="type">status_t</span> <code class="classname">YourApp</code>::<code class="methodname">OpenFile</code>(<span class="type">const char *</span><code class="parameter">pathname</code>)
{
   <span class="type">BFile *</span><code class="varname">file</code>;
   <span class="type">node_ref</span> <code class="varname">nref</code>;
   <span class="type">status_t</span> <code class="varname">err</code>;

   <code class="varname">file</code> = new <code class="classname">BFile</code>(<code class="parameter">pathname</code>, <code class="constant">B_READ_WRITE</code>);
   if ((<code class="varname">err</code>=<code class="varname">file</code>-&gt;<code class="methodname">InitCheck</code>()) != <code class="constant">B_OK</code>)
      return <code class="varname">err</code>;

   <code class="varname">file</code>-&gt;<code class="methodname">GetNodeRef</code>(&amp;<code class="varname">nref</code>);
   <code class="varname">err</code> = <code class="function">watch_node</code>(&amp;<code class="varname">nref</code>, <code class="constant">B_WATCH_NAME</code>, <code class="varname">be_app_messenger</code>);

   if (<code class="varname">err</code> != <code class="constant">B_OK</code>) {
      delete <code class="varname">file</code>;
      return <code class="varname">err</code>;
   }

   <span class="comment">/* We've got the file and we're monitoring it; now we cache
   * the BFile by adding it to a BList (data member).
   * function. There's a race condition between the
   * watch_node() call above and the following AddItem().
   */</span>
   return ((<code class="varname">FileList</code>-&gt;<code class="methodname">AddItem</code>((<span class="type">void *</span>)<code class="varname">file</code>)) ? <code class="constant">B_OK</code> : <code class="constant">B_ERROR</code>);

}</pre><p>Now we receive a Node Monitor message telling us the node has been
removed. We stuff the <code class="varname">device</code> and <code class="varname">node</code>
fields into a <span class="type">node_ref</span> and pass
them to a (fictitious) <code class="methodname">AlertUser()</code> function:</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">YourApp</code>::<code class="methodname">MessageReceived</code>(<span class="type">BMessage *</span><code class="parameter">msg</code>)
{
   <span class="type">int32</span> <code class="varname">opcode</code>;
   <span class="type">node_ref</span> <code class="varname">nref</code>;

   if (<code class="varname">msg</code>-&gt;<code class="varname">what</code> == <code class="constant">B_NODE_MONITOR</code>) {
      if (<code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("opcode", &amp;<code class="varname">opcode</code>) == <code class="constant">B_OK</code>) {
         switch (<code class="varname">opcode</code>) {
            case <code class="constant">B_ENTRY_REMOVED</code>:
               <code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("device", &amp;<code class="varname">nref</code>.<code class="varname">device</code>);
               <code class="varname">msg</code>-&gt;<code class="methodname">FindInt64</code>("node", &amp;<code class="varname">nref</code>.<code class="varname">node</code>);
               <code class="methodname">GoodbyeFile</code>(<code class="varname">nref</code>);
   ...
}</pre><p>The implementation of <code class="methodname">GoodbyeFile()</code> (which we won't show here) would walk
down the <a class="link" href="BFile.html" title="BFile"><code class="classname">BFile</code></a>
list looking for a <span class="type">node_ref</span> that matches the argument:</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">YourApp</code>::<code class="methodname">GoodbyeFile</code>(<span class="type">node_ref</span> <code class="parameter">nref</code>)
{
   <span class="type">BFile *</span><code class="varname">filePtr</code>;
   <span class="type">int32</span> <code class="varname">ktr</code> = 0;
   <span class="type">node_ref</span> <code class="varname">cref</code>;

   while ((*<code class="varname">filePtr</code> = (<span class="type">BFile *</span>)<code class="varname">FileList</code>-&gt;<code class="methodname">ItemAt</code>(<code class="varname">ktr</code>++))) {
      <code class="varname">filePtr</code>-&gt;<code class="methodname">GetNodeRef</code>(&amp;<code class="varname">cref</code>);
      if (<code class="parameter">nref</code> == <code class="varname">cref</code>) {
         <span class="comment">/* We found it. Now we do whatever
         * we need to do.
         */</span>
      }
   }
}</pre><p>If a match is found, your app could then do whatever it needs to do.
Remember—the node's data is still valid until your
<a class="link" href="BFile.html" title="BFile"><code class="classname">BFile</code></a> is
destroyed or re-initialized.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_ENTRY_MOVED"></a>B_ENTRY_MOVED</h4></div></div></div><a id="id1259711" class="indexterm"></a><p>A node was moved from one directory to a different directory.</p><p>You get this if you applied
<a class="link" href="The_Node_Monitor.html#B_WATCH_NAME"><code class="constant">B_WATCH_NAME</code></a> on the node itself, or
<a class="link" href="The_Node_Monitor.html#B_WATCH_DIRECTORY"><code class="constant">B_WATCH_DIRECTORY</code></a>
on either of the directories. The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td><code class="varname">opcode</code></td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_ENTRY_MOVED indicates that an existing entry moved from one directory to another.</code></td></tr><tr><td><code class="varname">name</code></td><td><code class="constant">B_STRING_TYPE</code></td><td>The name of the entry that moved.</td></tr><tr><td><code class="varname">from directory</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> (node) number of the directory
from that the node was removed from.</td></tr><tr><td><code class="varname">to directory</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> (node) number of the directory that
the node was added to.</td></tr><tr><td><code class="varname">device</code></td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the device that the moved node
entry lives on. (You can't move a file between devices, so this value
will be apply to the file's old and new locations.)</td></tr><tr><td><code class="varname">node</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> number of the node that moved.</td></tr></tbody></table></div><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Moving a node <span class="emphasis"><em>does not</em></span> change its <span class="type">ino_t</span> number.</p></div></div></div><p>Parsing the message is much the same as for
<a class="link" href="The_Node_Monitor.html#B_ENTRY_CREATED" title="B_ENTRY_CREATED"><code class="constant">B_ENTRY_CREATED</code></a>,
modulo the
<code class="varname">directory</code> field changes. See
"<a class="xref" href="The_Node_Monitor.html#TheNodeMonitor_ParsingAndTricks" title="Parsing and Tricks">Parsing and Tricks</a>"</p><p>Moving a node doesn't affect the objects that hold the node open. They
(the objects) can continue to read and write data from the node.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_STAT_CHANGED"></a>B_STAT_CHANGED</h4></div></div></div><a id="id1259984" class="indexterm"></a><p>A field in the node's <span class="type">stat</span> structure changed (this doesn't include
the <span class="type">stat</span> structure disappearing because the node was deleted).</p><p>You get this if you applied
<a class="link" href="The_Node_Monitor.html#B_WATCH_STAT"><code class="constant">B_WATCH_STAT</code></a>
on the node itself. The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td><code class="varname">opcode</code></td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_STAT_CHANGED indicates that some statistic of a node
(as recorded in its <span class="type">stat</span> structure) changed.</code></td></tr><tr><td><code class="varname">node</code></td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> number of the node.</td></tr><tr><td><code class="varname">device</code></td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the node's device.</td></tr></tbody></table></div><p>The stat structure is described in
"The stat Structure" in the
<a class="link" href="BStatable.html" title="BStatable"><code class="classname">BStatable</code></a>
class. The fields that you can change are:</p><ul class="itemizedlist"><li><p>Owner (<code class="varname">st_uid</code>), group (<code class="varname">st_gid</code>),
and permissions (low four bytes of <code class="varname">st_mode</code>).</p></li><li><p>Creation (<code class="varname">st_ctime</code>), modification (<code class="varname">st_mtime</code>), and access times
(<code class="varname">st_atime</code>; currently unused).</p></li><li><p>The size of the node's data (<code class="varname">st_size</code>). The measurement doesn't
include attributes.</p></li></ul><p>A couple of important points:</p><ul class="itemizedlist"><li><p>The <code class="constant">B_STAT_CHANGED</code> message doesn't give you enough information to
construct an object from which you can get a <span class="type">stat</span> structure. In other
words, you can't play the same games that were described in
"<a class="xref" href="The_Node_Monitor.html#TheNodeMonitor_ParsingAndTricks" title="Parsing and Tricks">Parsing and Tricks</a>."</p></li><li><p>The message also doesn't tell you which stat field changed.</p></li></ul><p>In most uses of the <code class="constant">B_STAT_CHANGED</code> message, you have to cache the objects
that you're monitoring so you can compare their <span class="type">node_ref</span>s to the message
fields (an example of this is given in
<a class="link" href="The_Node_Monitor.html#B_ENTRY_REMOVED" title="B_ENTRY_REMOVED"><code class="constant">B_ENTRY_REMOVED</code></a>).
Furthermore, you
may want to cache the objects' <span class="type">stat</span> structures so you can figure out
which field changed.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_ATTR_CHANGED"></a>B_ATTR_CHANGED</h4></div></div></div><a id="id1260279" class="indexterm"></a><p>An attribute of the node changed.</p><p>You get this if you applied
<a class="link" href="The_Node_Monitor.html#B_WATCH_ATTR"><code class="constant">B_WATCH_ATTR</code></a>
on the node itself. The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td>"opcode"</td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_ATTR_CHANGED indicates that some attribute of a node changed.</code></td></tr><tr><td>"node"</td><td><code class="constant">B_INT64_TYPE</code></td><td>The ino_t number of the node.</td></tr><tr><td>"device"</td><td><code class="constant">B_INT32_TYPE</code></td><td>The dev_t number of the node's device.</td></tr></tbody></table></div><p>Attributes are key/value pairs that can be "attached" to any file
(regardless of flavor). They're described in the
<a class="link" href="BNode.html" title="BNode"><code class="classname">BNode</code></a> class.</p><p>As with
<a class="link" href="The_Node_Monitor.html#B_STAT_CHANGED" title="B_STAT_CHANGED"><code class="constant">B_STAT_CHANGED</code></a>
messages, you may not be able to use the
<code class="constant">B_ATTR_CHANGED</code>
information directly. Instead, you have to cache references to the
(<a class="link" href="BNode.html" title="BNode"><code class="classname">BNode</code></a>)
objects that you're monitoring so you can
compare their <span class="type">node_ref</span>s to the message fields (an example of this is
given in
<a class="link" href="The_Node_Monitor.html#B_ENTRY_REMOVED" title="B_ENTRY_REMOVED"><code class="constant">B_ENTRY_REMOVED</code></a>).</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_DEVICE_MOUNTED"></a>B_DEVICE_MOUNTED</h4></div></div></div><a id="id1260461" class="indexterm"></a><p>A file system device (in other words, a volume) was mounted.</p><p>You get this if you passed
<a class="link" href="The_Node_Monitor.html#B_WATCH_MOUNT"><code class="constant">B_WATCH_MOUNT</code></a> to
<a class="link" href="The_Node_Monitor.html#watch_node" title="watch_node()"><code class="function">watch_node()</code></a>.
The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td>"opcode"</td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_DEVICE_MOUNTED indicates that a new device (or file system volume) has been mounted.</code></td></tr><tr><td>"new device"</td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the newly-mounted device.</td></tr><tr><td>"device"</td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the device that holds the
directory of the new device's mount point.</td></tr><tr><td>"directory"</td><td><code class="constant">B_INT64_TYPE</code></td><td>The <span class="type">ino_t</span> (node) number of the directory that
acts as the new device's mount point.</td></tr></tbody></table></div><p>Obviously, there's no node involved, here, so the first argument to the
<a class="link" href="The_Node_Monitor.html#watch_node" title="watch_node()"><code class="function">watch_node()</code></a>
call can be <code class="constant">NULL</code>:</p><pre class="programlisting example cpp"><code class="function">watch_node</code>(<code class="constant">NULL</code>, <code class="constant">B_WATCH_MOUNT</code>, <code class="varname">be_app_messenger</code>);</pre><p>Unlike with the other "watch flags," the only way to stop the
mount-watching is to call
<a class="link" href="The_Node_Monitor.html#stop_watching" title="stop_watching()"><code class="function">stop_watching()</code></a>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_DEVICE_UNMOUNTED"></a>B_DEVICE_UNMOUNTED</h4></div></div></div><a id="id1260685" class="indexterm"></a><p>A file system device (in other words, a volume) was unmounted.</p><p>You get this if you passed
<a class="link" href="The_Node_Monitor.html#B_WATCH_MOUNT"><code class="constant">B_WATCH_MOUNT</code></a> to
<a class="link" href="The_Node_Monitor.html#watch_node" title="watch_node()"><code class="function">watch_node()</code></a>.
The message's fields are:</p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td>"opcode"</td><td><code class="constant">B_INT32_TYPE</code></td><td><code class="constant">B_DEVICE_UNMOUNTED indicates that a device has been unmounted.</code></td></tr><tr><td>"device"</td><td><code class="constant">B_INT32_TYPE</code></td><td>The <span class="type">dev_t</span> number of the unmounted device.</td></tr></tbody></table></div><p>Be careful with the device number: <span class="type">dev_t</span>s are quickly recycled. You
should only need this number if you're keeping a list of the <span class="type">dev_t</span>s of
all mounted disks and you want to remove the <span class="type">dev_t</span> for this
recently-unmounted volume (keeping in mind that a device mounted message
bearing this <span class="type">dev_t</span> may arrive in the meantime).</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BVolumeRoster.html">BVolumeRoster</a>  Up: <a href="TheStorageKit.html">The Storage Kit</a>  Next: <a href="TheStorageKit_Functions.html">Functions</a> </div><div id="footerB"><div id="footerBL"><a href="BVolumeRoster.html" title="BVolumeRoster"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheStorageKit.html" title="The Storage Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheStorageKit_Functions.html" title="Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
