<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Media Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheMediaKit.html" title="The Media Kit" /><link rel="prev" href="TheMediaKit_MessageConstants.html" title="Message Constants" /><link rel="next" href="TheMidiKit.html" title="The Midi Kit" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="TheMediaKit_MessageConstants.html" title="Message Constants"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheMidiKit.html" title="The Midi Kit"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Media Kit</div></div><div id="headerB">Prev: <a href="TheMediaKit_MessageConstants.html">Message Constants</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="TheMidiKit.html">The Midi Kit</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheMediaKit_DefinedTypes"></a>Defined Types</h2></div></div></div><p>This section describes the defined types that make the
Media Kit tick.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="encode_parameters"></a>encode_parameters</h3></div></div></div><a id="id1187294" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct encode_parameters</span> {
    <span class="type">float</span>  <code class="varname">quality</code>;
    <span class="type">int32</span>  <code class="varname">avg_field_size</code>;
    <span class="type">int32</span>  <code class="varname">max_field_size</code>;
    <span class="type">int32</span>  <code class="varname">_pad</code>[27];
    <span class="type">void*</span>  <code class="varname">user_data</code>;
    <span class="type">size_t</span> <code class="varname">user_data_size</code>;
};</pre><p>Parameters for encoding a buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">quality</code></span></p></td><td><p>Indicates the compression quality to use. 0.0 is lowest
quality, 1.0 is high quality. You can use the
<a class="link" href="TheMediaKit_Constants.html#B_MEDIA_ANY_QUALITY"><code class="constant">B_MEDIA_ANY_QUALITY</code></a>,
<a class="link" href="TheMediaKit_Constants.html#B_MEDIA_LOW_QUALITY"><code class="constant">B_MEDIA_LOW_QUALITY</code></a>,
and so forth constants if you wish.</p></td></tr><tr><td><p><span class="term"><code class="varname">avg_field_size</code></span></p></td><td><p>Indicates the average size of a field that should be
allowed, in bytes. The encoder will try to maintain this average as it
compresses.</p></td></tr><tr><td><p><span class="term"><code class="varname">max_field_size</code></span></p></td><td><p>Indicates the maximum field size that should be
allowed, in bytes. The encoder will try to encode each field to be
smaller than this size.</p></td></tr><tr><td><p><span class="term"><code class="varname">user_data</code> and <code class="varname">user_data_size</code></span></p></td><td><p>Indicate user-defined data.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="live_node_info"></a>live_node_info</h3></div></div></div><a id="id1187476" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct live_node_info</span> {
    <code class="methodname">live_node_info</code>();
    <code class="methodname">~live_node_info</code>();
    <span class="type">media_node</span> <code class="varname">node</code>;
    <code class="classname">BPoint</code> <code class="varname">hint_point</code>;
    <span class="type">char</span> <code class="varname">name</code>[<code class="constant">B_MEDIA_NAME_LENGTH</code>];
  private:
    <code class="varname">reserved</code>[160];
};</pre><p>The <span class="type">live_node_info</span> structure describes
an active node, and is returned by
<a class="link" href="BMediaRoster.html#BMediaRoster_GetLiveNodes" title="GetLiveNodes()"><code class="methodname">BMediaRoster::GetLiveNodes()</code></a>.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">node</code></span></p></td><td><p>Specifies which node the <span class="type">live_node_info</span> structure describes.</p></td></tr><tr><td><p><span class="term"><code class="varname">hint_point</code></span></p></td><td><p>Is reserved for future use. Pass a
<a class="link" href="BPoint.html" title="BPoint"><code class="classname">BPoint</code></a>
with x and y both set to 0.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_addon_id"></a>media_addon_id</h3></div></div></div><a id="id1187618" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp">typedef <span class="type">int32</span> <span class="type">media_addon_id</span>;</pre><p>A media add-on ID number.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_audio_header"></a>media_audio_header</h3></div></div></div><a id="id1187665" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_audio_header</span> {
    <span class="type">int32</span> <code class="varname">_reserved_</code>[16];
};</pre><p>Defines the header of an audio buffer. There are no Be-defined fields in
this structure as of the release of BeOS R4; however, you may append
fields to the end of this structure if you wish.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_buffer_id"></a>media_buffer_id</h3></div></div></div><a id="id1187717" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp">typedef <span class="type">int32</span> <span class="type">media_buffer_id</span>;</pre><p>A media buffer ID number.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_decode_info"></a>media_decode_info</h3></div></div></div><a id="id1187764" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_decode_info</span> {
    <span class="type">bigtime_t</span> <code class="varname">time_to_decode</code>;
    <span class="type">int32</span>  <code class="varname">_pad</code>[26];
    <span class="type">void*</span>  <code class="varname">file_format_data</code>;
    <span class="type">size_t</span> <code class="varname">file_format_data_size</code>;
    <span class="type">void*</span>  <code class="varname">codec_data</code>;
    <span class="type">size_t</span> <code class="varname">codec_data_size</code>;

    <code class="methodname">media_decode_info</code>();
};</pre><p>Provides options to decoders.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">time_to_decode</code></span></p></td><td><p>Indicates how long, in microseconds, the decoder is
allowed to take to decode the buffer. Specify 0 to do it as fast as
possible, or <code class="constant">B_INFINITE_TIMEOUT</code> if you don't care.</p></td></tr><tr><td><p><span class="term"><code class="varname">file_format_data</code> and <code class="varname">file_format_data_size</code></span></p></td><td><p>These are a pointer to file-format specific data, and
the size of the buffer respectively.</p></td></tr><tr><td><p><span class="term"><code class="varname">codec_data</code> and <code class="varname">codec_data_size</code></span></p></td><td><p>These are a pointer to a codec-specific data buffer, and
the size of the buffer respectively.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_destination"></a>media_destination</h3></div></div></div><a id="id1187927" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_destination</span> {
    <code class="methodname">media_destination</code>(<span class="type">port_id</span>, <span class="type">int32</span>);
    <code class="methodname">media_destination</code>(<span class="type">const media_destination&amp;</span> <code class="parameter">clone</code>);
    <span class="type">media_destination&amp;</span> <code class="methodname">operator=</code> (<span class="type">const media_destination&amp;</span> <code class="parameter">clone</code>);
    <code class="methodname">media_destination</code>();
    <code class="methodname">~media_destination</code>();
    <span class="type">port_id</span> <code class="varname">port</code>;
    <span class="type">int32</span> <code class="varname">id</code>;
    <span class="type">static media_destination</span> <code class="varname">null</code>;
private:
    <span class="type">uint32</span> <code class="varname">_reserved_media_destination_</code>[2];
};</pre><p>Describes the destination end of a media connection between two nodes.
The <code class="varname">port</code> indicates the port ID on which the destination communicates.
This can be different from the <code class="varname">media_node</code>.<code class="varname">port</code>
value.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_encode_info"></a>media_encode_info</h3></div></div></div><a id="id1188060" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_encode_info</span> {
    <span class="type">uint32</span> <code class="varname">flags</code>;
    <span class="type">int32</span> <code class="varname">used_data_size</code>;
    <span class="type">bigtime_t</span> <code class="varname">start_time</code>;
    <span class="type">bigtime_t</span> <code class="varname">time_to_encode</code>;
    <span class="type">int32</span> <code class="varname">_pad</code>[22];
    <span class="type">void*</span> <code class="varname">file_format_data</code>;
    <span class="type">size_t</span> <code class="varname">file_format_data_size</code>;
    <span class="type">void*</span> <code class="varname">codec_data</code>;
    <span class="type">size_t</span> <code class="varname">codec_data_size</code>;

    <code class="methodname">media_encode_info</code>();
};</pre><p>Provides options to encoders and file writers about.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>Contains flags that alter the behavior of the encoder or
writer. The only defined value right now is <code class="constant">B_MEDIA_KEY_FRAME</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">used_data_size</code></span></p></td><td><p>Is currently reserved for use by Be.</p></td></tr><tr><td><p><span class="term"><code class="varname">start_time</code></span></p></td><td><p>Indicates the time at which the buffer being written is
located, in microseconds, from the start of the file.</p></td></tr><tr><td><p><span class="term"><code class="varname">time_to_decode</code></span></p></td><td><p>Indicates how long, in microseconds, the encoder is
allowed to take to encode the buffer. Specify 0 to do it as fast as
possible, or <code class="constant">B_INFINITE_TIMEOUT</code> if you don't care.</p></td></tr><tr><td><p><span class="term"><code class="varname">file_format_data</code> and <code class="varname">file_format_data_size</code></span></p></td><td><p>These are a pointer to file-format specific data, and
the size of the buffer respectively.</p></td></tr><tr><td><p><span class="term"><code class="varname">codec_data</code> and <code class="varname">codec_data_size</code></span></p></td><td><p>These are a pointer to a codec-specific data buffer, and
the size of the buffer respectively.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_encoded_audio_format"></a>media_encoded_audio_format</h3></div></div></div><a id="id1188573" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_encoded_audio_format</span> {
    enum <span class="type">audio_encoding</span> {
       <code class="constant">B_ANY</code>
    };
    <span class="type">media_raw_audio_format</span> <code class="varname">output</code>;
    <span class="type">audio_encoding</span> <code class="varname">encoding</code>;
    <span class="type">float</span> <code class="varname">bit_rate</code>;
    <span class="type">size_t</span> <code class="varname">frame_size</code>;
    <span class="type">media_multi_audio_info</span> <code class="varname">multi_info</code>;
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[3];
    <span class="type">static media_encoded_audio_format</span> <code class="varname">wildcard</code>;
};</pre><p>Describes the format of encoded audio data.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">output</code></span></p></td><td><p>Indicates the raw audio format that results from decoding the
encoded audio.</p></td></tr><tr><td><p><span class="term"><code class="varname">encoding</code></span></p></td><td><p>Specifies the encoding format. This should just be <code class="constant">B_ANY</code>;
this field, and the <span class="type">audio_encoding</span> enum, are depreciated. Instead, the
<a class="link" href="BMediaFormats.html" title="BMediaFormats"><code class="classname">BMediaFormats</code></a>
database should be used to identify the encoding format.</p></td></tr><tr><td><p><span class="term"><code class="varname">bit_rate</code></span></p></td><td><p>Specifies the bit rate (not byte rate) of the data stream.</p></td></tr><tr><td><p><span class="term"><code class="varname">frame_size</code></span></p></td><td><p>Indicates the size of each frame of audio, in bytes.</p></td></tr><tr><td><p><span class="term"><code class="varname">multi_info</code></span></p></td><td><p>Provides multi-channel information.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_encoded_audio_header"></a>media_encoded_audio_header</h3></div></div></div><a id="id1188783" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_encoded_audio_header</span> {
    <span class="type">int32</span> <code class="varname">_reserved_0</code>[14];
    <span class="type">uint32</span> <code class="varname">buffer_flags</code>;
    <span class="type">uchar</span> <code class="varname">unused_mask</code>;
    <span class="type">uchar</span> <code class="varname">_reserved_2</code>[3];
};</pre><p>Defines the header of a an encoded audio buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">buffer_flags</code></span></p></td><td><p>Contains flags that provide additional information about
the buffer. The only value currently defined (other than 0) is
<code class="constant">B_MEDIA_KEY_FRAME</code>, which indicates that the buffer is a key frame.</p></td></tr><tr><td><p><span class="term"><code class="varname">unused_mask</code></span></p></td><td><p>Indicates which bits of the last byte in the buffer are
unused (since encoded audio may result in a number of bits that doesn't
fill up the last byte in the buffer).</p></td></tr></tbody></table><p>If you wish, you can add more fields to the end of the header.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_encoded_video_format"></a>media_encoded_video_format</h3></div></div></div><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_encoded_video_format</span> {
    enum <span class="type">video_encoding</span> {
       <code class="constant">B_ANY</code>
    };
    <span class="type">media_raw_video_format</span> <code class="varname">output</code>;
    <span class="type">float</span> <code class="varname">avg_bit_rate</code>;
    <span class="type">float</span> <code class="varname">max_bit_rate</code>;
    <span class="type">video_encoding</span> <code class="varname">encoding</code>;
    <span class="type">size_t</span> <code class="varname">frame_size</code>;
    <span class="type">int16</span> <code class="varname">forward_history</code>;
    <span class="type">int16</span> <code class="varname">backward_history</code>;
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[3];
    <span class="type">static media_encoded_video_format</span> <code class="varname">wildcard</code>;
};</pre><p>Describes the format of encoded video data.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">output</code></span></p></td><td><p>Specifies the raw video format that results from decoding the
video. Set this to
<span class="code"><span class="type">media_raw_video_format</span>::<code class="varname">wildcard</code></span>.</p></td></tr><tr><td><p><span class="term"><code class="varname">avg_bit_rate</code></span></p></td><td><p>Indicates the average bit rate of the video.</p></td></tr><tr><td><p><span class="term"><code class="varname">max_bit_rate</code></span></p></td><td><p>Specifies the maximum bit rate that occurs at any point in
the video.</p></td></tr><tr><td><p><span class="term"><code class="varname">encoding</code></span></p></td><td><p>Has been depreciated, and should always be B_ANY; use the
<a class="link" href="BMediaFormats.html" title="BMediaFormats"><code class="classname">BMediaFormats</code></a>
lookup database to identify the encoding format.</p></td></tr><tr><td><p><span class="term"><code class="varname">frame_size</code></span></p></td><td><p>Indicates the size in bytes of a frame of data.</p></td></tr><tr><td><p><span class="term"><code class="varname">forward_history</code></span></p></td><td><p>Indicates the maximum number of future frames the
encoding algorithm requires in order to decode the current frame.</p></td></tr><tr><td><p><span class="term"><code class="varname">backward_history</code></span></p></td><td><p>Indicates the maximum number of past frames the
encoding algorithm requires in order to decode the current frame.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_encoded_video_header"></a>media_encoded_video_header</h3></div></div></div><a id="id1189164" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_encoded_video_header</span> {
    <span class="type">int32</span> <code class="varname">_reserved_1</code>[9];
    <span class="type">uint32</span> <code class="varname">field_flags</code>;
    <span class="type">int16</span> <code class="varname">forward_history</code>;
    <span class="type">int16</span> <code class="varname">backward_history</code>;
    <span class="type">uchar</span> <code class="varname">unsued_mask</code>;
    <span class="type">uchar</span> <code class="varname">_rserved_2</code>[3];
    <span class="type">float</span> <code class="varname">field_gamma</code>;
    <span class="type">uint32</span> <code class="varname">field_sequence</code>;
    <span class="type">uint16</span> <code class="varname">field_number</code>;
    <span class="type">uint16</span> <code class="varname">pulldown_number</code>;
    <span class="type">uint16</span> <code class="varname">first_active_line</code>;
    <span class="type">uint16</span> <code class="varname">line_count</code>;
};</pre><p>Defines the header of a video buffer. The fields in this buffer are the
same as those in the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_video_header" title="media_video_header"><span class="type">media_video_header</span></a>
structure, except for the reserved fields, the
<code class="varname">forward_history</code> and <code class="varname">backward_history</code> fields, the
<code class="varname">unused_mask</code>, which indicates which bits are unused in the last byte of
the video buffer, and <code class="varname">field_flags</code>, which can be either 0 or
<code class="constant">B_MEDIA_KEY_FRAME</code> (which indicates that the field is a key frame).</p><p>The <code class="varname">forward_history</code> field indicates how many buffers ahead of the current
one are required in order to decode the current buffer. The
<code class="varname">backward_history</code> field indicates the number of previous buffers are
required to decode the current buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">field_gamma</code></span></p></td><td><p>Specifies the gamma at which the video was captured.</p></td></tr><tr><td><p><span class="term"><code class="varname">field_sequence</code></span></p></td><td><p>Is an identifying number assigned to the field when it
was captured. They progress in sequence; you can tell if a field was
dropped by looking for skips in the sequence. Note that this value
doesn't necessarily start at 0, and it can wrap back around to 0.</p></td></tr><tr><td><p><span class="term"><code class="varname">field_number</code></span></p></td><td><p>Indicates which field of a video frame the buffer
represents. It's 0 for field 1, 1 for field 2, and so forth.</p></td></tr><tr><td><p><span class="term"><code class="varname">pulldown_number</code></span></p></td><td><p>Indicates that the field represented by the buffer is
a duplicate of a field <code class="varname">pulldown_number</code> fields back. If this value is 0,
it's not a duplicate field. This is used in cases when the video has
been converted from one field rate to another, resulting in duplication
of fields; these duplicated fields can be marked using pulldown numbers
so video hardware and software can optimize their performance by
knowing that duplicate fields exist.</p></td></tr><tr><td><p><span class="term"><code class="varname">first_active_line</code></span></p></td><td><p>Indicates the topmost line that actually contains
video data (instead of <acronym class="acronym">VBL</acronym> data); this is an
<acronym class="acronym">NTSC</acronym> or <acronym class="acronym">PAL</acronym> line number,
which is 1-based.</p></td></tr><tr><td><p><span class="term"><code class="varname">line_count</code></span></p></td><td><p>Indicates the number of active video lines
in the field.</p></td></tr></tbody></table><p>You may add fields to the end of this buffer if your video format
requires them.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_file_format"></a>media_file_format</h3></div></div></div><a id="id1189481" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_file_format</span> {
    enum {
       <code class="constant">B_READABLE</code> = 0x1,
       <code class="constant">B_WRITABLE</code> = 0x2,
       <code class="constant">B_PERFECTLY_SEEKABLE</code> = 0x4,
       <code class="constant">B_IMPERFECTLY_SEEKABLE</code> = 0x8,
       <code class="constant">B_KNOWS_RAW_VIDEO</code> = 0x10,
       <code class="constant">B_KNOWS_RAW_AUDIO</code> = 0x20,
       <code class="constant">B_KNOWS_MIDI</code> = 0x40,
       <code class="constant">B_KNOWS_ENCODED_VIDEO</code> = 0x80,
       <code class="constant">B_KNOWS_ENCODED_AUDIO</code> = 0x100,
       <code class="constant">B_KNOWS_OTHER</code> = 0x1000000,
       <code class="constant">B_KNOWS_ANYTHING</code> = 0x2000000
    };
    <span class="type">uint32</span> capabilities;
    <span class="type">media_file_format_id</span> id;
    <span class="type">media_format_family</span> family;
    <span class="type">int32</span> version;

    <span class="type">uint32</span> _reserved_[25];
    <span class="type">char</span> mime_type[64];
    <span class="type">char</span> pretty_name[64];
    <span class="type">char</span> short_name[32];
    <span class="type">char</span> file_extension[8];
    <span class="type">char</span> reserved[88];
};</pre><p>Describes a media file format.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">capabilities</code></span></p></td><td><p>Is a bitfield providing informational flags describing
the file format's capabilities.</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_READABLE</code></span></dt><dd><p>Indicates that the file format is readable.</p></dd><dt><span class="term"><code class="constant">B_WRITABLE</code></span></dt><dd><p>Indicates that the format can be written.</p></dd><dt><span class="term"><code class="constant">B_PERFECTLY_SEEKABLE</code></span></dt><dd><p>Indicates that seek operations are precise.</p></dd><dt><span class="term"><code class="constant">B_IMPERFECTLY_SEEKABLE</code></span></dt><dd><p>Indicates that seek operations may not be totally accurate.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_RAW_VIDEO</code></span></dt><dd><p>Indicates that the file format can handle video.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_RAW_AUDIO</code></span></dt><dd><p>Indicates that the format can handle audio.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_MIDI</code></span></dt><dd><p>Indicates that the format can handle MIDI data.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_ENCODED_VIDEO</code></span></dt><dd><p>Indicates that the file format can handle encoded video.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_ENCODED_AUDIO</code></span></dt><dd><p>Indicates that the file format can handle encoded audio.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_OTHER</code></span></dt><dd><p>Indicates that the format can handle other media
information, such as text, clipping, control changes, and so forth.</p></dd><dt><span class="term"><code class="constant">B_KNOWS_ANYTHING</code></span></dt><dd><p>Indicates that the format can handle any kind of media data.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="varname">id</code></span></p></td><td><p>Is an opaque ID used by the Media Kit to construct a
<a class="link" href="BMediaFile.html" title="BMediaFile"><code class="classname">BMediaFile</code></a>
object.</p></td></tr><tr><td><p><span class="term"><code class="varname">family</code></span></p></td><td><p>Is one of the
<a class="link" href="TheMediaKit_Constants.html#Constants_media_format_family" title="media_format_family"><span class="type">media_format_family</span></a>
constants.</p></td></tr><tr><td><p><span class="term"><code class="varname">version</code></span></p></td><td><p>Should be 100.</p></td></tr><tr><td><p><span class="term"><code class="varname">mime_type</code></span></p></td><td><p>Specifies the <acronym class="acronym">MIME</acronym> type string that identifies the file
format.</p></td></tr><tr><td><p><span class="term"><code class="varname">pretty_name</code></span></p></td><td><p>Is a nice user-viewable name, such as "QuickTime File
Format".</p></td></tr><tr><td><p><span class="term"><code class="varname">short_name</code></span></p></td><td><p>Is a short-form name, like "QuickTime".</p></td></tr><tr><td><p><span class="term"><code class="varname">file_extension</code></span></p></td><td><p>Specifies the file extension used on files containing
this format, such as ".mov".</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_file_format_id"></a>media_file_format_id</h3></div></div></div><a id="id1189961" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_file_format_id</span> {
    <span class="type">ino_t</span> <code class="varname">node</code>;
    <span class="type">dev_t</span> <code class="varname">device</code>;
    <span class="type">uint32</span> <code class="varname">internal_id</code>;
};</pre><p>A simple means for identifying file formats; used by the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_file_format" title="media_file_format"><span class="type">media_file_format</span></a>
structure.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_format"></a>media_format</h3></div></div></div><a id="id1190033" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_format</span> {
    <span class="type">media_type</span> <code class="varname">type</code>;
    <span class="type">type_code</span> <code class="varname">user_data_type</code>;
    <span class="type">uchar</span> <code class="varname">user_data</code>[48];
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[3];
    <span class="type">uint16</span> <code class="varname">require_flags</code>;
    <span class="type">uint16</span> <code class="varname">deny_flags</code>;

private:
    <span class="type">void*</span> <code class="varname">meta_data</code>;
    <span class="type">int32</span> <code class="varname">meta_data_size</code>;
    <span class="type">area_id</span> <code class="varname">meta_data_area</code>;
    <span class="type">area_id</span> <code class="varname">use_area</code>;
    <span class="type">team_id</span> <code class="varname">team</code>;
    <span class="type">void*</span> <code class="varname">thisPtr</code>;

public:
    union {
       <span class="type">media_multi_audio_format</span> <code class="varname">raw_audio</code>;
       <span class="type">media_raw_video_format</span> <code class="varname">raw_video</code>;
       <span class="type">media_multistream_format</span> <code class="varname">multistream</code>;
       <span class="type">media_encoded_audio_format</span> <code class="varname">encoded_audio</code>;
       <span class="type">media_encoded_video_format</span> <code class="varname">encoded_video</code>;
       <span class="type">char</span> <code class="varname">_reserved_</code>[96];
    } u;
    <span class="type">bool</span> <code class="methodname">IsVideo</code>() const ;
    <span class="type">uint32</span> <code class="methodname">Width</code>() const;
    <span class="type">uint32</span> <code class="methodname">Height</code>() const;
    <span class="type">color_space</span> <code class="methodname">ColorSpace</code>() const;
    <span class="type">uint32&amp;</span> <code class="methodname">Width</code>();
    <span class="type">uint32&amp;</span> <code class="methodname">Height</code>();
    <span class="type">color_space&amp;</span> <code class="methodname">ColorSpace</code>();

    <span class="type">bool</span> <code class="methodname">IsAudio</code>() const;
    <span class="type">uint32&amp;</span> <code class="methodname">AudioFormat</code>();
    <span class="type">uint32</span> <code class="methodname">AudioFormat</code>() const;
    <span class="type">uint32</span> <code class="methodname">Encoding</code>() const;
    <span class="type">bool</span> <code class="methodname">Matches</code>(<span class="type">const media_format*</span> <code class="parameter">otherFormat</code>) const;
    <span class="type">void</span> <code class="methodname">SpecializeTo</code>(<span class="type">const media_format*</span> <code class="parameter">otherFormat</code>);
    <span class="type">void</span> <code class="methodname">SetMetaData</code>(<span class="type">const void*</span> <code class="parameter">data</code>, <span class="type">int32</span> <code class="parameter">size</code>);
    <span class="type">const void*</span> <code class="methodname">MetaData</code>() const;
    <span class="type">int32</span> <code class="methodname">MetaDataSize</code>() const;

    <code class="methodname">media_format</code>();
    <code class="methodname">media_format</code>(<span class="type">const media_format&amp;</span> <code class="parameter">other</code>);
    <code class="methodname">~media_format</code>();
    <span class="type">media_format&amp;</span> <code class="methodname">operator=</code>(<span class="type">const media_format&amp;</span> <code class="parameter">clone</code>);
};</pre><p>The <span class="type">media_format</span> structure can describe any media data format the BeOS
can support.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">type</code></span></p></td><td><p>Indicates the type of media the format describes.</p></td></tr><tr><td><p><span class="term"><code class="varname">user_data</code></span></p></td><td><p>Allows the application to store custom
data in the <span class="type">media_format</span> structure</p></td></tr><tr><td><p><span class="term"><code class="varname">user_data_type</code></span></p></td><td><p>specifies the type of data stored in <code class="varname">user_data</code>
(<code class="constant">B_INT32_TYPE</code>, <code class="constant">B_STRING_TYPE</code>, etc).</p></td></tr><tr><td><p><span class="term"><code class="varname">require_flags</code> and <code class="varname">deny_flags</code></span></p></td><td><p>Are
<a class="link" href="TheMediaKit_Constants.html#Constants_media_format_flags" title="media_format_flags"><span class="type">media_format_flags</span></a>
indicating what options are required, and what options are rejected.</p></td></tr><tr><td><p><span class="term"><code class="varname">meta_data</code>, <code class="varname">meta_data_size</code>,
<code class="varname">meta_data_area</code>, <code class="varname">use_area</code>,
<code class="varname">team</code>, <code class="varname">thisPtr</code></span></p></td><td><p>Are currently only used by decoders when communicating with the
file reader; they're not currently for public use.</p></td></tr></tbody></table><p>The union, <code class="varname">u</code>, permits the selection of a specific media format, such
as raw audio or multistream data, and contains the descriptive
information specific to that media format.</p><p>If any field is 0, it's treated as a wildcard.</p><p>There are several convenience functions for fetching information from the
format that take care of dealing with different types automatically:</p><table class="variablelist functions"><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="methodname">IsVideo()</code></span></p></td><td><p>Returns <code class="constant">true</code> if the format represents video (either raw or
encoded), otherwise it returns <code class="constant">false</code>.</p></td></tr><tr><td><p><span class="term"><code class="methodname">Width()</code></span></p></td><td><p>Returns the width of the video data; its value is
undetermined if the format doesn't represent video.</p></td></tr><tr><td><p><span class="term"><code class="methodname">Height()</code></span></p></td><td><p>Returns the height of the video data; its value is
undetermined if the format doesn't represent video.</p></td></tr><tr><td><p><span class="term"><code class="methodname">ColorSpace()</code></span></p></td><td><p>Returns the video's color space. Its value is
undetermined if the format doesn't represent video.</p></td></tr><tr><td><p><span class="term"><code class="methodname">IsAudio()</code></span></p></td><td><p>Returns <code class="constant">true</code> if the format represents audio (either raw or
encoded), otherwise it returns <code class="constant">false</code>.</p></td></tr><tr><td><p><span class="term"><code class="methodname">AudioFormat()</code></span></p></td><td><p>Returns the audio's sample format.</p></td></tr><tr><td><p><span class="term"><code class="methodname">Matches()</code></span></p></td><td><p>Returns <code class="constant">true</code> if the format matches the specified
otherFormat, otherwise it returns <code class="constant">false</code>.</p></td></tr><tr><td><p><span class="term"><code class="methodname">SpecializeTo()</code></span></p></td><td><p>Adjusts the specified otherFormat as needed to match
the format.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_header"></a>media_header</h3></div></div></div><a id="id1190722" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_header</span> {
    <span class="type">media_type</span> <code class="varname">type</code>;
    <span class="type">media_buffer_id</span> <code class="varname">buffer</code>;
    <span class="type">int32</span> <code class="varname">destination</code>;
    <span class="type">media_node_id</span> <code class="varname">time_source</code>;
    <span class="type">uint32</span> <code class="varname">_depreciated_</code>;
    <span class="type">uint32</span> <code class="varname">size_used</code>;
    <span class="type">bigtime_t</span> <code class="varname">start_time</code>;
    <span class="type">area_id</span> <code class="varname">owner</code>;
    enum {
       <code class="constant">B_SEEK_TAG</code> = 'TRST'
    };
    <span class="type">type_code</span> <code class="varname">user_data_type</code>;
    <span class="type">uchar</span> <code class="varname">user_data</code>[64];
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[2];
    <span class="type">off_t</span> <code class="varname">file_pos</code>;
    <span class="type">size_t</span> <code class="varname">orig_size</code>;
    <span class="type">uint32</span> <code class="varname">data_offset</code>;
    union {
       <span class="type">media_audio_header</span> <code class="varname">raw_audio</code>;
       <span class="type">media_video_header</span> <code class="varname">raw_video</code>;
       <span class="type">media_multistream_header</span> <code class="varname">multistream</code>;
       <span class="type">media_encoded_audio_header</span> <code class="varname">encoded_audio</code>;
       <span class="type">media_encoded_video_header</span> <code class="varname">encoded_video</code>;
       <span class="type">char</span> <code class="varname">_reserved_</code>[64];
    } <code class="varname">u</code>;
};</pre><p>Defines the header of a media data buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">type</code></span></p></td><td><p>Indicates the type of media the format describes.</p></td></tr><tr><td><p><span class="term"><code class="varname">buffer</code></span></p></td><td><p>Indicates what buffer the header goes with. This field is
filled out by the
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">BBufferProducer::SendBuffer()</code></a>
function.</p></td></tr><tr><td><p><span class="term"><code class="varname">destination</code></span></p></td><td><p>Specifies the ID number of the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_destination" title="media_destination"><span class="type">media_destination</span></a>
to which the buffer is being sent. This field is filled out by the
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">BBufferProducer::SendBuffer()</code></a>
function.</p></td></tr><tr><td><p><span class="term"><code class="varname">time_source</code></span></p></td><td><p>Indicates the ID number of the node that encoded the
<code class="varname">start_time</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">size_used</code></span></p></td><td><p>Specifies how many bytes of the buffer actually contain
data.</p></td></tr><tr><td><p><span class="term"><code class="varname">start_time</code></span></p></td><td><p>Indicates the performance time at which the buffer should
be performed.</p></td></tr><tr><td><p><span class="term"><code class="varname">owner</code></span></p></td><td><p>Specifies the area ID of the buffer's owner.</p></td></tr><tr><td><p><span class="term"><code class="varname">user_data_type</code> and <code class="varname">user_data</code></span></p></td><td><p>Allow the application to store custom data in the
<span class="type">media_format</span> structure;
<code class="varname">user_data_type</code> specifies the type of data stored in
<code class="varname">user_data</code> (<code class="constant">B_INT32_TYPE</code>,
<code class="constant">B_STRING_TYPE</code>, etc). The
<code class="constant">B_SEEK_TAG</code> constant indicates that the
<code class="varname">user_data</code> contains a seek tag. </p></td></tr><tr><td><p><span class="term"><code class="varname">file_pos</code> and <code class="varname">orig_size</code></span></p></td><td><p><code class="varname">file_pos</code> indicates where in the corresponding file the data came
from, and <code class="varname">orig_size</code> indicates how big it was; if the data didn't come
from a file, these should be zero.
</p></td></tr><tr><td><p><span class="term"><code class="varname">data_offset</code></span></p></td><td><p>Indicates the offset within the buffer to the data. This
is reflected by the
<a class="link" href="BBuffer.html#BBuffer_Data" title="Data()"><code class="methodname">BBuffer::Data()</code></a>
function.</p></td></tr></tbody></table><p>The union, <code class="varname">u</code>, permits the selection of a specific media format, such
as raw audio or multistream data, and contains the descriptive
information specific to that media format.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_input"></a>media_input</h3></div></div></div><a id="id1191184" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_input</span> {
    <code class="methodname">media_input</code>();
    <code class="methodname">~media_input</code>();
    <span class="type">media_node</span> <code class="varname">node</code>;
    <span class="type">media_source</span> <code class="varname">source</code>;
    <span class="type">media_destination</span> <code class="varname">destination</code>;
    <span class="type">media_format</span> <code class="varname">format</code>;
    <span class="type">char</span> <code class="varname">name</code>[<code class="constant">B_MEDIA_NAME_LENGTH</code>];
private:
    <span class="type">char</span> <code class="varname">_reserved_media_input_</code>[4];
};</pre><p>The <span class="type">media_input</span> structure describes a complete connection between a
<a class="link" href="TheMediaKit_DefinedTypes.html#media_source" title="media_source"><span class="type">media_source</span></a> and
<a class="link" href="TheMediaKit_DefinedTypes.html#media_destination" title="media_destination"><span class="type">media_destination</span></a>,
from the point-of-view of the consumer (the destination).</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">node</code></span></p></td><td><p>Is the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_node" title="media_node"><span class="type">media_node</span></a>
that owns the input.</p></td></tr><tr><td><p><span class="term"><code class="varname">source</code></span></p></td><td><p>Is the source socket from which the data is being sent.</p></td></tr><tr><td><p><span class="term"><code class="varname">destination</code></span></p></td><td><p>Is the destination socket at which the data is arriving.</p></td></tr><tr><td><p><span class="term"><code class="varname">format</code></span></p></td><td><p>Is the format of the data.</p></td></tr><tr><td><p><span class="term"><code class="varname">name</code></span></p></td><td><p>Is the input's name.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_multistream_format"></a>media_multistream_format</h3></div></div></div><a id="id1191398" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_multistream_format</span> {
    enum {
        <code class="constant">B_ANY</code> = 0,
        <code class="constant">B_VID</code> = 1,
        <code class="constant">B_AVI</code>,
        <code class="constant">B_MPEG1</code>,
        <code class="constant">B_MPEG2</code>,
        <code class="constant">B_QUICKTIME</code>,
        <code class="constant">B_PRIVATE</code> = 90000,
        <code class="constant">B_FIRST_USER_TYPE</code> = 100000
    };
    <span class="type">float</span> <code class="varname">avg_bit_rate</code>;
    <span class="type">float</span> <code class="varname">max_bit_rate</code>;
    <span class="type">uint32</span> <code class="varname">avg_chunk_size</code>;
    <span class="type">uint32</span> <code class="varname">max_chunk_size</code>;
    enum {
        <code class="constant">B_HEADER_HAS_FLAGS</code> = 0x1,
        <code class="constant">B_CLEAN_BUFFERS</code> = 0x2,
        <code class="constant">B_HOMOGENOUS_BUFFERS</code> = 0x4
    };
    <span class="type">uint32</span> <code class="varname">flags</code>;
    <span class="type">int32</span> <code class="varname">format</code>;
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[2];
    <span class="type">struct vid_info</span> {
        <span class="type">float</span> <code class="varname">frame_rate</code>;
        <span class="type">uint16</span> <code class="varname">width</code>;
        <span class="type">uint16</span> <code class="varname">height</code>;
        <span class="type">color_space</span> <code class="varname">space</code>;
        <span class="type">float</span> <code class="varname">sampling_rate</code>;
        <span class="type">uint32</span> <code class="varname">sample_format</code>;
        <span class="type">uint16</span> <code class="varname">byte_order</code>;
        <span class="type">uint16</span> <code class="varname">channel_count</code>;
    };
    <span class="type">struct avi_info</span> {
        <span class="type">uint32</span> <code class="varname">us_per_frame</code>;
        <span class="type">uint16</span> <code class="varname">width</code>;
        <span class="type">uint16</span> <code class="varname">height</code>;
        <span class="type">uint16</span> <code class="varname">_reserved_</code>;
        <span class="type">uint16</span> <code class="varname">type_count</code>;
        <span class="type">media_type</span> <code class="varname">types</code>[5];
    };
    union {
        <span class="type">vid_info</span> <code class="varname">vid</code>;
        <span class="type">avi_info</span> <code class="varname">avi</code>;
    } <code class="varname">u</code>;
    <span class="type">static media_multistream_format</span> <code class="varname">wildcard</code>;
};</pre><p>Describes the format of multistream media data, such as a QuickTime, AVI,
or MPEG movie.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">avg_bit_rate</code> and <code class="varname">max_bit_rate</code></span></p></td><td><p>Indicate the average and maximum bit
rates of the media data.</p></td></tr><tr><td><p><span class="term"><code class="varname">avg_chunk_size</code> and <code class="varname">max_chunk_size</code></span></p></td><td><p>Indicate the average and maximum
buffer sizes; if all buffers are the same size, these two values should
be equal.</p></td></tr><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>Provides informational flags for the buffers.</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_HEADER_HAS_FLAGS</code></span></dt><dd><p>Indicates that the buffers' headers have valid
flags;</p></dd><dt><span class="term"><code class="constant">B_CLEAN_BUFFERS</code></span></dt><dd><p>Indicates that each buffer represents an
integral number of frames</p></dd><dt><span class="term"><code class="constant">B_HOMOGENOUS_BUFFERS</code></span></dt><dd><p>Indicates that each buffer has only one format in it.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="varname">format</code></span></p></td><td><p>Indicates the multistream data format
<code class="constant">B_AVI</code>, <code class="constant">B_QUICKTIME</code>,
etc).</p></td></tr><tr><td><p><span class="term">The union <code class="varname">u</code></span></p></td><td><p>contains either a <span class="type">vid_info</span> or an <span class="type">avi_info</span> structure that
describes the video stream:</p></td></tr></tbody></table><p><span class="type">vid_info</span></p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">frame_rate</code></span></p></td><td><p>Specifies the video frame rate (in frames per second).</p></td></tr><tr><td><p><span class="term"><code class="varname">width</code> and <code class="varname">height</code></span></p></td><td><p>Indicate the width and height of the video, in pixels.</p></td></tr><tr><td><p><span class="term"><code class="varname">space</code></span></p></td><td><p>Indicates the video's color space.</p></td></tr><tr><td><p><span class="term"><code class="varname">sampling_rate</code>, <code class="varname">sample_format</code>,
<code class="varname">byte_order</code>, and <code class="varname">channel_count</code></span></p></td><td><p>Specify the sampling rate, sample format, byte order, and number of channels
(stereo or mono) of the media's audio.</p></td></tr></tbody></table><p><span class="type">avi_info</span></p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">us_per_frame</code></span></p></td><td><p>Specifies the number of microseconds each frame should
be displayed.</p></td></tr><tr><td><p><span class="term"><code class="varname">width</code> and <code class="varname">height</code></span></p></td><td><p>Indicate the width and height of the video in pixels.</p></td></tr><tr><td><p><span class="term"><code class="varname">type_count</code></span></p></td><td><p>Indicates the number of
media_types
used in the AVI movie.</p></td></tr><tr><td><p><span class="term"><code class="varname">types</code></span></p></td><td><p>Is a list of the
media_types
used.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_multi_audio_format"></a>media_multi_audio_format</h3></div></div></div><a id="id1192026" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_multi_audio_format</span> {
    <span class="type">media_raw_audio_format</span> <code class="varname">raw</code>;
    <span class="type">media_multi_audio_info</span> <code class="varname">multi</code>;
};</pre><p>Describes a multi-channel audio format. This is constructed by using a
<span class="type">media_raw_audio_format</span> to describe the physical format of the sound,
followed by a <span class="type">media_multi_audio_info</span> structure that adds the
multi-channel information. This allows compatibility with existing BeOS
software while adding support for multi-channel audio in new software.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_multi_audio_info"></a>media_multi_audio_info</h3></div></div></div><a id="id1192096" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_multi_audio_info</span> {
    <span class="type">uint32</span> <code class="varname">channel_mask</code>;
    <span class="type">int16</span> <code class="varname">valid_bits</code>;
    <span class="type">uint16</span> <code class="varname">matrix_mask</code>;
    <span class="type">uint32</span> <code class="varname">_reserved_b</code>[3];
};</pre><p>Provides information about multi-channel audio support.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">channel_mask</code></span></p></td><td><p>Indicates which channels are supported; for each channel
(<code class="constant">B_CHANNEL_LEFT</code>, etc) the corresponding bit is set in this mask.</p></td></tr><tr><td><p><span class="term"><code class="varname">valid_bits</code></span></p></td><td><p>Indicates how many bits in a 32-bit integer sample
actually contain sample data.</p></td></tr><tr><td><p><span class="term"><code class="varname">matrix_mask</code></span></p></td><td><p>Indicates which multi-channel audio matrices are used.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_multistream_header"></a>media_multistream_header</h3></div></div></div><a id="id1192231" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_multistream_header</span> {
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[14];
    <span class="type">uchar</span> <code class="varname">unused_mask</code>;
    <span class="type">uchar</span> <code class="varname">_reserved_2</code>[3];
    enum {
       <code class="constant">B_MASTER_HEADER</code> = 0x1,
       <code class="constant">B_SUBSTREAM_HEADER</code> = 0x2,
       <code class="constant">B_COMPLETE_BUFFER</code> = 0x4
    };
    <span class="type">uint32</span> <code class="varname">flags</code>;
};</pre><p>Defines the header of a multistream media buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">unused_mask</code></span></p></td><td><p>Indicates which bits of the last byte in the buffer are
unused.</p></td></tr><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>Provides informational flags about the buffer. If
<code class="constant">B_MASTER_HEADER</code> is specified, master stream header data is in the
buffer; <code class="constant">B_SUBSTREAM_HEADER</code> indicates that the buffer contains substream
header information. <code class="constant">B_COMPLETE_BUFFER</code> indicates that the buffer's data
represents an integral number of frames.</p></td></tr></tbody></table><p>You may add fields to the end of this structure if your multistream media
format requires them.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_node"></a>media_node</h3></div></div></div><a id="id1192375" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp">class <code class="classname">media_node</code> {
public:
    <code class="methodname">media_node</code>();
    <code class="methodname">~media_node</code>();
    <span class="type">media_node_id</span> <code class="varname">node</code>;
    <span class="type">port_id</span> <code class="varname">port</code>;
    <span class="type">uint32</span> <code class="varname">kind</code>;
    <span class="type">static media_node</span> <code class="varname">null</code>;
private:
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[3];
};</pre><p>The <code class="classname">media_node</code> structure is the class that defines a node to client
applications; interactions with the
<a class="link" href="BMediaRoster.html" title="BMediaRoster"><code class="classname">BMediaRoster</code></a>
regarding nodes is done using <code class="classname">media_node</code> objects.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">node</code></span></p></td><td><p>Indicates the node's ID number.</p></td></tr><tr><td><p><span class="term"><code class="varname">port</code></span></p></td><td><p>Specifies the port ID number of the node's control port.</p></td></tr><tr><td><p><span class="term"><code class="varname">kind</code></span></p></td><td><p>Specifies the node's media kind. See
<a class="link" href="TheMediaKit_Constants.html#Enums_node_kind" title="node_kind"><span class="type">node_kind</span></a>
for a list of node kinds.</p></td></tr><tr><td><p><span class="term"><code class="varname">null</code></span></p></td><td><p>Represents a null node</p></td></tr></tbody></table><p>Applications will usually treat this as a black box.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_node_attribute"></a>media_node_attribute</h3></div></div></div><a id="id1192562" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_node_attribute</span> {
    enum {
       <code class="constant">B_R40_COMPILED</code> = 1,
       <code class="constant">B_USER_ATTRIBUTE_NAME</code> = 0x1000000,
       <code class="constant">B_FIRST_USER_ATTRIBUTE</code>
    };
    <span class="type">uint32</span> <code class="varname">what</code>;
    <span class="type">uint32</span> <code class="varname">flags</code>;
    <span class="type">uint64</span> <code class="varname">data</code>;
};</pre><p>The <span class="type">media_node_attribute</span> structure provides additional information about
nodes. Nodes can have as many of these as they want, and will return them
from their
<a class="link" href="BMediaNode.html#BMediaNode_GetNodeAttributes" title="GetNodeAttributes()"><code class="methodname">BMediaNode::GetNodeAttributes()</code></a>
function. Applications query the node using the
<a class="link" href="BMediaRoster.html#BMediaRoster_GetNodeAttributesFor" title="GetNodeAttributesFor()"><code class="methodname">BMediaRoster::GetNodeAttributesFor()</code></a>
function.</p><p>The <code class="varname">what</code> field indicates the attribute type.
<code class="constant">B_R40_COMPILED</code> indicates
that the node was compiled using BeOS Release 4.0;
<a class="link" href="BMediaNode.html" title="BMediaNode"><code class="classname">BMediaNode</code></a>
returns
this attribute automatically for nodes that were compiled using the
Release 4.0 headers. Nodes may create their own attribute types,
beginning at <code class="constant">B_FIRST_USER_ATTRIBUTE</code>.</p><p>The <code class="constant">B_USER_ATTRIBUTE_NAME</code> attribute
specifies the name of a protocol for the user attributes implemented by the
node. For example, if you devise a third-party standard for attribute
values whose attribute IDs are greater than
<code class="constant">B_FIRST_USER_ATTRIBUTE</code>, the value of
<code class="constant">B_USER_ATTRIBUTE_NAME</code> would be the name of the
standard.</p><p>The <code class="varname">flags</code> and <code class="varname">data</code>
fields are used for different things depending on the
<code class="varname">what</code> value; the <code class="constant">B_R40_COMPILED</code>
attribute doesn't use them.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_node_id"></a>media_node_id</h3></div></div></div><a id="id1192726" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp">typdef <span class="type">int32</span> <span class="type">media_node_id</span>;</pre><p>A node ID number.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_output"></a>media_output</h3></div></div></div><a id="id1192773" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_output</span> {
    <code class="methodname">media_output</code>();
    <code class="methodname">~media_output</code>();
    <span class="type">media_node</span> <code class="varname">node</code>;
    <span class="type">media_source</span> <code class="varname">source</code>;
    <span class="type">media_destination</span> <code class="varname">destination</code>;
    <span class="type">media_format</span> <code class="varname">format</code>;
    <span class="type">char</span> <code class="varname">name</code>[<code class="constant">B_MEDIA_NAME_LENGTH</code>];

private:
    <span class="type">char</span> <code class="varname">_reserved_media_output_</code>[4];
};</pre><p>The <span class="type">media_output</span> structure describes a complete connection between a
<a class="link" href="TheMediaKit_DefinedTypes.html#media_source" title="media_source"><span class="type">media_source</span></a> and
<a class="link" href="TheMediaKit_DefinedTypes.html#media_destination" title="media_destination"><span class="type">media_destination</span></a>,
from the point-of-view of the consumer (the destination).</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">node</code></span></p></td><td><p>Is the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_node" title="media_node"><span class="type">media_node</span></a>
that owns the output.</p></td></tr><tr><td><p><span class="term"><code class="varname">source</code></span></p></td><td><p>Is the source socket from which the data is being sent.</p></td></tr><tr><td><p><span class="term"><code class="varname">destination</code></span></p></td><td><p>Is the destination socket to which the data is being sent.</p></td></tr><tr><td><p><span class="term"><code class="varname">format</code></span></p></td><td><p>Is the format of the data.</p></td></tr><tr><td><p><span class="term"><code class="varname">name</code></span></p></td><td><p>Is the output's name.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_raw_audio_format"></a>media_raw_audio_format</h3></div></div></div><a id="id1192987" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_raw_audio_format</span> {
    enum {
        <code class="constant">B_AUDIO_FLOAT</code> = 0x24,
        <code class="constant">B_AUDIO_INT</code> = 0x4
        <code class="constant">B_AUDIO_SHORT</code> = 0x2,
        <code class="constant">B_AUDIO_UCHAR</code> = 0x11,
        <code class="constant">B_AUDIO_CHAR</code> = 0x1,
        <code class="constant">B_AUDIO_SIZE_MASK</code> = 0xf
    }
    <span class="type">float</span> <code class="varname">frame_rate</code>;
    <span class="type">uint32</span> <code class="varname">channel_count</code>;
    <span class="type">uint32</span> <code class="varname">format</code>;
    <span class="type">uint32</span> <code class="varname">byte_order</code>;
    <span class="type">size_t</span> <code class="varname">buffer_size</code>;

    <span class="type">static media_multi_audio_format</span> <code class="varname">wildcard</code>;
};</pre><p>Describes the format of raw audio data.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">frame_rate</code></span></p></td><td><p>Indicates the frame rate, in Hertz. One frame is one
sample per channel (stereo buffers contain two samples per channel). For
audio, each buffer contains multiple audio samples, whereas video
contains one frame, or one field (half-frame) per buffer.</p></td></tr><tr><td><p><span class="term"><code class="varname">channel_count</code></span></p></td><td><p>Indicates the number of channels of audio (typically
this is either 1 for mono or 2 for stereo).</p></td></tr><tr><td><p><span class="term"><code class="varname">format</code></span></p></td><td><p>Specifies the sample format (for compressed formats, see
<a class="link" href="TheMediaKit_DefinedTypes.html#media_encoded_audio_format" title="media_encoded_audio_format"><span class="type">media_encoded_audio_format</span></a>):</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_AUDIO_FLOAT</code></span></dt><dd><p>Each sample is four bytes; 0 is the middle, -1.0 is
the bottom, 1.0 is the top.</p></dd><dt><span class="term"><code class="constant">B_AUDIO_INT</code></span></dt><dd><p>Each sample is four bytes; 0 is the middle, 0x80000001
is the bottom, 0x7FFFFFFF is the top.</p></dd><dt><span class="term"><code class="constant">B_AUDIO_SHORT</code></span></dt><dd><p>Each sample is two bytes; 0 is the middle, -32767 is
the bottom, 32767 is the top.</p></dd><dt><span class="term"><code class="constant">B_AUDIO_UCHAR</code></span></dt><dd><p>Each sample is one byte; 128 is the midpoint, 1 is the
bottom, 255 is the top.</p></dd><dt><span class="term"><code class="constant">B_AUDIO_CHAR</code></span></dt><dd><p>Each sample is one byte; 0 is the midpoint, -127 is the
bottom, 127 is the top.</p></dd></dl><p>It's guaranteed that
(<code class="varname">format</code> &amp; <code class="constant">B_AUDIO_SIZE_MASK</code>)
will always be equal to the size of the sample.</p></td></tr><tr><td><p><span class="term"><code class="varname">byte_order</code></span></p></td><td><p>Indicates the endianness of the data (either
<code class="constant">B_MEDIA_BIG_ENDIAN</code> or <code class="constant">B_MEDIA_LITTLE_ENDIAN</code>).</p></td></tr><tr><td><p><span class="term"><code class="varname">buffer_size</code></span></p></td><td><p>Indicates the size of each buffer, in bytes.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_raw_video_format"></a>media_raw_video_format</h3></div></div></div><a id="id1193316" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_raw_video_format</span> {
    <span class="type">float</span> <code class="varname">field_rate</code>;
    <span class="type">uint32</span> <code class="varname">interlace</code>;
    <span class="type">uint32</span> <code class="varname">first_active</code>;
    <span class="type">uint32</span> <code class="varname">last_active</code>;
    <span class="type">uint32</span> <code class="varname">orientation</code>;
    <span class="type">uint16</span> <code class="varname">pixel_width_aspect</code>;
    <span class="type">uint16</span> <code class="varname">pixel_height_aspect</code>;
    <span class="type">media_video_display_info</span> <code class="varname">display</code>;

    <span class="type">static media_raw_video_format</span> <code class="varname">wildcard</code>;
};</pre><p>Describes the format of raw video data.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">field_rate</code></span></p></td><td><p>Indicates the field rate. This is 59.94 for <acronym class="acronym">NTSC</acronym> and 50.0
for <acronym class="acronym">PAL</acronym>. If you use BT848 in non-interlaced mode (thereby picking out
only every other field), you'd specify 29.97.</p></td></tr><tr><td><p><span class="term"><code class="varname">interlace</code></span></p></td><td><p>Specifies how many fields there are per frame. A value of 1
indicates that the video is progressive (non-interlaced). <acronym class="acronym">NTSC</acronym> video is
interlaced such that there are two fields per frame, so for standard
<acronym class="acronym">NTSC</acronym> video, this value is 2.</p></td></tr><tr><td><p><span class="term"><code class="varname">first_active</code> and <code class="varname">last_active</code></span></p></td><td><p>Indicate where the <acronym class="acronym">VBL</acronym> lines at the top
of the frame end, and where they resume at the bottom of the frame;
video data is confined between these two scan lines. Usually you'll use
0 for <code class="varname">first_active</code> and <code class="varname">line_count</code>-1
for <code class="varname">last_active</code>; these indicate
wildcard or "don't care" values.</p></td></tr><tr><td><p><span class="term"><code class="varname">orientation</code></span></p></td><td><p>Indicates the orientation of the video; this is typically
<code class="constant">B_VIDEO_TOP_LEFT_RIGHT</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">pixel_width_aspect</code> and <code class="varname">pixel_height_aspect</code></span></p></td><td><p>Specify the numerator and
denominator of the video's aspect ratio. If the aspect ratio is 4:3,
these values will be 4 and 3, respectively.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_request_info"></a>media_request_info</h3></div></div></div><a id="id1193566" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_request_info</span> {
    enum <span class="type">what_code</span> {
       <code class="constant">B_SET_VIDEO_CLIPPING_FOR</code> = 1,
       <code class="constant">B_REQUEST_FORMAT_CHANGE</code>,
       <code class="constant">B_SET_OUTPUT_ENABLED</code>,
       <code class="constant">B_SET_OUTPUT_BUFFERS_FOR</code>,
       <code class="constant">B_FORMAT_CHANGED</code> = 4097
    };
    <span class="type">what_code</span> what;
    <span class="type">int32</span> change_tag;
    <span class="type">status_t</span> status;
    <span class="type">int32</span> cookie;
    <span class="type">void*</span> user_data;
    <span class="type">media_source</span> source;
    <span class="type">media_destination</span> destination;
    <span class="type">media_format</span> format;
    <span class="type">uint32</span> _reserved_[32];
};</pre><p>This structure contains information that describes a request that has
been completed (or has failed). It gets passed into the
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">BMediaNode::RequestCompleted()</code></a>
function.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">what</code></span></p></td><td><p>Describes what type of request has been completed:</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_SET_VIDEO_CLIPPING_FOR</code></span></dt><dd><p>Indicates that a
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SetVideoClippingFor" title="SetVideoClippingFor()"><code class="methodname">BBufferConsumer::SetVideoClippingFor()</code></a>
request has been completed. The <code class="varname">source</code> and
<code class="varname">destination</code> fields contain these values from the request, and
<code class="varname">format</code>.<code class="varname">u</code>.<code class="varname">raw_video</code>.<code class="varname">display</code>
describes the new video display settings.</p></dd><dt><span class="term"><code class="constant">B_REQUEST_FORMAT_CHANGE</code></span></dt><dd><p>Indicates that a
<a class="link" href="BBufferConsumer.html#BBufferConsumer_RequestFormatChange" title="RequestFormatChange(), FormatChanged()"><code class="methodname">BBufferConsumer::RequestFormatChange()</code></a>
request has been completed. The
<code class="varname">source</code> and <code class="varname">destination</code> fields
contain these values from the request,
and <code class="varname">format</code> contains the negotiated format (it may have been altered by
the producer if there were wildcard fields).</p></dd><dt><span class="term"><code class="constant">B_SET_OUTPUT_ENABLED</code></span></dt><dd><p>Indicates that a
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SetOutputEnabled" title="SetOutputEnabled()"><code class="methodname">BBufferConsumer::SetOutputEnabled()</code></a>
request has been completed. The
<code class="varname">source</code> and <code class="varname">destination</code>
fields contain these values from the request,
and <code class="varname">status</code> is always <code class="constant">B_OK</code>.</p></dd><dt><span class="term"><code class="constant">B_SET_OUTPUT_BUFFERS_FOR</code></span></dt><dd><p>Indicates that a
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SetOutputBuffersFor" title="SetOutputBuffersFor()"><code class="methodname">BBufferConsumer::SetOutputBuffersFor()</code></a>
request has been completed. The
<code class="varname">source</code> and <code class="varname">destination</code>
fields contain these values from the request,
and <code class="varname">cookie</code> is a pointer to the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
that was set. Note that the change was only applied if status is <code class="constant">B_OK</code>.</p></dd><dt><span class="term"><code class="constant">B_FORMAT_CHANGED</code></span></dt><dd><p>Indicates that a
<a class="link" href="BBufferConsumer.html#BBufferConsumer_FormatChanged"><code class="methodname">BBufferConsumer::FormatChanged()</code></a>
request has been completed. The
<code class="varname">source</code> and <code class="varname">destination</code> fields contain
these values from the request, and <code class="varname">format</code> indicates the new format. The
values seen here are from the initator's point of view.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="varname">user_data</code></span></p></td><td><p> Contains the <code class="parameter">userData</code> pointer passed to the function
that initiated the request; this can be anything the node making the
request wants.
</p></td></tr><tr><td><p><span class="term"><code class="varname">status</code></span></p></td><td><p>Indicates the status of the function called, and is <code class="constant">B_OK</code> if no
error occurred.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_seek_tag"></a>media_seek_tag</h3></div></div></div><a id="id1193966" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_seek_tag</span> {
    <span class="type">char</span> <code class="varname">data</code>[16];
};</pre><p>The <span class="type">media_seek_tag</span> type is used to contain the seek tag data placed in
buffer headers by producers. This can contain whatever information the
producer deems necessary.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_source"></a>media_source</h3></div></div></div><a id="id1194021" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_source</span> {
    <code class="methodname">media_source</code>(<span class="type">port_id</span>, <span class="type">int32</span>);
    <code class="methodname">media_source</code>(<span class="type">const media_source&amp;</span> <code class="parameter">clone</code>);
    <span class="type">media_source&amp;</span> <code class="methodname">operator=</code> (<span class="type">const media_source&amp;</span> <code class="parameter">clone</code>);
    <code class="methodname">media_source</code>();
    <code class="methodname">~media_source</code>();
    <span class="type">port_id</span> <code class="varname">port</code>;
    <span class="type">int32</span> <code class="varname">id</code>;
    <span class="type">static media_source</span> <code class="varname">null</code>;
private:
    <span class="type">uint32</span> <code class="varname">_reserved_media_source_</code>[2];
};</pre><p>Describes the source end of a media connection between two nodes. The
<code class="varname">port</code> field indicates the port ID on which the source communicates. This
must be the same as the <code class="varname">media_node</code>.<code class="varname">port</code> value.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_video_display_info"></a>media_video_display_info</h3></div></div></div><a id="id1194153" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_video_display_info</span> {
    <span class="type">color_space</span> <code class="varname">format</code>;
    <span class="type">uint32</span> <code class="varname">line_width</code>;
    <span class="type">uint32</span> <code class="varname">line_count</code>;
    <span class="type">uint32</span> <code class="varname">bytes_per_row</code>;
    <span class="type">uint32</span> <code class="varname">pixel_offset</code>;
    <span class="type">uint32</span> <code class="varname">line_offset</code>;
    <span class="type">uint32</span> <code class="varname">flags</code>;
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[3];
    <span class="type">static media_video_display_info</span> <code class="varname">wildcard</code>;
};</pre><p>Describes a video buffer in terms of how its contents should be
interpreted in order to display it on the screen.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">format</code></span></p></td><td><p>Specifies the buffer's color space.</p></td></tr><tr><td><p><span class="term"><code class="varname">line_width</code> and <code class="varname">line_count</code></span></p></td><td><p>Indicate the total width of the buffer in
pixels, and the total height of the buffer in lines.</p></td></tr><tr><td><p><span class="term"><code class="varname">bytes_per_row</code></span></p></td><td><p>Specifies the number of bytes wide the buffer's image
is, including any slop space.</p></td></tr><tr><td><p><span class="term"><code class="varname">pixel_offset</code></span></p></td><td><p>Indicates the number of pixels between the start of the
buffer and the start of the video field. The buffer is the framebuffer.</p></td></tr><tr><td><p><span class="term"><code class="varname">line_offset</code></span></p></td><td><p>Specifies the offset between the start of the buffer and
the start of the field, in lines. The buffer is the framebuffer.</p></td></tr><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>Are
<a class="link" href="TheMediaKit_Constants.html#Constants_media_display_flags" title="media_display_flags"><span class="type">media_display_flags</span></a>,
indicating the dominance and order of the video fields.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="media_video_header"></a>media_video_header</h3></div></div></div><a id="id1194385" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaDefs.h</code></p><pre class="programlisting definition cpp"><span class="type">struct media_video_header</span> {
    <span class="type">uint32</span> <code class="varname">_reserved_</code>[12];
    <span class="type">float</span> <code class="varname">field_gamma</code>;
    <span class="type">uint32</span> <code class="varname">field_sequence</code>;
    <span class="type">uint16</span> <code class="varname">field_number</code>;
    <span class="type">uint16</span> <code class="varname">pulldown_number</code>;
    <span class="type">uint16</span> <code class="varname">first_active_line</code>;
    <span class="type">uint16</span> <code class="varname">line_count</code>;
};</pre><p>Defines the header of a video buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">field_gamma</code></span></p></td><td><p>Specifies the gamma at which the video was captured.</p></td></tr><tr><td><p><span class="term"><code class="varname">field_sequence</code></span></p></td><td><p>Is an identifying number assigned to the field when it
was captured. They progress in sequence; you can tell if a field was
dropped by looking for skips in the sequence. Note that this value
doesn't necessarily start at 0, and it can wrap back around to 0.</p></td></tr><tr><td><p><span class="term"><code class="varname">field_number</code></span></p></td><td><p>Indicates which field of a video frame the buffer
represents. It's 0 for field 1, 1 for field 2, and so forth.</p></td></tr><tr><td><p><span class="term"><code class="varname">pulldown_number</code></span></p></td><td><p>Indicates that the field represented by the buffer is
a duplicate of a field <code class="varname">pulldown_number</code> fields back. If this value is 0,
it's not a duplicate field. This is used in cases when the video has
been converted from one field rate to another, resulting in duplication
of fields; these duplicated fields can be marked using pulldown numbers
so video hardware and software can optimize their performance by
knowing that duplicate fields exist.</p></td></tr><tr><td><p><span class="term"><code class="varname">first_active_line</code></span></p></td><td><p>Indicates the topmost line that actually contains
video data (instead of <acronym class="acronym">VBL</acronym> data); this is
an <acronym class="acronym">NTSC</acronym> or <acronym class="acronym">PAL</acronym> line number,
which is 1-based.</p></td></tr><tr><td><p><span class="term"><code class="varname">line_count</code></span></p></td><td><p>Indicates the number of active video lines in the field.</p></td></tr></tbody></table><p>You may add fields to the end of this buffer if your video format
requires them.</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="TheMediaKit_MessageConstants.html">Message Constants</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="TheMidiKit.html">The Midi Kit</a> </div><div id="footerB"><div id="footerBL"><a href="TheMediaKit_MessageConstants.html" title="Message Constants"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheMidiKit.html" title="The Midi Kit"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
