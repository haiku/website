<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Interface Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheInterfaceKit.html" title="The Interface Kit" /><link rel="prev" href="BRegion.html" title="BRegion" /><link rel="next" href="BScrollBar.html" title="BScrollBar" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BRegion.html" title="BRegion"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheInterfaceKit.html" title="The Interface Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BScrollBar.html" title="BScrollBar"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Interface Kit</div></div><div id="headerB">Prev: <a href="BRegion.html">BRegion</a>  Up: <a href="TheInterfaceKit.html">The Interface Kit</a>  Next: <a href="BScrollBar.html">BScrollBar</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen"></a>BScreen</h2></div></div></div><a id="id1021043" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td>–</td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">interface/Screen.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libbe.so</code></td></tr><tr><td>Allocation:</td><td>Constructor or on the stack</td></tr></tbody></table></td><td>
<a class="link overview" href="BScreen_Overview.html" title="BScreen">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BScreen.html#BScreen_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BScreen.html#BScreen_MemberFunctions">Member Functions</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_Constructor"></a>BScreen()</h4></div></div></div><div class="synopsisgroup">
<code class="constructorsynopsis cpp"><span class="methodname">BScreen</span>(<span class="methodparam"><span class="type"><a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>* </span><span class="parameter">window</span></span>);</code>

<code class="constructorsynopsis cpp"><span class="methodname">BScreen</span>(<span class="methodparam"><span class="type">screen_id </span><span class="parameter">id</span><span class="initializer"> = <span class="constant">B_MAIN_SCREEN_ID</span></span></span>);</code>
</div><p>
Initializes the <code class="classname">BScreen</code> object so that it represents the screen where
<code class="parameter">window</code> is displayed or the screen identified by
<code class="parameter">id</code>. If <code class="parameter">window</code> is <code class="constant">NULL</code> or
hidden, or if the <code class="parameter">id</code> is invalid, the
<code class="classname">BScreen</code> will represent the main
screen.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Since multiple monitors aren't currently supported, there's no API for
screen identifiers other than for the main screen.</p></div></div></div><p>
To be sure the new object was correctly constructed, call
<a class="link" href="BScreen.html#BScreen_IsValid" title="IsValid()"><code class="methodname">IsValid()</code></a>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_Destructor"></a>~BScreen()</h4></div></div></div><code class="destructorsynopsis cpp"><span class="methodname">~BScreen</span>();</code><p>
Unlocks the screen and invalidates the <code class="classname">BScreen</code> object.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ColorMap"></a><a id="BScreen_IndexForColor"></a>
<a id="BScreen_ColorForIndex"></a>
ColorMap(), IndexForColor(), ColorForIndex()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">const </span><span class="type">color_map* </span><span class="methodname">ColorMap</span>();</code><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="modifier">inline </span><span class="type">uint8 </span><span class="methodname">IndexForColor</span>(<span class="methodparam"><span class="type">rgb_color </span><span class="parameter">color</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">uint8 </span><span class="methodname">IndexForColor</span>(<span class="methodparam"><span class="type">uint8 </span><span class="parameter">red</span></span>,<br />                    <span class="methodparam"><span class="type">uint8 </span><span class="parameter">green</span></span>,<br />                    <span class="methodparam"><span class="type">uint8 </span><span class="parameter">blue</span></span>,<br />                    <span class="methodparam"><span class="type">uint8 </span><span class="parameter">alpha</span><span class="initializer"> = 255</span></span>);</code>
</div><code class="methodsynopsis cpp"><span class="type">rgb_color </span><span class="methodname">ColorForIndex</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">uint8 </span><span class="parameter">index</span></span>);</code><code class="methodsynopsis cpp"><span class="type">uint8 </span><span class="methodname">InvertIndex</span>(<span class="methodparam"><span class="type">uint8 </span><span class="parameter">index</span></span>);</code><p>
These functions return information from the color_map structure for this
screen. The <a class="link" href="TheInterfaceKit_DefinedTypes.html#color_map" title="color_map"><span class="type">color_map</span></a>
structure defines the set of 256 colors that can be
displayed in an <code class="constant">B_CMAP8</code> color space. A single
<span class="type">color_map</span> is shared by all
applications that display on the same screen. See the <span class="type">color_map</span> structure
for more information about the structure.
</p><p>
<code class="methodname">ColorMap()</code> returns a pointer to the <span class="type">color_map</span> itself. The structure
belongs to the <code class="classname">BScreen</code> object; you can't modify or free it. (Note that
the the <code class="methodname">system_colors()</code> function retrieves the <span class="type">color_map</span> structure for
the main screen without reference to a <code class="classname">BScreen</code> object.)
</p><p>
<code class="methodname">IndexForColor()</code> returns the "index" of the 8-bit color that, in this
screen's color map, most closely matches the given 32-bit color. You can
pass the <code class="parameter">index</code> to functions such
<a class="link" href="BBitmap.html#BBitmap_SetBits" title="SetBits()"><code class="methodname">BBitmap::SetBits()</code></a> to set an 8-bit
color. Note that <code class="methodname">IndexForColor()</code> knows how to convert
<code class="constant">B_TRANSPARENT_32_BIT</code> into <code class="constant">B_TRANSPARENT_8_BIT</code>.
</p><p>
<code class="methodname">ColorForIndex()</code> returns the 32-bit color representation of a given 8-bit
color <code class="parameter">index</code>. This function doesn't convert
<code class="constant">B_TRANSPARENT_8_BIT</code> into
<code class="constant">B_TRANSPARENT_32_BIT</code>.
</p><p>
<code class="methodname">InvertIndex()</code> takes an 8-bit <code class="parameter">index</code>
and returns an index that represents
the color's "inversion." Inverted colors are typically used for
highlighting.
</p><div class="admonition important"><div class="title">Important</div><div class="graphic"><img class="icon" alt="Important" width="32" src="./images/admonitions/Warning_32.png" /><div class="text"><p>The information gained through <code class="methodname">IndexForColor()</code>,
<code class="methodname">ColorForIndex()</code>, and
<code class="methodname">InvertIndex()</code> can be retrieved more efficiently
from the <span class="type">color_map</span>
structure. If you're repeatedly calling these functions, you should
consider accessing the <span class="type">color_map</span> structure, instead. Note, however, that
the intelligent <code class="constant">B_TRANSPARENT_32_BIT</code> to
<code class="constant">B_TRANSPARENT_8_BIT</code> conversion is
not supported by the structure.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ColorSpace"></a>ColorSpace()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">color_space </span><span class="methodname">ColorSpace</span>();</code><p>
Returns the color space of the screen display—typically <code class="constant">B_CMAP8</code>,
<code class="constant">B_RGB15</code>, or <code class="constant">B_RGB32</code>—or
<code class="constant">B_NO_COLOR_SPACE</code> if the <code class="classname">BScreen</code> object is
invalid.
</p><p>
The color space is set by the user through the <span class="application">Screen</span> preferences
application. You can set it programatically through the
<a class="link" href="BScreen.html#BScreen_SetMode"><code class="methodname">SetMode()</code></a>
function.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_Frame"></a>Frame()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type"><a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a> </span><span class="methodname">Frame</span>();</code><p>
Returns the rectangle that locates the screen in the screen coordinate
system. For example, the frame for a 1,024 * 768 main screen looks like
this:
</p><pre class="programlisting example cpp"><a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a>(0.0, 0.0, 1023.0, 767.0)</pre><p>
If the <code class="classname">BScreen</code> object is invalid, all sides of the rectangle are set to
0.0.
</p><p>
The screen's frame rectangle is set by the user through the <span class="application">Screen</span>
preferences application. You can set it programatically through the
<a class="link" href="BScreen.html#BScreen_SetMode"><code class="methodname">SetMode()</code></a> function.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_GetDeviceInfo"></a>GetDeviceInfo()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetDeviceInfo</span>(<span class="methodparam"><span class="type">accelerant_device_info* </span><span class="parameter">info</span></span>);</code><p>
Returns information about the graphics card.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_GetModeList"></a><a id="BScreen_SetMode"></a>
<a id="BScreen_GetMode"></a>
GetModeList(), SetMode(), GetMode()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetModeList</span>(<span class="methodparam"><span class="type">display_mode** </span><span class="parameter">mode_list</span></span>,<br />                     <span class="methodparam"><span class="type">uint32* </span><span class="parameter">count</span></span>);</code><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetMode</span>(<span class="methodparam"><span class="type">display_mode* </span><span class="parameter">mode</span></span>,<br />                 <span class="methodparam"><span class="type">bool </span><span class="parameter">makeDefault</span><span class="initializer"> = <span class="constant">false</span></span></span>);</code><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetMode</span>(<span class="methodparam"><span class="type">display_mode* </span><span class="parameter">mode</span></span>);</code><p>
These functions set and get the screen's display mode. Each <span class="type">display_mode</span>
structure (defined in <code class="filename">add-ons/graphics/Accelerant.h</code>) is a distinct
combination of screen size, pixel depth, and display timing.
</p><p>
<code class="methodname">GetModeList()</code> allocates and returns, in <code class="parameter">mode_list</code>, a list of the
<span class="type">display_mode</span> structures that the graphics card is guaranteed to support;
<code class="parameter">count</code> is set to the number of <span class="type">display_mode</span> elements in the list. The
caller is responsible for freeing <code class="parameter">mode_list</code>.
</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>There's no guarantee that the monitor can support all of the modes that
<code class="methodname">GetModeList()</code> retrieves.</p></div></div></div><p>
<code class="methodname">SetMode()</code> resets the screen to the given <code class="parameter">mode</code>.
If <code class="parameter">makeDefault</code> is <code class="constant">true</code>,
the mode becomes the default for the current workspace.
</p><p>
<code class="methodname">GetMode()</code> copies the current <span class="type">display_mode</span>
into <code class="parameter">mode</code>.
</p><p>
The <span class="type">display_mode</span> structure is:
</p><pre class="programlisting definition c">typedef struct {
      <span class="type">display_timing</span> <code class="varname">timing</code>;
      <span class="type">uint32</span> <code class="varname">space</code>;
      <span class="type">uint16</span> <code class="varname">virtual_width</code>;
      <span class="type">uint16</span> <code class="varname">virtual_height</code>;
      <span class="type">uint16</span> <code class="varname">h_display_start</code>;
      <span class="type">uint16</span> <code class="varname">v_display_start</code>;
      <span class="type">uint32</span> <code class="varname">flags</code>;
} <span class="type">display_mode</span>;</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">timing</code></span></p></td><td><p>Provides CTRC timing information.</p></td></tr><tr><td><p><span class="term"><code class="varname">space</code></span></p></td><td><p>Is the color space of the display.</p></td></tr><tr><td><p><span class="term"><code class="varname">virtual_width</code></span></p></td><td><p>Is the screen's virtual width in pixels</p></td></tr><tr><td><p><span class="term"><code class="varname">virtual_height</code></span></p></td><td><p>Is the screen's virtual height in lines.</p></td></tr><tr><td><p><span class="term"><code class="varname">h_display_start</code></span></p></td><td><p>Is the first displayed pixel in a line</p></td></tr><tr><td><p><span class="term"><code class="varname">v_display_start</code></span></p></td><td><p>Is the first displayed line.</p></td></tr><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>Are mode flags:</p><dl class="variablelist"><dt><span class="term"><code class="constant">B_SCROLL</code></span></dt><dd><p>Scrolling display; a large display is being simulated by
scrolling around on a smaller screen.</p></dd><dt><span class="term"><code class="constant">B_8_BIT_DAC</code></span></dt><dd><p>The DAC is in 8-bit mode.</p></dd><dt><span class="term"><code class="constant">B_HARDWARE_CURSOR</code></span></dt><dd><p>The mode supports a hardware cursor.</p></dd><dt><span class="term"><code class="constant">B_PARALLEL_ACCESS</code></span></dt><dd><p>The mode supports parallel access.</p></dd><dt><span class="term"><code class="constant">B_DPMS</code></span></dt><dd><p>The mode supports power management.</p></dd><dt><span class="term"><code class="constant">B_IO_FB_NA</code></span></dt><dd><p>The graphics card's frame buffer shouldn't be touched by the
<span class="application">Application Server</span> while the card's acceleration
engine might be doing so.</p></dd></dl></td></tr></tbody></table><p>
The <span class="type">display_timing</span> structure is:
</p><pre class="programlisting definition c">typedef struct {
      <span class="type">uint32</span> <code class="varname">pixel_clock</code>;
      <span class="type">uint16</span> <code class="varname">h_display</code>;
      <span class="type">uint16</span> <code class="varname">h_sync_start</code>;
      <span class="type">uint16</span> <code class="varname">h_sync_end</code>;
      <span class="type">uint16</span> <code class="varname">h_total</code>;
      <span class="type">uint16</span> <code class="varname">v_display</code>;
      <span class="type">uint16</span> <code class="varname">h_display</code>;
      <span class="type">uint16</span> <code class="varname">v_sync_start</code>;
      <span class="type">uint16</span> <code class="varname">v_sync_end</code>;
      <span class="type">uint16</span> <code class="varname">v_total</code>;
      <span class="type">uint32</span> <code class="varname">flags</code>;
} <span class="type">display_timing</span>;</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">pixel_clock</code></span></p></td><td><p>Is in kHz.</p></td></tr><tr><td><p><span class="term"><code class="varname">h_display</code></span></p></td><td><p>Is in pixels, not in character clocks.</p></td></tr><tr><td><p><span class="term"><code class="varname">v_display</code></span></p></td><td><p>is in lines.</p></td></tr><tr><td><p><span class="term"><code class="varname">flags</code></span></p></td><td><p>are:</p><dl class="variablelist"><dt><span class="term"><code class="constant">B_BLANK_PEDESTAL</code></span></dt><dd><p>Use a 7.5 IRE blanking pedestal instead of a 0.0 IRE
blanking pedestal. Usually 0.0 IRE.</p></dd><dt><span class="term"><code class="constant">B_TIMING_INTERLACED</code></span></dt><dd><p>The mode is interlaced instead of progressively
scanned. Rarely set; most modern displays don't need this.</p></dd><dt><span class="term"><code class="constant">B_POSITIVE_HSYNC</code></span></dt><dd><p>If set, the mode uses a positive (high) sync polarity.</p></dd><dt><span class="term"><code class="constant">B_POSITIVE_VSYNC</code></span></dt><dd><p>If set, the mode uses a negative (low) sync polarity.</p></dd><dt><span class="term"><code class="constant">B_SYNC_ON_GREEN</code></span></dt><dd><p>The mode generates sync information on the green color
signal.</p></dd></dl></td></tr></tbody></table><p>
See also:
<a class="link" href="BScreen.html#BScreen_ProposeMode" title="ProposeMode()"><code class="methodname">ProposeMode()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_GetPixelClockLimits"></a>GetPixelClockLimits()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetPixelClockLimits</span>(<span class="methodparam"><span class="type">display_mode* </span><span class="parameter">mode</span></span>,<br />                             <span class="methodparam"><span class="type">uint32* </span><span class="parameter">low</span></span>,<br />                             <span class="methodparam"><span class="type">uint32* </span><span class="parameter">high</span></span>);</code><p>
This function returns, in <code class="parameter">low</code> and <code class="parameter">high</code>,
the minimum and maximum "pixel
clock" rates (in thousands-of-pixels per second) that are possible for
the given <code class="parameter">mode</code>. Given the pixel clock and a display mode, you can
determine the refresh rate range by dividing the pixel clock by the
"real" size of the screen, thus:
</p><pre class="programlisting example cpp"><span class="type">uint32</span> <code class="varname">hi_clock</code>, <code class="varname">lo_clock</code>;
<span class="type">float</span> <code class="varname">hi_refresh</code>, <code class="varname">lo_refresh</code>;
<span class="type">float</span> <code class="varname">real_size</code>;
<span class="type">display_mode</span> <code class="varname">mode</code>;

<code class="methodname">GetMode</code>(&amp;<code class="varname">mode</code>);
<code class="methodname">GetPixelClockLimits</code>(&amp;<code class="varname">mode</code>, &amp;<code class="varname">lo_clock</code>, &amp;<code class="varname">hi_clock</code>);

<span class="comment">/* The real screen dimensions (i.e. the dimensions for the purposes
* of the gun) are given by the 'timing.h_total' and
* 'timing.v_total' fields.
*/</span>
<code class="varname">total_size</code> = <code class="varname">mode</code>.<code class="varname">timing</code>.<code class="varname">h_total</code> * <code class="varname">mode</code>.<code class="varname">timing</code>.<code class="varname">v_total</code>

<span class="comment">/* Get the refresh rate by dividing the pixel clock by the total
* screen size. Remember -- the pixel clock values are given in
* kHz; we multiply by 1000.0 to retrieve refresh rates in Hz.
*/</span>
<code class="varname">hi_refresh</code> = ((<span class="type">float</span>) <code class="varname">hi_clock</code>*1000.0)/(<span class="type">float</span>) <code class="varname">total_size</code>;
<code class="varname">lo_refresh</code> = ((<span class="type">float</span>) <code class="varname">lo_clock</code>*1000.0)/(<span class="type">float</span>) <code class="varname">total_size</code>;</pre><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
Pixel clock limits returned successfully.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code>.</span></p></td><td><p>
No clock limits known.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_GetTimingConstraints"></a>GetTimingConstraints()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetTimingConstraints</span>(<span class="methodparam"><span class="type">display_timing_constraints* </span><span class="parameter">dtc</span></span>);</code><p>
This function fills out the <code class="parameter">dtc</code> structure with the timing constraints of
the current display mode.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
Constraints returned successfully.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code>.</span></p></td><td><p>
No constraints known.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ID"></a>ID()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">screen_id </span><span class="methodname">ID</span>();</code><p>
Returns the identifier for the screen. The main screen is identified as
<code class="constant">B_MAIN_SCREEN_ID</code>.
</p><p>
The ID isn't presistent across boots, and may change if the monitor is
diconnected and then reconnected.
</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Currently, this function always returns <code class="constant">B_MAIN_SCREEN_ID</code>, even if the
<code class="classname">BScreen</code> object is invalid.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_IsValid"></a>IsValid()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">IsValid</span>();</code><p>
Returns <code class="constant">true</code> if the <code class="classname">BScreen</code>
object is valid (if it represents a real
screen connected to the computer), and <code class="constant">false</code> if not.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ProposeMode"></a>ProposeMode()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">ProposeMode</span>(<span class="methodparam"><span class="type">display_mode* </span><span class="parameter">candidate</span></span>,<br />                     <span class="methodparam"><span class="modifier">const </span><span class="type">display_mode* </span><span class="parameter">low</span></span>,<br />                     <span class="methodparam"><span class="modifier">const </span><span class="type">display_mode* </span><span class="parameter">high</span></span>);</code><p>
<code class="methodname">ProposeMode()</code> is a convenience function
that attempts to adjust <code class="parameter">candidate</code>
so that it's a supported mode (as listed by the
<a class="link" href="BScreen.html#BScreen_GetModeList" title="GetModeList(), SetMode(), GetMode()"><code class="methodname">GetModeList()</code></a> function).
It then compares the possibly-adjusted <code class="parameter">candidate</code> to the limits declared
in <code class="parameter">low</code> and <code class="parameter">high</code>
and expresses this comparison in the return value. Note
that the function doesn't adjust <code class="parameter">candidate</code> so that it is, of necessity,
between <code class="parameter">low</code> and <code class="parameter">high</code>.
</p><p>
Exactly how <code class="methodname">ProposeMode()</code> works is up to the individual graphics driver.
It's expected that the function will adjust <code class="parameter">candidate</code>'s screen size
fields while holding the color space constant.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>This function was formerly called <code class="methodname">ProposeDisplayMode()</code>.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
Candidate (as returned) is supported and falls within the
limits.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>
Candidate (as returned) is supported, but doesn't fall
within the limits.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code>.</span></p></td><td><p>
candidate isn't supported.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_ReadBitmap"></a><a id="BScreen_GetBitmap"></a>
ReadBitmap(), GetBitmap()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">ReadBitmap</span>(<span class="methodparam"><span class="type"><a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a>* </span><span class="parameter">buffer</span></span>,<br />                    <span class="methodparam"><span class="type">bool </span><span class="parameter">draw_cursor</span><span class="initializer"> = <span class="constant">true</span></span></span>,<br />                    <span class="methodparam"><span class="type"><a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a>* </span><span class="parameter">bounds</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">GetBitmap</span>(<span class="methodparam"><span class="type"><a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a>** </span><span class="parameter">buffer</span></span>,<br />                   <span class="methodparam"><span class="type">bool </span><span class="parameter">draw_cursor</span><span class="initializer"> = <span class="constant">true</span></span></span>,<br />                   <span class="methodparam"><span class="type"><a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a>* </span><span class="parameter">bounds</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><p>
These functions provide read-only access to the screen by copying the
screen's contents into the first argument
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a>. The difference between
them is that <code class="methodname">ReadBitmap()</code> expects you to allocate the
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a> before
passing it in, while <code class="methodname">GetBitmap()</code> allocates a new
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a> for you. The
caller is responsible for freeing the
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a> allocated by
<code class="methodname">GetBitmap()</code>.
</p><p>
The <code class="parameter">draw_cursor</code> argument determines whether the cursor is drawn in the
screen shot; <code class="parameter">bounds</code> let you specify the region, in screen coordinates,
that you want copied. If <code class="parameter">bounds</code> is <code class="constant">NULL</code>,
the entire screen is copied. The
functions fail if the <code class="parameter">bounds</code> rectangle doesn't fall wholly within the
screen's frame.
</p><p>
The functions return <code class="constant">B_OK</code> on success or
<code class="constant">B_ERROR</code> on failure.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_SetDesktopColor"></a><a id="BScreen_DesktopColor"></a>
SetDesktopColor() , DesktopColor()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetDesktopColor</span>(<span class="methodparam"><span class="type">rgb_color </span><span class="parameter">color</span></span>,<br />                     <span class="methodparam"><span class="type">bool </span><span class="parameter">makeDefault</span><span class="initializer"> = <span class="constant">true</span></span></span>);</code><code class="methodsynopsis cpp"><span class="type">rgb_color </span><span class="methodname">DesktopColor</span>();</code><p>
These functions set and return the color of the desktop—the
backdrop against which windows are displayed on the screen.
<code class="methodname">SetDesktopColor()</code> makes an immediate change in the desktop color
displayed on-screen;
<code class="methodname">DesktopColor()</code> returns the color currently displayed.
</p><p>
If the <code class="parameter">makeDefault</code> flag is <code class="constant">true</code>,
the color that's set becomes the default
color for the screen; it's the color that will be shown the next time the
machine is booted. If the flag is <code class="constant">false</code>, the color is set only for the
current session.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>The "Background Images" section tells you how to convince the desktop
to display a bitmap image.</p></div></div></div><p>
Typically, users choose the desktop color with the Screen preferences
application.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_SetDPMS"></a><a id="BScreen_DPMSCapabilities"></a>
<a id="BScreen_DPMSState"></a>
SetDPMS() , DPMSState() , DPMSCapabilities()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetDPMS</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">dpmsState</span></span>);</code><code class="methodsynopsis cpp"><span class="type">uint32 </span><span class="methodname">DPMSState</span>();</code><code class="methodsynopsis cpp"><span class="type">uint32 </span><span class="methodname">DPMSCapabilities</span>();</code><p>
<code class="methodname">SetDPMS()</code> lets you set the VESA Display Power Management Signaling state
for the screen. The state can be one of the following values:
</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_DPMS_ON</code></span></p></td><td><p>Image is visible, normal screen operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DPMS_STAND_BY</code></span></p></td><td><p>Image is not visible, but can be restored "instantly."
Saves around 30% of the power used by the monitor in
<code class="constant">B_DPMS_ON</code> mode.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DPMS_SUSPEND</code></span></p></td><td><p>Image is not visible, but can be restored in less than
five seconds. Saves more power by turning off the CRT's heater. The
amount of savings (or if there's any) depends on the display.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DPMS_OFF</code></span></p></td><td><p>Image is not visible and will take some time to restore.
Typically turns off all monitor power except the processor watching the
sync signals for a higher power state (typically
<code class="constant">B_DPMS_ON</code>).</p></td></tr></tbody></table><p>
<code class="methodname">DPMSState()</code> returns the current display state, indicating whether the
monitor is on or off or in one of the two sleep modes.
</p><p>
<code class="methodname">DPMSCapabilities()</code> indicates which of the above modes the monitor
supports.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_SetToNext"></a>SetToNext()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetToNext</span>();</code><p>
In the current BeOS release, this function always returns <code class="constant">B_ERROR</code>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BScreen_WaitForRetrace"></a>WaitForRetrace()</h4></div></div></div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">WaitForRetrace</span>();</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">WaitForRetrace</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">timeout</span></span>);</code>
</div><p>
Blocks until the monitor has finished the current vertical retrace, then
returns <code class="constant">B_OK</code>. There are a few milliseconds available before it begins
another retrace. Drawing changes made to the frame buffer in this period
won't cause any "flicker" on-screen.
</p><p>
For some graphics card drivers, this function will wait for vertical
sync; for others it will wait until vertical blank, providing a few extra
milliseconds.
</p><p>
The <code class="parameter">timeout</code> argument lets you provide a timeout in microseconds—if
the screen hasn't retraced within the limit, the function returns
<code class="constant">B_ERROR</code>.
</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BRegion.html">BRegion</a>  Up: <a href="TheInterfaceKit.html">The Interface Kit</a>  Next: <a href="BScrollBar.html">BScrollBar</a> </div><div id="footerB"><div id="footerBL"><a href="BRegion.html" title="BRegion"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheInterfaceKit.html" title="The Interface Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BScrollBar.html" title="BScrollBar"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
