<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Media Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheMediaKit.html" title="The Media Kit" /><link rel="prev" href="BBufferGroup.html" title="BBufferGroup" /><link rel="next" href="BContinuousParameter.html" title="BContinuousParameter" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BBufferGroup.html" title="BBufferGroup"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BContinuousParameter.html" title="BContinuousParameter"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Media Kit</div></div><div id="headerB">Prev: <a href="BBufferGroup.html">BBufferGroup</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BContinuousParameter.html">BContinuousParameter</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer"></a>BBufferProducer</h2></div></div></div><a id="id1123587" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td><a class="link" href="BMediaNode.html" title="BMediaNode"><code class="classname">BMediaNode</code></a></td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">media/BufferProducer.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libmedia.so</code></td></tr><tr><td>Allocation:</td><td>Constructor only</td></tr></tbody></table></td><td>
<a class="link overview" href="BBufferProducer_Overview.html" title="BBufferProducer">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BBufferProducer.html#BBufferProducer_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BBufferProducer.html#BBufferProducer_MemberFunctions">Member Functions</a></span></li><li><span class="section"><a href="BBufferProducer.html#BBufferProducer_Constants">Constants</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_Constructor"></a>BBufferProducer()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="constructorsynopsis cpp"><span class="modifier">explicit </span><span class="methodname">BBufferProducer</span>(<span class="methodparam"><span class="type">media_type </span><span class="parameter">producerType</span></span>);</code><p>Constructs the <code class="classname">BBufferProducer</code> object.
The <code class="parameter">producerType</code> specifies the
type of media data that will be output by the node.</p><p>If the node will produce more than one type of data, your
<code class="classname">BBufferProducer</code>
subclass should set the kind to the default (which is a wildcard value).</p><p>If your node has additional latency on startup, you should call
<a class="link" href="BBufferProducer.html#BBufferProducer_SetInitialLatency" title="SetInitialLatency()"><code class="methodname">SetInitialLatency()</code></a>
to record this information. This might be the case if
the buffers your node produces are created from an input signal which
refreshes infrequently, such as a television signal.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>In BeOS Release 4.5.2 and earlier, the <code class="parameter">producerType</code> has a default
value; it no longer does, and you'll have to specify the media type
yourself.</p></div></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_AdditionalBufferRequested"></a>AdditionalBufferRequested()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">AdditionalBufferRequested</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                                           <span class="methodparam"><span class="type">media_buffer_id </span><span class="parameter">previousBufferID</span></span>,<br />                                           <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">previousTime</span></span>,<br />                                           <span class="methodparam"><span class="modifier">const </span><span class="type">media_seek_tag* </span><span class="parameter">previousTag</span></span>);</code><p>When a consumer calls
<a class="link" href="BBufferConsumer.html#BBufferConsumer_RequestAdditionalBuffer" title="RequestAdditionalBuffer()"><code class="methodname">BBufferConsumer::RequestAdditionalBuffer()</code></a>,
this
function is called as a result. Its job is to call
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">SendBuffer()</code></a>
to immediately send the next buffer to the consumer.</p><p>The <code class="parameter">previousBufferID</code>, <code class="parameter">previousTime</code>,
and <code class="parameter">previousTag</code> arguments identify
the last buffer the consumer received. Your node should respond by
sending the next buffer after the one described.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>The <code class="parameter">previousTag</code> may be <code class="constant">NULL</code>.</p></div></div></div><p>Return <code class="constant">B_OK</code> if all is well; otherwise
return an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_ChangeFormat"></a>ChangeFormat()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">ChangeFormat</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                      <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                      <span class="methodparam"><span class="type">media_format* </span><span class="parameter">newFormat</span></span>);</code><p>Informs the destination that the data flowing between source and
destination is immediately changing to the format specified by
<code class="parameter">newFormat.</code></p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>You must never call
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">SendBuffer()</code></a>
while this call is pending.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The format change request has been sent without error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_CHANGE_IN_PROGRESS</code>.</span></p></td><td><p>A mutual exclusion error has occurred
with <a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">SendBuffer()</code></a>;
<code class="methodname">ChangeFormat()</code> and
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">SendBuffer()</code></a>
can't both be running at the same time.</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>You may receive other errors if the consumer doesn't
agree with the new format you're requesting.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_ClipDataToRegion"></a>ClipDataToRegion()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">static </span><span class="type">status_t </span><span class="methodname">ClipDataToRegion</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">format</span></span>,<br />                                 <span class="methodparam"><span class="type">int32 </span><span class="parameter">byteCount</span></span>,<br />                                 <span class="methodparam"><span class="modifier">const </span><span class="type">void* </span><span class="parameter">clipData</span></span>,<br />                                 <span class="methodparam"><span class="type"><span class="classname">BRegion</span>* </span><span class="parameter">region</span></span>);</code><p>Given <code class="parameter">byteCount</code> bytes of clipping
data <code class="parameter">clipDatain</code> the specified <code class="parameter">format</code>,
makes the specified <code class="parameter">region</code> match the clipping region.</p><p>The <code class="parameter">region</code> you specify must already exist.</p><p>The only format currently supported is
<code class="constant">B_CLIP_SHORT_RUNS</code>.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The clip data was converted without error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_CLIP_FORMAT</code>.</span></p></td><td><p>The specified clip format is invalid.</p></td></tr></tbody></table><p>See also:
<a class="link" href="BBufferConsumer.html#BBufferConsumer_RegionToClipData" title="RegionToClipData()"><code class="methodname">BBufferConsumer::RegionToClipData()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_Connect"></a>Connect()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Connect</span>(<span class="methodparam"><span class="type">status_t </span><span class="parameter">status</span></span>,<br />                     <span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                     <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                     <span class="methodparam"><span class="modifier">const </span><span class="type">media_format&amp; </span><span class="parameter">format</span></span>,<br />                     <span class="methodparam"><span class="type">char* </span><span class="parameter">ioName</span></span>);</code><p>Implement this hook function to establish a connection between the source
and the destination. The format negotiation is already complete by the
time <code class="methodname">Connect()</code> is called, so you have to
accept the specified <code class="parameter">format</code>.</p><p>The <code class="parameter">status</code> argument indicates
whether or not the connection actually took
place; this is the result code returned by the
<a class="link" href="BBufferConsumer.html#BBufferConsumer_Connected" title="Connected()"><code class="methodname">BBufferConsumer::Connected()</code></a>
function or an error code indicating an
error that has occurred during other preparation for the connection.</p><p>If <code class="parameter">status</code> isn't <code class="constant">B_OK</code>,
you should release the <span class="type">media_source</span> that was
reserved for this connection by
<a class="link" href="BBufferProducer.html#BBufferProducer_PrepareToConnect" title="PrepareToConnect()"><code class="methodname">PrepareToConnect()</code></a>;
this lets it be used by other connection attempts.</p><p>On entry, <code class="parameter">ioName</code> contains the connection name specified by the consumer
(this may be different from the name specified by the
<a class="link" href="BBufferProducer.html#BBufferProducer_PrepareToConnect" title="PrepareToConnect()"><code class="methodname">PrepareToConnect()</code></a>
function). On return, <code class="parameter">ioName</code> should
point to a name for the connection; if the name really matters to you,
copy the name you want the connection to have back into <code class="parameter">ioName</code>;
otherwise, you can leave it alone.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_Disconnect"></a>Disconnect()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Disconnect</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                        <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>) <span class="modifier"> = 0</span>;</code><p>Your implementation of <code class="methodname">Disconnect()</code>
should terminate the connection between the specified
<code class="parameter">source</code> and
<code class="parameter">destination</code>. Once you return from this function,
you shouldn't send any further buffers on the connection.</p><p>If a <a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
has been specified for your producer (via the
<a class="link" href="BBufferProducer.html#BBufferProducer_SetBufferGroup" title="SetBufferGroup()"><code class="methodname">SetBufferGroup()</code></a>
function), you should delete it here.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_DisposeOutputCookie"></a>DisposeOutputCookie()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">DisposeOutputCookie</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">cookie</span></span>) <span class="modifier"> = 0</span>;</code><p>Once a client has finished iterating through your outputs via
<a class="link" href="BBufferProducer.html#BBufferProducer_GetNextOutput" title="GetNextOutput()"><code class="methodname">GetNextOutput()</code></a>
calls, it will call this function with the last value you
returned as a <code class="parameter">cookie</code>. This gives you the opportunity to dispose of any
memory you may have allocated for the iteration process.</p><p>Return <code class="constant">B_OK</code> if the cookie is successfully disposed of (or if nothing
needs to be done); otherwise, return an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_EnableOutput"></a>EnableOutput()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">EnableOutput</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">whichOutput</span></span>,<br />                          <span class="methodparam"><span class="type">bool </span><span class="parameter">enabled</span></span>,<br />                          <span class="methodparam"><span class="type">int32* </span><span class="parameter">_deprecated_</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called when a consumer's
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SetOutputEnabled" title="SetOutputEnabled()"><code class="methodname">SetOutputEnabled()</code></a>
function is called. This indicates whether or not the output specified by
<code class="parameter">whichOutput</code> needs to be sent buffers. You must implement this function so
that you don't send buffers to outputs that don't need them. The
<code class="parameter">_deprecated_</code> argument is no longer used.</p><p>By default, output is enabled.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_FindLatencyFor"></a>FindLatencyFor()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">FindLatencyFor</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">forDestination</span></span>,<br />                        <span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">outLatency</span></span>,<br />                        <span class="methodparam"><span class="type">media_node_id* </span><span class="parameter">outTimeSource</span></span>) <span class="modifier"> = 0</span>;</code><p><code class="methodname">FindLatencyFor()</code> returns the latency
introduced by sending data to the destination
<code class="parameter">forDestination</code>. On return, the latency will be
stored in <code class="parameter">outLatency</code>, and the time source used
by <code class="parameter">forDestination</code> will be available in
<code class="parameter">outTimeSource</code> (unless an error is returned, in
which case these values are undetermined).</p><p>The latency of sending a buffer from one time source to another should
always be assumed to be zero, since there may be no relationship between
the progress of time of two different time sources.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The latency was returned without error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_DESTINATION</code>.</span></p></td><td><p>The destination is invalid.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>The request couldn't be sent to the destination.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_FindSeekTag"></a>FindSeekTag()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">FindSeekTag</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">forDestination</span></span>,<br />                     <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">inTargetTime</span></span>,<br />                     <span class="methodparam"><span class="type">media_seek_tag* </span><span class="parameter">outTag</span></span>,<br />                     <span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">outTaggedTime</span></span>,<br />                     <span class="methodparam"><span class="type">uint32* </span><span class="parameter">outFlags</span><span class="initializer"> = 0</span></span>,<br />                     <span class="methodparam"><span class="type">uint32* </span><span class="parameter">inFlags</span><span class="initializer"> = 0</span></span>);</code><p>In order to improve seek performance, the Media Kit provides the
concept of seek tags. These are special tags that identify easily-located
points in media data (such as key frames in Cinepak video). The
<code class="methodname">FindSeekTag()</code> function asks the consumer
specified by <code class="parameter">forDestination</code> for the nearest seek
tag to the time specified by <code class="parameter">inTargetTime</code>, and
returns the tag in <code class="parameter">outTag</code> and the time
corresponding to that tag in <code class="parameter">outTaggedTime</code>. On
return, <code class="parameter">outFlags</code> (if the pointer isn't
<code class="constant">NULL</code>) contains flags giving further details about
the tag.</p><p>There are currently no defined values for
<code class="parameter">inFlags</code> or <code class="parameter">outFlags</code>.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>No error.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>An error occurred communicating with the Media Server.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_FormatChangeRequested"></a>FormatChangeRequested()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">FormatChangeRequested</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                                       <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                                       <span class="methodparam"><span class="type">media_format* </span><span class="parameter">ioFormat</span></span>,<br />                                       <span class="methodparam"><span class="type">int32* </span><span class="parameter">_deprecated_</span></span>) <span class="modifier"> = 0</span>;</code><p>Implement <code class="methodname">FormatChangeRequested()</code> to
change the format of the media data flowing from the given
<code class="parameter">source</code> to the specified
<code class="parameter">destination</code> to the format specified by
<code class="parameter">ioFormat</code>. If there are wildcards specified in
<code class="parameter">ioFormat</code>, fill them in to match the format you
prefer before returning from this call. You should ignore the
<code class="parameter">_deprecated_</code> argument; it's no longer
used.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>This call is issued synchronously by the destination, so you can't ask
it if the format is acceptable. Fortunately, since the destination issued
the request, you can safely assume that it's fine.</p></div></div></div><p>Return <code class="constant">B_OK</code> if the change request is processed successfully; otherwise,
return an appropriate error code.</p><p>See also:
<a class="link" href="BBufferProducer.html#BBufferProducer_FormatSuggestionRequested" title="FormatSuggestionRequested()"><code class="methodname">FormatSuggestionRequested()</code></a>,
<a class="link" href="BBufferProducer.html#BBufferProducer_FormatProposal" title="FormatProposal()"><code class="methodname">FormatProposal()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_FormatProposal"></a>FormatProposal()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">FormatProposal</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">output</span></span>,<br />                                <span class="methodparam"><span class="type">media_format* </span><span class="parameter">format</span></span>) <span class="modifier"> = 0</span>;</code><p>Your <code class="classname">BBufferProducer</code> should implement this function to verify that the
proposed <span class="type">media_format</span> is suitable for the specified <code class="parameter">output</code>. If any fields
in the <code class="parameter">format</code> are wildcards, and you have a specific requirement, adjust
those fields to match your requirements before returning.</p><p>Return <code class="constant">B_OK</code> if the proposed format is acceptable; once you've done so,
the Media Kit will assume that any connection request made on output with
the specified format (after any changes you may have made) will succeed.</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_BAD_SOURCE</code></span></p></td><td><p><code class="parameter">output</code> isn't available.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_MEDIA_FORMAT</code></span></p></td><td><p><code class="parameter">format</code> isn't reasonable.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_FormatSuggestionRequested"></a>FormatSuggestionRequested()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">FormatSuggestionRequested</span>(<span class="methodparam"><span class="type">media_type </span><span class="parameter">type</span></span>,<br />                                           <span class="methodparam"><span class="type">int32 </span><span class="parameter">quality</span></span>,<br />                                           <span class="methodparam"><span class="type">media_format* </span><span class="parameter">format</span></span>) <span class="modifier"> = 0</span>;</code><p>You must implement <code class="methodname">FormatSuggestionRequested()</code> to return fill the buffer
pointed to by format that your producer is capable of emitting that meets
the desired type and quality requirements.</p><p>If your producer can work with a range of possible formats, let the
quality argument guide your selection. For example, you might choose to
use 10 fps for previews, and 60 fps interlaced 640x480 for full-quality
video.</p><p>If <code class="parameter">type</code> is a media class that your producer doesn't want to work with,
return <code class="constant">B_BAD_MEDIA_FORMAT</code>. If you're preapared to accept a wide range of
values for some specific field, set that field to the wildcard value (see
media_audio_format::wildcard()
and media_video_format::wildcard()
for more information.</p><p>Return <code class="constant">B_OK</code> if the
<code class="parameter">format</code> is successfully returned.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_GetLatency"></a>GetLatency()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetLatency</span>(<span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">outLatency</span></span>) <span class="modifier"> = 0</span>;</code><p>Implement this hook function to store, in <code class="parameter">outLatency</code>, the total amount of
latency your <code class="classname">BBufferProducer</code> incurs from receiving a buffer of data until
it reaches its ultimate destination.</p><p>Call <a class="link" href="BBufferProducer.html#BBufferProducer_FindLatencyFor" title="FindLatencyFor()"><code class="methodname">FindLatencyFor()</code></a>
on whatever outputs the data is being forwarded to,
add your own latency to the largest of those values, and return that
value.</p><p>The default implementation of <code class="methodname">GetLatency()</code> finds the maximum latency of
your currently-available outputs by iterating over them, and returns that
value in <code class="parameter">outLatency</code>; therefore, your implementation of this function may
simply need to call the inherited version of this function, then add your
own processing latency to the returned value.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The latency has been returned successfully.</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>Unable to calculate the latency.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_GetNextOutput"></a>GetNextOutput()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetNextOutput</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">cookie</span></span>,<br />                               <span class="methodparam"><span class="type">media_output* </span><span class="parameter">outOutput</span></span>) <span class="modifier"> = 0</span>;</code><p>Implement this function to return information about your available
outputs. The first time it's called for a new iteration loop, the value
pointed to by <code class="parameter">cookie</code> will be 0. Each
time <code class="methodname">GetNextOutput()</code> is called, you
should set it to some value that makes sense to you so you can keep track
of where in the iteration process the client is, but never set it to 0.</p><p>For each call to <code class="methodname">GetNextOutput()</code>,
including the first, you should return
one of your outputs that the client hasn't seen during the iteration loop
in <code class="parameter">outOutput</code>.</p><p>Once all outputs have been reported, you should return
<code class="constant">B_ERROR</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_HandleMessage"></a>HandleMessage()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">HandleMessage</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">message</span></span>,<br />                               <span class="methodparam"><span class="modifier">const </span><span class="type">void* </span><span class="parameter">data</span></span>,<br />                               <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>);</code><p>When your node derived from <code class="classname">BBufferProducer</code> receives a message on its
control port, you should handle it yourself if you know how, or dispatch
to each ancestor class in turn (starting with
<code class="classname">BBufferProducer</code>'s <code class="methodname">HandleMessage()</code>)
until one of the <code class="methodname">HandleMessage()</code>
implementations returns <code class="constant">B_OK</code>. If none of the inherited implementations of
this function returns <code class="constant">B_OK</code>, you should pass the message to
<a class="link" href="BMediaNode.html#BMediaNode_HandleBadMessage" title="HandleBadMessage()"><code class="methodname">BMediaNode::HandleBadMessage()</code></a>
to be dealt with.</p><p>Your port-listening thread should call <code class="methodname">HandleMessage()</code> to dispatch the
received data.</p><p>See also:
"<a class="xref" href="TheMediaKit_Overview_Introduction.html#TheMediaKit_AboutMultipleVirtualInheritance" title="About Multiple Virtual Inheritance">About Multiple Virtual Inheritance</a>"</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_LatencyChanged"></a>LatencyChanged()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">LatencyChanged</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">source</span></span>,<br />                            <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                            <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">newLatency</span></span>,<br />                            <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span></span>);</code><p>This hook function is called when a
<a class="link" href="BBufferConsumer.html" title="BBufferConsumer"><code class="classname">BBufferConsumer</code></a>
that's receiving data
from you determines that its latency has changed. It will call its
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SendLatencyChange" title="SendLatencyChange()"><code class="methodname">BBufferConsumer::SendLatencyChange()</code></a>
function, and in response, the Media
Server will call your <code class="methodname">LatencyChanged()</code> function.</p><p>The <code class="parameter">source</code> argument indicates your output that's involved in the
connection, and <code class="parameter">destination</code> specifies the input on the consumer to which
the connection is linked. <code class="parameter">newLatency</code> is the consumer's new latency. The
<code class="parameter">flags</code> are currently unused.</p><p>Override this function to implement whatever functionality you need to
adjust your own latency calculations to keep the data flowing smoothly.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_LateNoticeReceived"></a>LateNoticeReceived()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">LateNoticeReceived</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">whichSource</span></span>,<br />                                <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">howLate</span></span>,<br />                                <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">performanceTime</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called when a
<a class="link" href="BBufferConsumer.html" title="BBufferConsumer"><code class="classname">BBufferConsumer</code></a>
that's receiving data
from you determines that data is arriving late (when the
<a class="link" href="BBufferConsumer.html#BBufferConsumer_NotifyLateProducer" title="NotifyLateProducer()"><code class="methodname">BBufferConsumer::NotifyLateProducer()</code></a>
function is called); the exact
degree to which your buffers are late is specified by the <code class="parameter">howLate</code>
argument. Your implementation of this function should take whatever steps
are necessary to correct the problem, either by asking nodes upstream
from you to deliver buffers earlier, dropping buffers, or other
appropriate actions, depending on the current run mode.</p><p>The <code class="parameter">performanceTime</code> argument
specifies the performance time at which the
notification was sent.</p><p>See also:
<a class="link" href="BMediaNode.html#BMediaNode_RunMode" title="RunMode(), SetRunMode()"><code class="methodname">BMediaNode::RunMode()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_PrepareToConnect"></a>PrepareToConnect()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">PrepareToConnect</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">whichSource</span></span>,<br />                                  <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">whichDestination</span></span>,<br />                                  <span class="methodparam"><span class="type">media_format* </span><span class="parameter">format</span></span>,<br />                                  <span class="methodparam"><span class="type">media_source* </span><span class="parameter">outSource</span></span>,<br />                                  <span class="methodparam"><span class="type">char* </span><span class="parameter">outName</span></span>) <span class="modifier"> = 0</span>;</code><p>The <code class="methodname">PrepareToConnect()</code> hook is called before a new connection between the
source <code class="parameter">whichSource</code> and the destination <code class="parameter">whichDestination</code> is established,
in order to give your producer one last chance to specialize any
wildcards that remain in the format (although by this point there
shouldn't be any, you should check anyway).</p><p>Your implementation should, additionally, return in <code class="parameter">outSource</code> the source
to be used for the connection, and should fill the <code class="parameter">outName</code> buffer with
the name the connection will be given; the consumer will see this in the
<span class="code"><code class="varname">outInput</code>-&gt;<code class="varname">name</code></span>
argument specified to
<a class="link" href="BBufferConsumer.html#BBufferConsumer_Connected" title="Connected()"><code class="methodname">BBufferConsumer::Connected()</code></a>.
If your node doesn't care what the name is, you can leave the <code class="parameter">outName</code>
untouched.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Your <a class="link" href="BBufferProducer.html#BBufferProducer_Connect" title="Connect()"><code class="methodname">Connect()</code></a>
function may return a different <span class="type">media_source</span> value in
<code class="parameter">outOutput</code>'s source field than the one
specified as the <code class="parameter">source</code> argument to
this function. One reason you might do this is if you implement one
<span class="type">media_source</span> to accept connection requests, then create a new
<span class="type">media_source</span> to actually handle each connection.</p></div></div></div><p>Return <code class="constant">B_OK</code> if the connection process should proceed, or an appropriate
error code if something's wrong.</p><p>If you return <code class="constant">B_OK</code>, the consumer's
<a class="link" href="BBufferConsumer.html#BBufferConsumer_Connected" title="Connected()"><code class="methodname">Connected()</code></a>
function will be called,
to let it know that a new connection is being established. Finally, the
producer's <code class="methodname">Connect()</code> function is called to complete the exchange.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_ProducerType"></a>ProducerType()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">media_type </span><span class="methodname">ProducerType</span>();</code><p>Returns the <span class="type">media_type</span> of the media data produced by the node.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_ProposeFormatChange"></a>ProposeFormatChange()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">ProposeFormatChange</span>(<span class="methodparam"><span class="type">media_format* </span><span class="parameter">format</span></span>,<br />                             <span class="methodparam"><span class="modifier">const </span><span class="type">media_destination&amp; </span><span class="parameter">forDestination</span></span>);</code><p>Call this function to determine whether or not the destination
<code class="parameter">forDestination</code> is prepared to accept
buffers in the specified <code class="parameter">format</code>.
This function can be especially useful if you want to test various
formats to select the best compatible format during a hookup request in
which the requested format contains wildcards.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The proposed format is acceptable to the destination.</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>The proposed format is unacceptable, or an error
occurred in querying the destination node.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_SendBuffer"></a>SendBuffer()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SendBuffer</span>(<span class="methodparam"><span class="type"><span class="classname">BBuffer</span>* </span><span class="parameter">buffer</span></span>,<br />                    <span class="methodparam"><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>);</code><p>Call this function to send a buffer of media data to the specified
<code class="parameter">destination</code>, which must already be connected to one of your outputs. This
is how your <code class="classname">BBufferProducer</code> object will send data downstream to
<a class="link" href="BBufferConsumer.html" title="BBufferConsumer"><code class="classname">BBufferConsumer</code></a>s
to which it's connected.</p><p>It's your responsibility to ensure that the buffer's header and the data
contained in the buffer itself are valid, although
<code class="methodname">SendBuffer()</code> will
automatically fill out the following header fields for you:</p><ul class="itemizedlist"><li><p><code class="varname">buffer</code></p></li><li><p><code class="varname">for_id</code></p></li><li><p><code class="varname">change_tag</code></p></li></ul><p>In particular, be sure that if you're outputting video buffers you set
the <span class="type">media_video_buffer</span> to describe the video properly. If you don't,
things will go badly for you.</p><p>You can obtain a buffer to fill and send by calling
<a class="link" href="BBufferConsumer.html#BBufferConsumer_RequestAdditionalBuffer" title="RequestAdditionalBuffer()"><code class="methodname">BBufferConsumer::RequestAdditionalBuffer()</code></a>
on a <a class="link" href="BBufferConsumer.html" title="BBufferConsumer"><code class="classname">BBufferConsumer</code></a> that you own (and
that's okay to use for buffers going to the specified destination).</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The buffer was sent without error.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>An error occurred sending the buffer.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_SendDataStatus"></a>SendDataStatus()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SendDataStatus</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">status</span></span>,<br />                        <span class="methodparam"><span class="type">media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                        <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">atTime</span></span>);</code><p>Call this function to inform the specified <code class="parameter">destination</code> whether or not
there's data available from your producer node. Specify the appropriate
status flag as the <code class="parameter">status</code> argument, and the time at which the status
takes effect as the atTime argument.</p><p>Possible values for the status argument are:</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_DATA_NOT_AVAILABLE</code></span></p></td><td><p>There aren't any buffers ready for the destination.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DATA_AVAILABLE</code></span></p></td><td><p>There are buffers ready for the destination.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_PRODUCER_STOPPED</code></span></p></td><td><p>The producer has stopped.</p></td></tr></tbody></table><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The status update was sent without error.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>The status update couldn't be delivered.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_SetBufferGroup"></a>SetBufferGroup()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SetBufferGroup</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">forSource</span></span>,<br />                                <span class="methodparam"><span class="type"><span class="classname">BBufferGroup</span>* </span><span class="parameter">group</span></span>) <span class="modifier"> = 0</span>;</code><p>When a client wants a specific
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
to be used for a given output
<code class="parameter">forSource</code>, it will call this function. You
should remember the <code class="parameter">group</code> and
use it for all requests for buffers to send on the output forSource (and
for no other outputs, unless the client explicitly requests you do so by
calling <code class="methodname">SetBufferGroup()</code> for another output source).</p><p>If your <code class="classname">BBufferProducer</code> goes away, or the connection is broken, delete
the <a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
object.</p><p>If <code class="parameter">group</code> is <code class="constant">NULL</code>,
you should use whatever
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
you wish after disposing of the previous group.</p><p>It's okay to pass <code class="parameter">group</code> on to another node upstream from your
<code class="classname">BBufferProducer</code> if your <code class="classname">BBufferProducer</code> only passes along buffers it
receives in its processing loop; in that case, you're not really the
owner of the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>,
unless you pass <code class="constant">true</code> for <code class="parameter">willReclaim</code> in the
call to
<a class="link" href="BBufferConsumer.html#BBufferConsumer_SetOutputBuffersFor" title="SetOutputBuffersFor()"><code class="methodname">BBufferConsumer::SetOutputBuffersFor()</code></a>.</p><p>Return <code class="constant">B_OK</code> if the buffer group is set without incident; otherwise,
return an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_SetInitialLatency"></a>SetInitialLatency()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetInitialLatency</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">initialLatency</span></span>,<br />                       <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span></span>) <span class="modifier"> = 0</span>;</code><p>If your node has additional startup latency imposed by the signal from
which its buffers are constructed, you should call <code class="methodname">SetInitialLatency()</code> to
specify the maximum possible latency that can be added by this delay.
<code class="parameter">initialLatency</code> should be the maximum latency, in microseconds, that might
occur.</p><p>One situation in which this occurs is for <acronym class="acronym">TV</acronym> capture card nodes. An
<acronym class="acronym">NTSC</acronym>
television signal broadcasts a new field about every sixtieth of a
second, which means that if your node is started partway through one
field being received, you might have to wait as long as a sixtieth of a
second for the first complete frame to arrive. So the maximum latency in
this situation is a sixtieth of a second.</p><p>Setting the initial latency correctly can prevent consumers from having
problems synchronizing with your node, and can improve performance.</p><p><code class="parameter">flags</code> should be 0 for now; there are
no values defined yet.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_SetPlayRate"></a>SetPlayRate()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SetPlayRate</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">numerator</span></span>,<br />                             <span class="methodparam"><span class="type">int32 </span><span class="parameter">denominator</span></span>);</code><p>This function is called to tell the producer to resample the data rate by
the specified factor. Specifying a value of 1 (ie, <code class="parameter">numerator</code>/<code class="parameter">denominator</code>
= 1) indicates that the data should be output at the same playback rate
that it comes into the node at. The format of the data should be
unchanged.</p><p>For example, if you're playing a sound at 48 kHz, and you receive a call
to <code class="methodname">SetPlayRate()</code> with a
<code class="parameter">numerator</code> of 2 and a <code class="parameter">demoninator</code> of 1 (double
speed), you should resample so that you move twice as fast through the
source data while keeping the output rate constant. You might do this by
doing a brute-force resample to 24 kHz (which would result in twice the
data rate) or do time-compression (which would retain the pitch).</p><p>As another example, if you're playing video at 30 frames per second, and
your <code class="methodname">SetPlayRate()</code> function is called with a ratio of 1:2 specified (half
speed), you should continue sending 30 frames per second, but you need to
arrange for the playback to look like half-speed. A reasonable way to do
this would be to send each frame twice (re-time-stamped and buffered
internally, if necessary), which would result in the desired half-speed
appearance.</p><p>Return <code class="constant">B_OK</code> if the sampling rate is changed; otherwise, return an error.
It's okay to return an error if you don't support varying sampling
rates—the Media Kit won't hold that against you.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_VideoClippingChanged"></a>VideoClippingChanged()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">VideoClippingChanged</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">media_source&amp; </span><span class="parameter">forSource</span></span>,<br />                                      <span class="methodparam"><span class="type">int16 </span><span class="parameter">numShorts</span></span>,<br />                                      <span class="methodparam"><span class="type">int16* </span><span class="parameter">clipData</span></span>,<br />                                      <span class="methodparam"><span class="modifier">const </span><span class="type">media_video_display_info&amp; </span><span class="parameter">display</span></span>,<br />                                      <span class="methodparam"><span class="type">int32* </span><span class="parameter">outFromChangeTag</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called when a client wants your <code class="classname">BBufferProducer</code> to
output video data clipped to a particular region. Your producer must
remember this clipping region and apply it to all video data you produce,
without altering any bytes outside the region in any buffers sent through
the source <code class="parameter">forSource</code>.</p><p>Before your implementation of <code class="methodname">VideoClippingChanged()</code> returns, you should
set the value pointed to by <code class="parameter">outFromChangeTag</code> to the change tag value at
which the clipping will take effect, so the client will know what buffers
it can expect to have the requested clipping. This can be done easily by
adding the following line to your implementation:</p><pre class="programlisting example cpp">*<code class="parameter">outFromChangeTag</code> = <code class="methodname">UpdateChangeTag</code>();</pre><p>You can use the
<a class="link" href="BBufferProducer.html#BBufferProducer_ClipDataToRegion" title="ClipDataToRegion()"><code class="methodname">ClipDataToRegion()</code></a>
function to convert the data in
<code class="parameter">clipData</code> into an actual
<a class="link" href="BRegion.html" title="BRegion"><code class="classname">BRegion</code></a>
if that's a better format for you to work
with. If you do, keep in mind that <code class="parameter">numShorts</code> is the actual number of
<span class="type">int16</span> values in the array specified by
<code class="parameter">clipData</code>, while
<a class="link" href="BBufferProducer.html#BBufferProducer_ClipDataToRegion" title="ClipDataToRegion()"><code class="methodname">ClipDataToRegion()</code></a>
requires the number of bytes of data in the array; be sure to multiply
<code class="parameter">numShorts</code> by
<span class="code"><code class="function">sizeof</code>(<span class="type">int16</span>)</span>.</p><p>The <span class="type">media_video_display_info</span> structure referred to by display indicates
the format of the video display onto which the video is being displayed;
this lets you know what color space, screen size, and so forth is in use
on the video display, so your producer can render properly.
<code class="methodname">VideoClippingChanged()</code> is called not only when clipping changes, but when
the configuration of the display changes as well. Your producer must
abide by this starting at the specified change count.</p><p>See  "<a class="xref" href="BBufferProducer_Overview.html#BBufferProducer_Overview_VideoClipping" title="Video Clipping">Video Clipping</a>"
for information on the format of the clip data.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_Constants"></a>Constants</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Constants_ClippingDataFormats"></a><a id="B_CLIP_SHORT_RUNS"></a>
Clipping Data Formats</h4></div></div></div><a id="id1127229" class="indexterm"></a><p>Declared in: <code class="filename">media/BufferProducer.h</code></p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_CLIP_SHORT_RUNS</code>.</span></p></td><td><p>Clipping is encoded using runs of shorts.</p></td></tr></tbody></table><p>This value defines the only clipping format currently supported by
<code class="classname">BBufferProducer</code>. Note that because this constant is a member of the
<code class="classname">BBufferProducer</code> class, if you need to access it from other classes, you
must code it as
<span class="code"><code class="classname">BBufferProducer</code>::<code class="constant">B_CLIP_SHORT_RUNS</code></span>.
See "<a class="xref" href="BBufferProducer_Overview.html#BBufferProducer_Overview_VideoClipping" title="Video Clipping">Video Clipping</a>"
for a description of this format.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferProducer_Constants_suggestion_quality"></a><a id="B_ANY_QUALITY"></a>
<a id="B_LOW_QUALITY"></a>
<a id="B_MEDIUM_QUALITY"></a>
<a id="B_HIGH_QUALITY"></a>
suggestion_quality</h4></div></div></div><a id="id1127331" class="indexterm"></a><a id="id1127340" class="indexterm"></a><a id="id1127349" class="indexterm"></a><a id="id1127358" class="indexterm"></a><p>Declared in: <code class="filename">media/BufferProducer.h</code></p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_ANY_QUALITY</code></span></p></td><td><p>Any quality.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_LOW_QUALITY</code></span></p></td><td><p>A low quality level (10).</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIUM_QUALITY</code></span></p></td><td><p>Medium quality level (50).</p></td></tr><tr><td><p><span class="term"><code class="constant">B_HIGH_QUALITY</code></span></p></td><td><p>High quality level (100).</p></td></tr></tbody></table><p>Quality values you can use when you don't want to have to come up with
one on your own.</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BBufferGroup.html">BBufferGroup</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BContinuousParameter.html">BContinuousParameter</a> </div><div id="footerB"><div id="footerBL"><a href="BBufferGroup.html" title="BBufferGroup"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BContinuousParameter.html" title="BContinuousParameter"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
