<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 4: 1999</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume4.html" title="Volume 4: 1999" /><link rel="prev" href="Issue4-23.html" title="Issue 4-23, June 9, 1999" /><link rel="next" href="Issue4-25.html" title="Issue 4-25, June 23, 1999" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue4-23.html" title="Issue 4-23, June 9, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue4-25.html" title="Issue 4-25, June 23, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 4: 1999</div></div><div id="headerB">Prev: <a href="Issue4-23.html">Issue 4-23, June 9, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-25.html">Issue 4-25, June 23, 1999</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue4-24"></a>Issue 4-24, June 16, 1999</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Marketing4-24"></a>Be is Open for Business!</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Dave</span> <span class="surname">Johnson</span></span></div></div></div><p>
Developers, here's the word: It's time to get your BeOS product finished
and into a box. Some of our third-party BeOS applications are starting to
sell in quantity, and you probably want to get in on that. This is
happening even before the upcoming R4.5 retail channels &amp; marketing push.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790156"></a>Starting to Sell</h3></div></div></div><p>
Starting this summer we'll have new customer-oriented BeOS packaging,
flyers, posters, and other materials. We'll be advertising and getting
the retail outlets in place to deliver BeOS and third-party products to
buyers.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790171"></a>BeDepot, As Great As It Is, Is Only As Great As It Is</h3></div></div></div><p>
BeDepot is a great place to sell your BeOS product, especially to users
who buy a new computer that ships with BeOS pre-installed. But BeDepot
does not sell your product on retail store shelves. You've got to get the
product into a box for that.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790187"></a>Distribution Channels in Place</h3></div></div></div><p>
We're doing our part. We've been working hard to get distribution
channels in place to handle BeOS retail store orders. Starting this
summer some opportunities to sell through major chains may be available
to you, but your product must be finished and in a box.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790202"></a>BeOS is Worldwide</h3></div></div></div><p>
Our retail channel sales are international. In Europe Stephan Landier
&lt;slandier@beeurope.com&gt; has been working hard for you. He needs products
with manuals and boxes in English, German and French. In Japan Takeaki
Akahoshi &lt;akahoshi@be.com&gt; is looking for products with Japanese boxes
and manuals, and which support our Japanese input method.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790220"></a>"Would You Like Fries with That, Sir?"</h3></div></div></div><p>
In case you missed it, the message of this article is that Be has been
working to establish retail store sales to end users for sales of R4.5
with the intention of enabling you to make money with your BeOS products.
These resellers and distributors are asking for additional third-party
products to recommend to their BeOS customers. "Would you like fries with
that, sir?" It's part of the retail equation—resellers want add-ons to
sell at time of purchase and customers want those products to use. Will
it be YOUR product? Only if you finish it and get it into a box.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790231"></a>The Green Field Effect</h3></div></div></div><p>
We're beyond the "chicken-and-egg" paradox, where the conventional wisdom
had it that there was a need for BeOS applications to bring in customers
and customers to bring in the applications. We're now arriving at the
point where there is serious customer and reseller interest in the BeOS,
but there aren't enough boxed products to satisfy customer demand. This
is great news for you, the developer. It's the beginning of the expected
"green field" effect for the early (smart) BeOS developers, where good
products in good boxes along side the BeOS can enjoy good store sales
with little competition. This helps Be and it helps you. It helps us
because third-party products help persuade even more customers to
purchase BeOS. It helps you because the customers who buy the BeOS want
third- party products to use. Assuming, of course, that they are finished
and in a box.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790242"></a>That's Boxes - not Jewel Cases</h3></div></div></div><p>
To sell in a retail store your product must be in a box. Visit a few
computer stores and look at the packaging used by different software
companies, if you need ideas. The box must have a UPC bar-code,
consisting of your manufacturer ID and a product number. The Uniform Code
Council is the organization that assigns manufacturer ID numbers for use
in UPC retail bar codes. Check the following web site to arrange to get
your manufacturer ID: <a class="ulink" href="http://www.uc-council.org/">http://www.uc-council.org/</a>. A company that
provides software for printing bar codes, as well as good general bar
code info is at <a class="ulink" href="http://www.mecsw.com/">http://www.mecsw.com/</a>.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790272"></a>Packaging Tips for BeOS-By-Night Developers</h3></div></div></div><p>
Provide end-user-oriented copy on the back listing BENEFITS. Customers
don't care what the product is called and—you'll be surprised to know
-- their interest is not so much what the product is. Customers are
selfish. They want to know WHAT'S IN IT FOR THEM. They want to know how
using this product benefits them, what they can DO with it. Here's an
example:
</p><p>
"The BeBop bop program is a utility that will bop your hard drive seven
times a day. It is the only bop program that has a special symbop doopap
doobopper."
</p><p>
The customer doesn't care. But—the same information put a different
way will work wonders:
</p><p>
"With BeBop your hard drive is bopped clean so often that you'll never
worry about a bop problem again. Our unique symbop doopap doobopper
ensures swift debopping action."
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790307"></a>Build It and They Will Come?</h3></div></div></div><p>
ADVERTISE. Whether you're selling at BeDepot or in stores people aren't
likely to purchase your product if they don't know about it. It just
ain't so that if you build it they will come. That worked in a movie, but
the likelihood of selling to customers who don't know about your product
is about as high as the likelihood of a dead pitcher stepping out of a
cornfield into your yard. You can wait for that to happen or you can
advertise.
</p><p>
BeOS news web sites are visited by thousands of BeOS users and their ad
rates are reasonable. You should place ads at these sites to build name
recognition and mind share for your products. Eventually these BeOS users
will find their way to BeDepot or stores to purchase your products.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790334"></a>Engineers Are Not Regular People (and They Don't Buy Stuff)</h3></div></div></div><p>
I think it's important to understand that you and I and most of the
people we know are computer sophisticates. We know more about computers
and the industry than the people we're selling to and this has major
implications. We probably don't understand what the average end-user,
cruising an aisle in a store in Ohio, sees or thinks or wants or needs.
</p><p>
I just finished reading the book, "Why We Buy," by Paco Underhill
<a class="ulink" href="http://www.amazon.com/exec/obidos/ASIN/0684849135">http://www.amazon.com/exec/obidos/ASIN/0684849135</a>. I
strongly recommend this book to anyone selling a product. It's about a
consulting firm that sends people out to follow customers around in
stores to see what they actually do. It contains example after example of
what happens when marketing people come up with "brilliant" ideas without
understanding their customers, and describes what happens when the
customer is confronted with these examples of marketing foolishness in a
store.
</p><p>
Here's a good example from the book: Some casino hotels don't provide
lobby seating, hoping to drive people into the casino. Instead, this
practice results in gloomy lobbies where incoming guests are confronted
with lots of tired, unhappy people (the losers) sitting on the floor
along the edges of the lobby waiting for their tour vans and buses. This
book will help adjust your brain around how to think about retail
channels and end-users and about using marketing research. So will one of
my previous articles, "<a class="xref" href="Issue3-44.html#Marketing3-44" title="Testing and Tracking">Testing and Tracking</a>."
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-24"></a>Be Engineering Insights: Kernel Programming Part 2: Device Drivers</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Victor</span> <span class="surname">Tsou</span></span></div></div></div><p>
The kernel imposes and enforces rules to keep individual applications
from interfering with other applications or bringing down the entire
system. For example, a program can create windows and send messages to
other programs, but it can't write into the address space of another
program. The kernel makes sure everybody plays fair and cleans up the
mess when accidents occur.
</p><p>
Sometimes this hand-holding gets in the way. When it does, device drivers
will let you circumvent the kernel's protections. Remember, though, that
drivers run with the same privileges as the kernel, so they must be
careful to avoid disrupting system stability. Bugs are always more
serious in kernel space since driver bugs can bring down the entire
system. Good design dictates that device drivers should be as short as
possible, with as much code as is feasible relegated to user space.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790433"></a>devfs</h3></div></div></div><p>
The kernel manages device drivers through devfs, the file system mounted
at <code class="filename">/dev</code> during the boot process.
Communication between user space and
drivers occurs through entries published by the driver in the
<code class="filename">/dev</code>
hierarchy. Therefore, the basic primitives for interacting with drivers
map to basic file operations: <code class="function">open</code>, <code class="function">read</code>,
<code class="function">write</code>, <code class="function">readv</code>, <code class="function">writev</code>,
<code class="function">ioctl</code>, and <code class="function">close</code>.
</p><p>
Drivers tell devfs which entries they want to appear in
<code class="filename">/dev</code> through a
mechanism known as "publishing." Devfs publishes drivers as needed.
Typically, this means it publishes drivers the first time a program
iterates through the directory entries for a subdirectory in
<code class="filename">/dev</code>. The
kernel knows which drivers publish entries in any given portion of the
<code class="filename">/dev</code>
hierarchy through a simple mapping mechanism: binaries appear in
<code class="filename">/boot/beos/system/add-ons/kernel/drivers/dev</code>
in locations that correlate
to their published entries in <code class="filename">/dev</code>.
For example, the atapi driver publishes drivers in
<code class="filename">/dev/disk/ide/atapi</code>,
so its binary appears in
<code class="filename">/boot/beos/system/add-ons/kernel/drivers/dev/disk/ide/atapi</code>.
</p><p>
Actually, this is a lie. Since drivers may publish entries in more than
one location in the /dev hierarchy, the entries in
<code class="filename">/boot/beos/system/add-ons/kernel/drivers/dev</code>
are typically symbolic links
to the actual binaries which live in
<code class="filename">/boot/beos/system/add-ons/kernel/drivers/bin</code>.
Of course, the same
discussion applies to user-installed drivers in
<code class="filename">/boot/home/config/add-ons/kernel/drivers/...</code>
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790568"></a>Exported Symbols</h3></div></div></div><p>
The driver entry points are the scaffolding required for communication
with devfs:
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">init_hardware</code>(<span class="type">void</span>);
</pre><p>
This function is called when the system is booted, allowing the driver to
detect and reset the hardware. The function should return <code class="constant">B_OK</code> if the
initialization is successful or an error code if it is not. If the
function returns an error, the driver will not be used.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">init_driver</code>(<span class="type">void</span>);
</pre><p>
Devfs loads and unloads drivers on an as-needed basis. This function is
called when the driver is loaded into memory, allowing it to allocate any
system resources it needs to function properly.
</p><pre class="programlisting c">
<span class="type">void</span> <code class="function">uninit_driver</code>(<span class="type">void</span>);
</pre><p>
Conversely, this function is called when the driver is unloaded from
memory, allowing it to clean up after itself.
</p><pre class="programlisting c">
<span class="type">const char **</span><code class="function">publish_devices</code>(<span class="type">void</span>);
</pre><p>
Devfs calls this hook to discover the names, relative to
<code class="filename">/dev</code>, of the
driver's supported devices. The driver should return a <code class="constant">NULL</code>-terminated
array of strings enumerating the list of installed devices supported by
the driver. For example, a network device driver might return the
following:
</p><pre class="programlisting c">
<span class="type">static char *</span><code class="varname">devices</code>[] = {
    "net/ether",
    NULL
};
</pre><p>
Devfs will then create the pseudo-file
<code class="filename">/dev/net/ether</code>, through which user
level programs can access the driver.
</p><p>
Only one instance of the driver will ever be loaded, so it must be
prepared to gracefully field requests for multiple devices. Typically,
this is handled by exporting a separate entry for each device present in
the system. For example, the serial driver exports
<code class="filename">/dev/ports/serial1</code>,
<code class="filename">/dev/ports/serial2</code>,
and so on, up to the number of serial ports present
in the system.
</p><pre class="programlisting c">
<span class="type">device_hooks *</span><code class="function">find_device</code>(<span class="type">const char *</span><code class="parameter">name</code>);
</pre><p>
When an exported <code class="filename">/dev</code>
entry is accessed, devfs calls a set of driver hook
functions to fulfill the request. <code class="function">find_device()</code> reports the hooks for the
entry name in a <span class="type">device_hooks</span> structure. The structure, detailed in
<code class="filename">be/drivers/Drivers.h</code>,
is composed of function pointers, described below
in the section "Device Hooks."
</p><pre class="programlisting c">
<span class="type">int32</span> <code class="varname">api_version</code>;
</pre><p>
This variable defines the API version to which the driver was written; it
should always be set to <code class="constant">B_CUR_DRIVER_API_VERSION</code> (whose value, naturally,
changes with the driver API).
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id790804"></a>Device Hooks</h3></div></div></div><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">open_hook</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">uint32</span> <code class="parameter">flags</code>, <span class="type">void **</span><code class="parameter">cookie</code>)
</pre><p>
This hook is called when a program opens one of the entries exported by
the driver. The name of the entry is passed in <code class="parameter">name</code>,
along with the <code class="parameter">flags</code>
passed to the <code class="function">open()</code> call. <code class="parameter">cookie</code>
is a pointer to a region of memory
large enough to hold a single pointer. This can be used to store state
information associated with the open instance; typically the driver
allocates a chunk of memory as large as it needs and stores a pointer to
that memory in this area.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">close_hook</code>(<span class="type">void **</span><code class="parameter">cookie</code>)
</pre><p>
This hook is called when an open instance of the driver is closed. Note
that there may still be outstanding transactions on this instance in
other threads, so this function should not be used to reclaim
instance-wide resources. Blocking drivers must unblock ongoing
transactions when the close hook is called.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">free_hook</code>(<span class="type">void **</span><code class="parameter">cookie</code>)
</pre><p>
This hook is called after an open instance of the driver has been closed
and all the outstanding transactions have completed. This is the proper
place to perform uninitialization activities.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">read_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">off_t</span> <code class="parameter">position</code>, <span class="type">void *</span><code class="parameter">data</code>, <span class="type">size_t *</span><code class="parameter">len</code>)
</pre><p>
This hook handles read requests on an open instance of the device. The
function reads <code class="parameter">*len</code> bytes from offset
<code class="parameter">position</code> to the memory buffer data.
Precisely what this means is device specific. The driver should set <code class="parameter">*len</code>
to the number of bytes processed and return either <code class="constant">B_OK</code> or an error code,
as appropriate.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">readv_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">off_t</span> <code class="parameter">position</code>,
<span class="type">const struct iovec *</span><code class="parameter">vec</code>, <span class="type">size_t</span> <code class="parameter">count</code>, <span class="type">size_t *</span><code class="parameter">numBytes</code>)
</pre><p>
This is the scatter-gather equivalent of read. The function is passed an
array of count iovec entries describing address/length pairs to put data
read starting at position. As with read_hook, the function should set
<code class="parameter">*numBytes</code> to the number of bytes processed and return an appropriate
error code.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">write_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">off_t</span> <code class="parameter">position</code>,
<span class="type">void *</span><code class="parameter">data</code>, <span class="type">size_t</span> <code class="parameter">len</code>)

<span class="type">status_t</span> <code class="function">writev_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">off_t</span> <code class="parameter">position</code>,
<span class="type">const struct iovec *</span><code class="parameter">vec</code>, <span class="type">size_t</span> <code class="parameter">count</code>, <span class="type">size_t *</span><code class="parameter">numBytes</code>)
</pre><p>
Conversely, these hooks handle write requests. Again, the meaning of
"write" is device specific.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">control_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">uint32</span> <code class="parameter">op</code>, <span class="type">void *</span><code class="parameter">data</code>, <span class="type">size_t</span> <code class="parameter">len</code>)
</pre><p>
This hook handles <code class="function">ioctl()</code> requests. The control hook provides a means of
instructing the driver to perform actions that don't map directly to
<code class="function">read()</code> or <code class="function">write()</code>. It is passed
the <code class="parameter">cookie</code> for the open instance as well
as a command code <code class="parameter">op</code> and parameters
<code class="parameter">data</code> and <code class="parameter">len</code> supplied by the caller.
<code class="parameter">data</code> and <code class="parameter">len</code>
have no intrinsic relation; they are simply two arguments to
<code class="function">ioctl()</code>. The interpretation of the command codes and the parameter
information is defined by the driver. Common command codes can be found
in <code class="filename">be/drivers/Drivers.h</code>.
</p><p>
NOTE: <code class="parameter">len</code> is only valid when
<code class="function">ioctl()</code> is called from user space; the
kernel implementation of <code class="function">ioctl</code> always passes
0 in the <code class="parameter">len</code> field.
</p><pre class="programlisting c">
<span class="type">status_t</span> <code class="function">select_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">uint8</span> <code class="parameter">event</code>, <span class="type">uint32</span> <code class="parameter">ref</code>,
                                        <span class="type">selectsync *</span><code class="parameter">sync</code>);

<span class="type">status_t</span> <code class="function">deselect_hook</code>(<span class="type">void *</span><code class="parameter">cookie</code>, <span class="type">uint8</span> <code class="parameter">event</code>,
                                        <span class="type">selectsync *</span><code class="parameter">sync</code>);
</pre><p>
These hooks are for future use; their corresponding entries in the
<span class="type">device_hooks</span> structure should be set to <code class="constant">NULL</code> for now.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791328"></a>Thread Awareness</h3></div></div></div><p>
The following rules apply for any given open instance of a driver:
</p><div class="orderedlist"><ol><li><p>
<code class="function">open()</code> will be called first, and no other hooks will be called
until it has completed.
</p></li><li><p>
<code class="function">close()</code> may be called while there are pending
<code class="function">read</code>/<code class="function">readv</code>/<code class="function">write</code>/<code class="function">writev</code>/<code class="function">ioctl</code>
commands. Again, blocking drivers must
unblock any outstanding transactions. Calls to
<code class="function">read</code>/<code class="function">readv</code>/<code class="function">write</code>/<code class="function">writev</code>/<code class="function">ioctl</code>
may occur after the <code class="function">close()</code> hook is
called. The driver should return failure in response to any such
requests.
</p></li><li><p>
<code class="function">free()</code> is not called until all the pending transactions for an open
instance have completed.
</p></li><li><p>
Multiple threads may be accessing the
<code class="function">read</code>/<code class="function">readv</code>/<code class="function">write</code>/<code class="function">writev</code>/<code class="function">ioctl</code>/<code class="function">close</code>
hooks of the driver
simultaneously, even for a single open instance, so you must be
careful to lock as needed.
</p></li></ol></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791447"></a>Sample Code</h3></div></div></div><p>
I've put together a sample device driver that you can find at
&lt;ftp://ftp.be.com/pub/samples/drivers/digit.zip&gt;. After you build it, you
should place the binary in
<code class="filename">~/config/add-ons/kernel/drivers/bin</code>. You
should also create a link to it in
<code class="filename">~/config/add-ons/kernel/drivers/dev/misc</code>, i.e.:
</p><pre class="screen">
mkdir -p ~/config/add-ons/kernel/drivers/dev/misc
cd ~/config/add-ons/kernel/drivers/dev/misc
ln -s ../../bin/digit .
</pre></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-24-2"></a>Be Engineering Insights: The Legend of the Buggy Library</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Adam</span> <span class="surname">Haberlach</span></span></div></div></div><p>
This is the story of the Be Bugmaster. He inherited his duties from
Bugmaster Ronzilla, who left bugs to sell used chariots. Ronzilla
inherited the bugs from The Great Ming, who went on to the Empire of the
northwest. And so it has been, throughout history.
</p><p>
The Bugmaster is charged with the upkeep of the great library of bugs.
This library is used to track problems in BeOS, both current and past, in
order that they may be fixed. This makes BeOS strong.
</p><p>
It came to the new Bugmaster as a library that worked—barely. It
allowed users and engineers to enter bugs into the library and it allowed
engineers to comment upon them, track them, and eventually mark them
fixed. And it usually only burned down twice a day. It came with great
plans. It was to move from a machine running that "Operating System"
known as Mac OS to a machine running that other "Operating System" known
as NT. It was to house the library in a new building, one which would not
burn. It would rely on a strange language, "Rope with Loop" for
communication. It was to use a new dialect of the magic which brought
information to the masses, which would do more then ever before.
</p><p>
Alas, that was not to be. There were problems between that new library on
that new "Operating System." There were things that simply could not be
done. Things which must be done. Simple things that any database should
have been able to do, actually. The dialect was found to be faulty. It
could not handle phrases of longer than 255 characters, a grave
limitation indeed.
</p><p>
Thus, the great hunt began. Many great libraries were rounded together.
There was the mighty Oracle, which was judged too expensive, and whose
setup time would be longer than the life of the library, and possibly of
the Bugmaster himself. There was the sleek Sybase ASE, who spoke a
language unlike that of the Bugmaster. There was <span class="application">MiniSQL</span>
and <span class="application">MySQL</span>, both
of which had many followers, but were strange and untrusted by the
Bugmaster. In the end, the keeper of the bugs chose to call upon
<span class="application">PostgreSQL</span>, a friend from his past, which he knew was up to the task at
hand. But the previous language would not work with the new library --
and a new one had to be chosen. That language was PHP, which was similar
to the rope language, but faster and with more features.
</p><p>
Now the Bugmaster called upon the great gods of free software. Not free
as in speech, but free as in beer: the Bugmaster, from his school days
living in a fraternity, has a keen understanding of the value of beer and
the money which backs it. The gods of Debian Linux were called down and
asked to push aside the "Operating System" which had infested the
machine. They had to be called down three times, in fact, for they seemed
to have trouble settling into their accommodations. The gods of Debian
eventually seemed to be pleased in their new surroundings, and took
quickly to their new wards, <span class="application">Apache</span>
and <span class="application">PostgreSQL</span>.
</p><p>
A great translation project was begun. The Bugmaster spent weeks perusing
the magical incantations which had kept the old library together, all the
while rebooting it as necessary. Mountains were climbed, great battles
were fought. Large scripts were run with the help of the Master of Webs
in order to get several years of bugs from the old library into the new.
The Bugmaster spent a lot of time listening to techno music and typing
arcane commands into terminal windows, dead to the world, knowing that he
was putting his days of hearing cries of "mos-eisley is down again"
behind him.
</p><p>
And one day, it was judged that the new library was ready. Its doors
opened. During the first day, all the books from the first library were
hurriedly brought forth, transcribed, and entered into their new places.
At the end of that day, all was good (except for a few features). Backup
procedures were created. Those things that had been missing during the
grand opening were added. Many visitors cried that they could not find
their bugs, but this was not to be helped, for there were things which
could not be disclosed, and no simple way to discern different
disclosures. And thus far, although the doors have been closed
occasionally, and the village has suffered a power outage, the library of
the bugs has not burned.
</p><p>
In short: The old system used <span class="application">Filemaker Pro</span> as the back end database,
<span class="application">Lasso</span> as a web &lt;-&gt; database interface,
and <span class="application">WebSTAR</span> as the web server. On
Mac OS, of all things. At the end, it was only crashing 2-3 times a day.
The new system uses <span class="application">PostgreSQL</span> as a back end, PHP3 as a database
interface, and <span class="application">Apache</span> as a web server, all running on Linux. Two months,
and no crashes. None.
</p><p>
A few common feature requests/bug reports. Some data seems to have been
lost regarding the "Show to world" status of bugs. Those bugs exist and
are nagging engineers as we speak, they just aren't visible to the
outside world. Currently, the developer databases all reside on the
crufty old <span class="application">FileMaker</span> system. This means that the new system cannot verify
identities and we therefore cannot allow developers to modify or comment
on their bugs. We Will Fix This (tm).
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop4-24"></a>Developers' Workshop: Taking the Media Kit Offline</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Stephen</span> <span class="surname">Beaulieu</span></span></div></div></div><p>
When processing media in real time with the Media Kit, a given node chain
will have one node that acts as the time source for the entire chain. The
time source's sense of time advances in constant but tiny increments
(microseconds), and is used to keep all the nodes in sync with each other.
</p><p>
In offline mode, there are no real time constraints for processing
buffers, and as such, nodes do not pay attention to external time
sources. In effect, each node acts as its own time source. Time advances
for an offline node when all the data required for a processing quantum
is available. This usually occurs in fits and jumps. Time can progress
faster or slower than real time, depending on the work being done.
</p><p>
Applications and nodes have different behavior when working with media
offline.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791686"></a>Offline Applications</h3></div></div></div><p>
Writing media applications to use offline nodes is straightforward,
though a little more complicated than more standard real time apps. Our
advice boils down to two main points:
</p><div class="orderedlist"><ol><li><p>
In a given node chain, all nodes downstream from an offline node
must also be in offline mode. As you'll see, media nodes in offline
mode depend on the behavior of downstream nodes to drive the proper
flow of buffers. Nodes in a real time mode will not properly request
and handle buffers from an upstream node in offline mode.
</p></li><li><p>
Processing media in an offline chain should be done in distinct
quanta of time, where all the components and settings are consistent.
An app should connect the nodes and specify their settings for the
specified quantum. Use <code class="methodname">BMediaRoster::RollNode()</code> to instruct the nodes
to start and stop. <code class="methodname">RollNode()</code> calls <code class="methodname">Seek()</code>,
<code class="methodname">Start()</code> and <code class="methodname">Stop()</code> on each
node in an atomic action. This ensures that a stop event will be
enqueued before the node has a chance to move past the stop time
(remember, performance time can elapse much faster in offline mode).
</p></li></ol></div><p>
Following these two rules will help make sure that the output from
offline nodes is what you expect.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791751"></a>Offline Nodes</h3></div></div></div><p>
Nodes that are derived from <code class="classname">BMediaEventLooper</code> (and why would you want to
do it any other way?), already have a good deal of infrastructure for
handling offline mode. <code class="classname">BMediaEventLooper</code>s have an internal sense of time
in offline mode which can be accessed and set through <code class="methodname">SetOfflineTime()</code>
and <code class="methodname">OfflineTime()</code>. For most nodes, this simple value is sufficient, but
if necessary, <code class="methodname">OfflineTime()</code> can be overridden to provide more specific
behavior.
</p><p>
The <code class="classname">BMediaEventLooper</code> has a different control loop in offline mode that
bases actions on the offline time. The loop looks like this:
</p><div class="orderedlist"><ol><li><p>
Determine offline time using <code class="methodname">OfflineTime()</code>.
</p></li><li><p>
Handle all performance time events before or at offline time.
</p></li><li><p>
Determine next real time event (if any).
</p></li><li><p>
Wait for messages until the next real time event.
</p></li><li><p>
Handle the real time event or a message which comes in.
</p></li><li><p>
Start over.
</p></li></ol></div><p>
The gist of the loop is to wait for messages and add events to the event
queue until the offline time is updated for the node. Then handle all
events in the event queue up to and including the new offline time.
</p><p>
Only a node can determine the exact conditions required to advance its
internal sense of time, but there are some general guidelines. Offline
time advances under two circumstances: when starting and stopping the
node, and through buffer flow.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791851"></a>Starts and Stops</h3></div></div></div><p>
When <code class="methodname">Start()</code> is called and the looper is currently stopped, set offline
time to the start time and add the start event to the queue. When
handling a <code class="constant">B_STOP</code> event in
<code class="methodname">HandleEvent()</code>, look to see if there is another
start event in the queue, and advance offline time to that event's time.
This will ensure that events start to be handled appropriately.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791879"></a>Buffer Flow</h3></div></div></div><p>
Advancing offline time based on buffer flow varies depending on the type
of node: producer, consumer, or both.
</p><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791890"></a>BBufferProducers:</h4></div></div></div><p>
In any real time mode producers create and send buffers downstream on a
regular basis, according to the time. Most nodes handle this by adding a
<code class="constant">B_HANDLE_BUFFER</code> event to the queue the next time a buffer needs to be
produced. So when time advances to that time, the next buffer is produced
and sent downstream. In order to keep nodes responsive, only the first
buffer is sent downstream when an offline producer is started. Subsequent
buffers are sent when an additional buffer is requested by the downstream
node (through the new <code class="methodname">AdditionalBufferRequested()</code> function).
</p><p>
Producers in offline mode will increment offline time to the next
<code class="constant">B_HANDLE_BUFFER</code> time when <code class="methodname">AdditionalBufferRequested()</code> is called.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791931"></a>BBufferConsumers:</h4></div></div></div><p>
Consumers work in exactly the opposite fashion: they wait for all the
data necessary for a specific time quantum to arrive, and then update
offline time to reflect the data received. Remember, in offline mode the
goal is to not drop data, so consumers have to wait until all buffers
have arrived before moving on. In offline mode, there are really no late
buffers. So, offline time is updated in <code class="methodname">BufferReceived()</code> to the minimum
time of the last buffer received from each source.
</p><p>
In addition, to keep buffers flowing, whenever a consumer is done with a
buffer, the node calls <code class="methodname">RequestAdditionalBuffer()</code> from the upstream
source. This will ensure that another buffer is prepared and sent.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id791964"></a>Filters (Consumer/Producers)</h4></div></div></div><p>
Filters combine these two sets of requirements, and are a little more
complex. For offline time to advance to the time to send a buffer
downstream all of the data must arrive for that time quantum and an
additional buffer must be requested. A convenient way to manage this is
to stash a couple of booleans: <code class="varname">ReadyToSend</code>
and <code class="varname">AdditionalBufferRequested</code>.
In <code class="methodname">BufferReceived()</code> and
<code class="methodname">AdditionalBufferRequested()</code> these flags are set
and checked. If additional buffers have been requested it is safe to
update offline time in <code class="methodname">BufferReceived()</code>; if
<code class="varname">ReadyToSend</code> it is safe to
update offline time in <code class="methodname">AdditionalBufferRequested()</code>. In either case, when
a buffer is sent downstream, the booleans must be updated.
</p></div></div><p>
Sample code that demonstrates offline processing can be found at
&lt;ftp://ftp.be.com/pub/samples/media_kit/OfflineSample.zip&gt;. This sample
code works with the later genki betas and the final genki release of the
BeOS.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee4-24"></a>Singing, Dancing... and Selling</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
The Web started as a hypertext extension to what was then a geek
underworld known as the Internet. The Internet itself was a community --
some even said a commune—of cheeky Unix users, if you'll pardon the
pleonasm. They had the foresight to divert (or pervert) defense funding
into developing a unified set of powerful protocols and wires
interconnecting their computers. A simple Unix command—no pleonasm
here—gave you access to files and other computing resources anywhere
on the Internet.
</p><p>
Ted Nelson had popularized the idea of hypertext with his 60's book,
"Literary Machines"
<a class="ulink" href="http://jefferson.village.virginia.edu/elab/">http://jefferson.village.virginia.edu/elab/</a>.
HyperCard was one attempt to organize
information using hypertext ideas. Finally, Tim Berners-Lee at the CERN,
saw how a simple new protocol, http, could fertilize the Internet by
linking Universal Resource Locators, URLs, in a "one-click-away" web of
hypertext connections.
</p><p>
And fertilize it did. http proved to be so simple, so powerful, so
magical that the new web became the Web, and attracted the largest wave
of capital invested in a new sector. I chose the word "fertilize" with
intent. The hypertext protocol was promptly enriched with media types
sexier than old-fashioned text. And it begat hypermedia that quickly
became hyping-media, taking the Web to what could be its real raison
d'être: selling. Selling goods, services, "content," music, video, hotel
reservations, and the lineage of your ancestors.
</p><p>
I'm not sure how Ted Nelson feels about this incarnation of "Literary
Machines," but nevertheless, that's where we are. The Web is hyperselling
-- everything, to everyone, everywhere, all the time. Personally, I like
this—for many reasons. First, it has the potential of re-leveling the
playing field, even for artistic activities. Take the music scene, for
instance. One could lament the ugliness of MP3 piracy—a real problem.
One could also look at the potential for creators and publishers.
Yesterday, their access to the market was guarded by the big publishing
and distribution houses, names withheld. With the Web, there's hope that
they can be heard. More generally, new forms of old commerce—Amazon,
E*TRADE—or new media—Yahoo, AOL—or altogether new forms such as
eBay emerge. It's interesting and it's fun.
</p><p>
Lastly, our media-focused technology has ways to make IP packets sing,
dance, and sell like no one in the business. That's why we feel the BeOS
has a choice role to play in the creation and the consumption of rich
media on the Web. Understandably, we encounter two schools of thought
when dealing with new technology and new opportunities. On one side of
the debate, some believe the PC as we know it—or, more precisely,
Windows—will continue to do everything, for everyone, everywhere, all
the time. It will just keep adding more blades to the Swiss Army knife.
</p><p>
At the far extreme of the debate, some claim Windows is no longer
required and will disappear. Our position isn't that radical. We think
the office automation roots of Windows make it extremely useful, even
irreplaceable for some, in productivity applications—including those
now extended to the all-pervasive Web. But these very roots are what
limit Windows in media-rich applications, where this mature OS has
trouble with singing and dancing IP packets.
</p><p>
In other words, we believe that PCs are bound not to disappear but to
coexist with a growing number of Web-centric devices. When a new genre
appears, there is a tendency to assume it will kill off earlier life
forms: TV was going to kill movies, videoconferencing would replace
business travel. Instead, as we now know and forget, we ended up with
more choices—the new genres created more opportunities.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue4-23.html">Issue 4-23, June 9, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-25.html">Issue 4-25, June 23, 1999</a> </div><div id="footerB"><div id="footerBL"><a href="Issue4-23.html" title="Issue 4-23, June 9, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue4-25.html" title="Issue 4-25, June 23, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
