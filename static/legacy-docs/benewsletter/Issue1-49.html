<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 1: 1995–1996</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume1.html" title="Volume 1: 1995–1996" /><link rel="prev" href="Issue1-48.html" title="Issue 1-48, November 6, 1996" /><link rel="next" href="Issue1-50.html" title="Issue 1-50, November 20, 1996" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue1-48.html" title="Issue 1-48, November 6, 1996"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume1.html" title="Volume 1: 1995–1996"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue1-50.html" title="Issue 1-50, November 20, 1996"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 1: 1995–1996</div></div><div id="headerB">Prev: <a href="Issue1-48.html">Issue 1-48, November 6, 1996</a>  Up: <a href="volume1.html">Volume 1: 1995–1996</a>  Next: <a href="Issue1-50.html">Issue 1-50, November 20, 1996</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue1-49"></a>Issue 1-49, November 13, 1996</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering1-49"></a>Be Engineering Insights: The MIDI Sample Player</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Marc</span> <span class="surname">Ferguson</span></span></div></div></div><p>According to tiny anthropomorphic hamsters huddled in a corner at
Bloomingdale's pre-opening gala, Be, Inc. will be releasing its software
MIDI synthesizer later this month. This will allow MIDIphiles to play
MIDI files using the audio output of the BeBox without having to connect
to an external MIDI player. It also provides an easy way for application
developers to add a soundtrack and sound effects to their applications.
</p><p>The software synthesizer is based on the wavetable synthesis engine
SoundMusicSys, licensed from Headspace, Inc. SoundMusicSys was created by
Steve Hales and Jim Nitchals and has achieved considerable popularity
among game developers. The SoundMusicSys engine supports Headspace's RMF
(Rich Music Format), a cross-platform open standard for musical
expression (see www.headspace.com for more about RMF).
</p><p>The software synthesizer also supports the General MIDI Specification,
which is a mapping from MIDI program change numbers to instruments. An
application can play ocarina sounds, for example, by sending a program
change number 79 (ocarina) to the synthesizer on one of the sixteen MIDI
channels. The synthesizer will then respond to a note-on message on that
channel by mixing an appropriately pitch- shifted ocarina sound into an
audio stream (usually the DAC stream).
</p><p>A high-quality General MIDI instrument sample library was developed
specifically for the BeOS by Peter Drescher of Twittering Machine
Productions. The library includes a complete set of 127 instruments, plus
a percussion bank, and contains about 5 MB of samples. The instruments
are sampled at 22 KHz, 16-bit resolution. While they're designed to be
able to play a wide range of General MIDI files in a variety of musical
styles, special attention was paid to creating a lifelike effect from the
acoustic instruments.
</p><p>The SoundMusicSys engine can play user supplied samples as well as sounds
from the sample library; and a selection of built-in reverb effects can
be applied to the samples.
</p><p>Interested developers should pay close attention to the Be web site,
where a sample application capable of rendering MIDI files to audio will
be appearing, followed shortly by an API to the synthesizer along with
source code to the sample application.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering1-49-2"></a>Be Engineering Insights: Standard Template Library</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Mani</span> <span class="surname">Varadarajan</span></span></div></div></div><p>The next major release of the BeOS, Developer Release 9 (DR9), will
include a significant overhaul of our mainline C++ libraries. Many of
these changes should make development on the BeOS much more flexible. The
major new features planned for inclusion are C++ I/O streams, support for
exceptions, and an implementation of the C++ Standard Template Library
(<acronym class="acronym">STL</acronym>).
</p><p>Most programmers should be familiar with the first two features. I/O
streams provide an easy way to abstract file I/O. C++ exceptions provide
a mechanism by which the programmer can handle unexpected or error
conditions and relay them to other parts of the program. Both of these
are described in detail in any good C++ book.
</p><p>The third new feature, <acronym class="acronym">STL</acronym>, has been a part of the ANSI C++ standard
since 1994. <acronym class="acronym">STL</acronym> is a powerful and efficient library that aggressively
uses templates to provide a set of useful C++ container classes and
generic algorithms. These classes and algorithms provide an easy way to
construct and operate on new and complex data structures.
</p><p>The details of <acronym class="acronym">STL</acronym> can get rather hairy and may take some time to
understand properly. This article provides a very brief description of
the elements of <acronym class="acronym">STL</acronym> and a few examples of their use.
</p><p><acronym class="acronym">STL</acronym> consists of five elements:
</p><ul class="itemizedlist"><li><p>"Algorithms" are template functions that perform operations on
containers.
</p></li><li><p>"Containers" are objects that contain other objects and perform
memory operations on them.
</p></li><li><p>"Iterators" are methods that specify the location of a container or
stream, for use by an algorithm.
</p></li><li><p>"Function objects" encapsulate functions in an object for use by
other components.
</p></li><li><p>"Adaptors" adapt components to provide different interfaces; they
translate between classes.
</p></li></ul><p><acronym class="acronym">STL</acronym> extends basic C and C++ programming paradigms, making it easy to
start using the library. For example, <acronym class="acronym">STL</acronym> provides a generic sorting
algorithm, appropriately named <code class="function">sort()</code>.
</p><p>The following code fragment demonstrates how <code class="function">sort()</code> can be used to sort
the elements in a "normal" array, as well as on the <acronym class="acronym">STL</acronym> "vector"
container:
</p><pre class="programlisting cpp">
<span class="type">double</span> <code class="varname">a[1000]</code>;
<span class="type">vector</span>&lt;<span class="type">double</span>&gt; <code class="varname">b</code>;
...

<span class="comment">// sort all the items in the array</span>
<code class="function">sort</code>(<code class="varname">a</code>, <code class="varname">a</code> + 1000);

<span class="comment">//sort all the items in the vector</span>
<code class="function">sort</code>(<code class="varname">b</code>.<code class="methodname">begin</code>(), <code class="varname">b</code>.<code class="methodname">end</code>());
</pre><p>As with all <acronym class="acronym">STL</acronym> algorithms, the <code class="function">sort()</code> algorithm is generic: It accepts
regular pointers as its arguments, as well as the <acronym class="acronym">STL</acronym>-defined "iterators"
(location specifiers) that are returned by the <code class="function">begin()</code> and <code class="function">end()</code> calls.
</p><p>Note that there are various kinds of iterators. The type of the iterator
defines its use. For example, input iterators provide access to data
sources. Output iterators provide access to data sinks. These can be
explored further as the programmer delves into <acronym class="acronym">STL</acronym>.
</p><p>The library provides a number of container types. In addition to arrays
("built-in" containers) and the vector type demonstrated above, <acronym class="acronym">STL</acronym>
provides lists, queues, sets, and stacks, to name a few. These are all
templates, so you can have a list of ints, set of Employees, and so on,
without doing much work at all.
</p><p>Here's a simple example taken from the web that once again uses the
vector container type (see
http://www.cs.brown.edu/people/jak/programming/stl-tutorial/tutorial.html
for more examples):
</p><pre class="programlisting cpp">
#include &lt;iostream.h&gt;
#include &lt;algobase.h&gt;
#include &lt;vector.h&gt;

<code class="function">main</code> (<span class="type">int</span> <code class="parameter">argc</code>, <span class="type">char *</span><code class="parameter">argv</code>[])
{
  <span class="type">int</span> <code class="varname">n</code> = atoi (<code class="parameter">argv</code>[1]); <span class="comment">// argument checking removed for clarity</span>

  <span class="type">vector</span>&lt;<span class="type">int</span>&gt; <code class="varname">v</code>;
  for (<span class="type">int</span> <code class="varname">i</code> = 0; <code class="varname">i</code> &lt; <code class="varname">n</code>; <code class="varname">i</code>++) <span class="comment">// append integers [0, n-1] to v</span>
    <code class="varname">v</code>.<code class="methodname">push_back</code> (<code class="varname">i</code>);

  <span class="comment">// shuffle</span>
  <code class="function">random_shuffle</code> (<code class="varname">v</code>.<code class="methodname">begin</code>(), <code class="varname">v</code>.<code class="methodname">end</code>());

  <span class="comment">// print to stdio</span>
  <code class="function">copy</code> (<code class="varname">v</code>.<code class="methodname">begin</code>(), <code class="varname">v</code>.<code class="methodname">end</code>(), ostream_iterator&lt;int&gt; (<code class="varname">cout</code>, "\n"));
}
</pre><p>This program generates a random permutation of the first 'n' integers,
where 'n' is specified on the command line. Believe it or not, the
algorithm <code class="function">random_shuffle()</code> is defined in <acronym class="acronym">STL</acronym>.
</p><p>The last line of this program may be a bit confusing. The <acronym class="acronym">STL</acronym> <code class="function">copy()</code>
algorithm takes three iterators. The first two specify the source range
and the third is the destination. Here, the third argument,
<code class="code">ostream_iterator&lt;<span class="type">int</span>&gt;()</code>, is an "adaptor." The adaptor converts the
integer vector into an output stream. Assigning to
<code class="code">ostream_iterator&lt;<span class="type">int</span>&gt;</code>
writes data out. The two arguments to the <code class="code">ostream_iterator&lt;<span class="type">int</span>&gt;</code>
constructor are the output stream and the element separator.
</p><p>In summary, <acronym class="acronym">STL</acronym> provides a concise and efficient way of constructing and
operating on a variety of data structures. What I've presented above are
the bare essentials; there are many other ways these template classes can
be used. Look forward to using them in DR9!
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="News1-49"></a>News From The Front</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">William</span> <span class="surname">Adams</span></span></div></div></div><p>Before I was married, I used to work all the time. Lucky for me, my
future wife worked with me. That's 24-hour-a-day exposure to my spouse to
be!
</p><p>When we were married, we vowed, among other thing, to not work on
weekends, and not only that, but we didn't keep a machine at home either.
What a time squeeze. At the time we were doing a lot of NeXT development
and were pretty proficient at it, so things were OK.
</p><p>Before my daughter was born, I got in the habit of exercising to think
quickly. I figured there wouldn't be much time to write buggy code
accompanied by long hours of debugging. So, what to do? I know, use
frameworks and plug- ins extensively. Object-oriented programming has
been given a bad wrap. Encapsulation at least is a key development
methodology, which works very well in many situations, and add-ons
implement encapsulation beautifully.
</p><p>One advantage that the BeOS has as a new operating system, starting
relatively from scratch, is that we have a lot of good and bad examples
to look at. This is true for both the OS code itself and the applications
that we encourage developers to write. An application like, oh, I don't
know... Lumena, was pretty good, took a long time to develop, and
couldn't keep up with the times.
</p><p>We can learn from this. We can emulate functions and features, and best
of all, we know what the architecture of the application should be. I
would argue that the architecture, or framework, upon which the
application is built is one of the most important factors that will
influence how gracefully it ages over time. A framework that supports
add-ons will at least be more easily updated and possibly more extensible
than its traditional monolithic counterpart. And even at that, we've
learned a lot about how to make add-ons work most efficiently. So like
today's OS that learns from the pros and cons of the past, applications
do the same thing.
</p><p>As an example, last week I released the first version of Rraster! This is
a simple example of how to support add-ons using the BeOS. The
application is simple, it's meant to be an add-ons aware image viewer. I
would put it in the category of esoteric software, because although this
particular category has launched such products as Photoshop and
DeBabelizer, this really is a mundane feature that no OS should be
without.
</p><p>My nanny was deathly ill last week, so I spent at lot more time with my
daughter. When you're with an 18-month old you don't have a lot of time
to think, let alone code. But I had to stay productive, so what to do?
Write more Rraster add- ons. So this week I've updated Rraster. I managed
to add support for the following file formats:
</p><p>GIF, PCX, PBM, TIFF, TGA, PNG, JFIF, XBM, and BMP
</p><p>I didn't quite have enough time for PICT or other Mac formats, but what
can you expect for coding that has to occur between diaper changes. Then
I was about to take a whack at filter plug-ins and the weekend parties
and visiting started.
</p><p>You can get the latest at:
</p><p>ftp://ftp.be.com/pub/Samples/Rraster.tgz
</p><p>Of course all this source is for you to be able to write your own
favorite image plug-in and to see how add-ons can be supported in general.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506252"></a>From The Pit</h3></div></div></div><p>To continue the deluge of internally developed demo app source releases,
I managed to get Mandelbrot prettied-up. So take a look at:
</p><p>ftp://ftp.be.com/pub/Samples/Mandel.tgz
</p><p>You'll see the most often implemented demo code in the history of graphic
computing. This is probably the Hello World! of graphics programming,
other than bouncing balls.
</p><p>I'll take one more pass at the graphics framework as an example before
moving on to some apps that are more audio in nature, since we're lacking
in this area. Remember, if you want to see something specific, send in
those requests and keep them coming.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee1-49"></a>Genre</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>In 1987, most pundits started predicting that multimedia was poised to
become the next revolution in computing. I believe this was the time when
the P word, paradigm, as in "paradigm shift," started to creep into
execuspeak. Others felt multimedia was the simple but important
continuation of an old trend: With great regularity, more of (almost)
everything was offered to hardware and software engineers. As a result,
the computer increased its range of media and, to a large extent, it
handled it more gracefully with the passage of time.
</p><p>There was a time when multimedia meant multiple slide projectors and a
tape player; when the multimedia dust settled for a brief moment before
the rise of the web, multimedia had come to mean a CD-ROM, loudspeakers,
color, music, and animated graphics. At Apple, in the early days of the
new era, we were both clueless and bombarded—from outside and, as a
result, from the executive suite. We were clueless because, while we
liked more interesting, livelier computers, at that time we had no idea
what the next multimedia "killer app" would turn out to be. We were
bombarded with suggestions and demands from the outside world. (This is a
long-standing tradition for Apple, one that seems to perpetuate itself
today with suggestions to adopt a certain operating system.)
</p><p>For instance, in those days technological haruspices were clamoring for
the adoption of DVI, an Intel-sponsored asymmetric video compression
technology, and there were big debates about CD-I, the "I" standing for
interactive. Japanese companies were trying to enter the market with a
new kind of multimedia personal computer, the CD-I PC. There was panic,
we must have a statement of strategic direction, and collateral damage,
the overproduction of overhead transparencies. The search for the
multimedia Holy VisiCalc wasn't going well. Video looked attractive,
"compelling" was the buzzword. Other had their doubts, based on a
combinations of psychological and business arguments. They saw the
classical productivity applications as tools, used repeatedly and valued
accordingly. Video was perceived as more ephemeral. Captivating,
entertaining, but few customers, if any, would use the same video over
and over again. And for entertainment, why bring TV to the computer
screen?
</p><p>Sensing the potential, but unable to divine the killer app, I made a bold
move: I hired a childhood friend of Larry Tesler, Marc Porat, with the
mission to scour Apple's technology portfolio and build a multimedia
strategy. He came up with General Magic instead. But there was hope. One
researcher in Apple's Advanced Technology Group wrote a short paper
summarizing the notion of "genre." The genre expresses a convention, an
agreement combining the expressive ways of authors and the expectations,
the habits of an audience. The same physical medium can harbor many
genres: Newspaper, book, newsletter, encyclopedia on paper, or comedy,
tragedy, musical comedy on stage. That paper transmuted the Holy
PageMaker question into one of new, emerging genres. We now know a little
more. In many ways, the CD-ROM has become synecdoche for multimedia, and
a few distinct genres have emerged for the new medium: Games, reference,
software distribution, the questionable edutainment, and lately, back-up,
admittedly not very multimedia nor totally ROM. All self-respecting PCs
now have a CD-ROM drive, speakers, and reasonable audio and video
capabilities.
</p><p>The Internet poses even more interesting genre questions. We have e-mail,
news, web pages... E-mail meets the definition of genre very well:
Expectations, audience, expression, the ingredients are there. The same
is true for news. Things get more confusing for web pages. One can argue
company and personal pages are gaining the stable conventions required to
qualify. But the proliferation of information has created an opportunity
for new genres: Search and delivery.
</p><p>In a way, General Magic was onto something and investors were lured by
the promise of intelligent agents. Newspapers use intelligent humans to
sort and present information to us. Humans and computers in concert are
likely to create one or two stable genres mining the web for us and
providing us the combination of the expected and the pleasantly
unexpected, for which we'll be willing to part with some of our money.
Which is another genre criterion.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BeDevTalk1-49"></a>BeDevTalk Summary</h2></div></div></div><p>BeDevTalk is an unmonitored discussion group in which technical
information is shared by Be developers and interested parties. In this
column, we summarize some of the active threads, listed by their subject
lines as they appear, verbatim, in the mail.
</p><p>To subscribe to BeDevTalk, visit the mailing list page on our web site:
http://www.be.com/aboutbe/mailinglists.html.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506381"></a>WEEK 2</h3></div></div></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506387"></a>Subject: Fresh Programs</h4></div></div></div><p>Scripting talk. Correspondents politely debated the merits of REXX (and
OREXX), Java, Python, and so on. At a higher level, the one-language
attitude was questioned: Some folks would prefer an open scripting
architecture, in which any number of scripting languages are
recognized. It was offered that Be must (at least) standardize the
scripting interface at the application port (AKA socket) level.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506405"></a>Subject: Injecting input into the app_server stream</h4></div></div></div><p>Methods for polling and calibrating joysticks were discussed.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506418"></a>Subject: 603e vs DSP</h4></div></div></div><p>More performance comparisons between the PPC family (the 603e,
specifically) and dedicated DSP chips.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506431"></a>Subject: 3D GUI talk</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">
AKA: 3D SPACE<br />
AKA: GUI
</h5></div></div></div><p>More discussion of the possibility of a three-dimensional desktop. The
score so far: Everyone pretty much hates messy overlapping windows --
anything that can improve this fact of life is appreciated. 3D,
obviously, holds promise in this area, but most correspondents are a
bit skeptical of the intuitiveness of a full 3D workspace. The provicts
argue that we live in a 3D world, so intuition should be on the side of
a 3D GUI; convicts grant this point, but then score a right to the jaw
by reminding us that our input devices aren't designed for 3D. (Now, if
we had e-gloves...)
</p><p>A number of counterproposals and fine-tunings were also offered: "2.5"
dimensions, a torus desktop, multiple (networked) computers connected
to the same three- dimensional workspace, and so on.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506456"></a>Subject: BeAPI design flaw? BControl.Invoke() and</h4></div></div></div><p>A discussion of methods for getting mouse events: Is polling for mouse
movement acceptable? What about blocking in the main loop while waiting
for a mouse move event?
</p></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506472"></a>NEW</h3></div></div></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506478"></a>Subject: A must Read Article for All</h4></div></div></div><p>A recent article by Simson Garfinkle in which Mr. Garfinkle critiqued
the Be GUI was met with some beg-to-differism. After the initial "who
does he think he is?" bent, the thread itself became a constructive
criticism of certain aspects of the GUI.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506493"></a>Subject: Newsletter #48</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">AKA: Asynch IO</h5></div></div></div><p>Last week, JLG pointed readers to a couple of articles that spoke to
the Be/Apple rumors. Many correspondents took issue with the content of
one of the articles, in which Gil Amelio portrayed the BeOS as
less-than-real-time and I/O- challenged. This led to a broader
discussion of threads vs asynchronous I/O.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id506514"></a>Subject: DR9 Filesystem Features</h4></div></div></div><p>Many contributors pleaded for an overview of DR9 file system features.
Dominic Giampaolo, the Italian half of Be's international file system
team, complied.
</p></div></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue1-48.html">Issue 1-48, November 6, 1996</a>  Up: <a href="volume1.html">Volume 1: 1995–1996</a>  Next: <a href="Issue1-50.html">Issue 1-50, November 20, 1996</a> </div><div id="footerB"><div id="footerBL"><a href="Issue1-48.html" title="Issue 1-48, November 6, 1996"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume1.html" title="Volume 1: 1995–1996"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue1-50.html" title="Issue 1-50, November 20, 1996"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
