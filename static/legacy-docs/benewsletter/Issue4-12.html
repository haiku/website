<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 4: 1999</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume4.html" title="Volume 4: 1999" /><link rel="prev" href="Issue4-11.html" title="Issue 4-11, March 17, 1999" /><link rel="next" href="Issue4-13.html" title="Issue 4-13, March 31, 1999" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue4-11.html" title="Issue 4-11, March 17, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue4-13.html" title="Issue 4-13, March 31, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 4: 1999</div></div><div id="headerB">Prev: <a href="Issue4-11.html">Issue 4-11, March 17, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-13.html">Issue 4-13, March 31, 1999</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue4-12"></a>Issue 4-12, March 24, 1999</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-12"></a>Be Engineering Insights: Exact Change Only—Riding the Universal Serial
Bus Through User-land</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Brian</span> <span class="surname">Swetland</span></span></div></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id773898"></a>Deja Vu</h3></div></div></div><p>
The last Developer Newsletter article I wrote had a similar theme to this
one—I explained how to use the new scsi_raw device to talk directly to
SCSI devices from outside the kernel. This time around we'll look at a
slightly newer bus. The Universal Serial Bus (<acronym class="acronym">USB</acronym>) is available on most
new PCs. If we're lucky, it may do away with a number of the bizarre
ports on the back of our PCs, replacing them with one standard interface.
I could live with that.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id773921"></a>Coming Soon To A Release Near You</h3></div></div></div><p>
BeOS Release 4.1 (coming soon) provides support for <acronym class="acronym">USB</acronym> keyboards, mice,
and printers. It also supports <acronym class="acronym">USB</acronym> hubs (used to connect several devices
to one <acronym class="acronym">USB</acronym> port) and all the assorted bookkeeping and bus management
involved. There is a <acronym class="acronym">USB</acronym> Bus Manager for device drivers to use, but it's
a fairly complex critter that's still evolving. My original intention was
to provide a usb_raw device to allow user programs to talk to <acronym class="acronym">USB</acronym>
devices, but even that proved to be tricky—the usb_raw device uses the
not-officially-documented, subject-to-change <acronym class="acronym">USB</acronym> Bus Manager, has to
"cheat" a bit in places, and has a rather complex <code class="function">ioctl()</code> interface.
Where the scsi_raw device had one function—to send a <acronym class="acronym">SCSI</acronym> Command --
the usb_raw device must support a number of operations.
</p><p>
Wouldn't it be nice if there was a C++ Kit (like some of the other Be
<acronym class="acronym">API</acronym>s) to make this all easier? Well that's what you'll get this week. Be
aware that this is a prototype right now and not an "Official" Be Kit.
This is your opportunity to take a look at a new Kit as it's being
developed, and to provide some feedback. Let me know what you like or
dislike—we'll post updated versions as things evolve, and once it's
finalized, it will become part of the standard BeOS Kits.
</p><p>
You'll need R4.1 to actually use the code in this article. The usb_raw
device and <code class="filename">USB.h</code>
system header are provided for those who are interested
in what the kernel side of things looks like, but we're not going to
cover them in detail here. Suffice to say, they contain many sharp edges
that we intend to sand down, and they are not for people who are afraid
of cutting themselves on the bleeding edge of undocumented kernel <acronym class="acronym">API</acronym>
development.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774009"></a>Everything You Ever Wanted To Know About USB But Were Afraid To Ask</h3></div></div></div><p>
This article refers to several <acronym class="acronym">USB</acronym> concepts and terms, but does not
attempt to explain them. The following resources will prove useful to
people who want to learn more about <acronym class="acronym">USB</acronym>:
</p><ul class="itemizedlist"><li><p>
ftp://ftp.be.com/pub/samples/r4/usb_kit/usbkit_99-03-23.tgz<br />
Source code for components discussed in this article.
</p></li><li><p>
<a class="ulink" href="http://www.usb.org/developers/">http://www.usb.org/developers/</a><br />
The USB Implementors Forum: Lots of info, specs, etc. here.
</p></li><li><p>
<a class="ulink" href="http://www.usb.org/developers/download.htm">http://www.usb.org/developers/download.htm</a><br />
The USB 1.1 Spec in PDF (Chapters 9-11 are most helpful).
</p></li><li><p>
<a class="ulink" href="http://www.amazon.com/exec/obidos/ASIN/0201461374/beincorporated/">http://www.amazon.com/exec/obidos/ASIN/0201461374/beincorporated/</a><br />
Universal Serial Bus System Architecture, by MindShare.
</p></li></ul></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774080"></a>The Prototype USB Kit</h3></div></div></div><p>
There are five classes in the <acronym class="acronym">USB</acronym> Kit:
</p><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774094"></a><code class="classname">USBDevice</code> (<code class="filename">usb/Device.cpp</code>)</h4></div></div></div><p>
The <code class="classname">USBDevice</code> class is initialized from a
path to a raw <acronym class="acronym">USB</acronym> device (e.g.,
<code class="filename">/dev/bus/usb/0/0</code>)
and uses the usb_raw driver to provide access to most
of the functionality of the <acronym class="acronym">USB</acronym> Bus Manager from user space
</p><p>
<code class="classname">USBDevice</code> objects are best obtained
by using the <code class="classname">USBRoster</code>, described
below. Using the <code class="classname">USBRoster</code> allows for
the dynamic nature of <acronym class="acronym">USB</acronym>. Just
examine the device in the <code class="methodname">DeviceAdded()</code> method to see if it's the one
you're looking for.
</p><p>
A number of methods exist to examine the contents of the Device
Descriptor (a structure defined by the <acronym class="acronym">USB</acronym> Specification that describes
the device). These methods include <code class="methodname">USBVersion()</code>,
<code class="methodname">Class()</code>, <code class="methodname">Subclass()</code>,
<code class="methodname">Protocol()</code>,
<code class="methodname">MaxEndpoint0PacketSize()</code>, <code class="methodname">VendorID()</code>,
<code class="methodname">ProductID()</code>, <code class="methodname">Version()</code>,
<code class="methodname">ManufacturerString()</code>, and <code class="methodname">ProductString()</code>.
</p><p>
A <acronym class="acronym">USB</acronym> device may be in one of several configurations (represented by
<code class="classname">USBConfiguration</code> objects in this Kit). <code class="classname">USBDevice</code> provides a
<code class="methodname">CountConfigurations()</code> method to determine how many exist and
<code class="methodname">ConfigurationAt()</code> to obtain a specific configuration. Once you select a
configuration, a device may be configured with the <code class="methodname">SetConfiguration()</code>
method. The current configuration (or <code class="constant">NULL</code> if the device is unconfigured)
may be obtained via the <code class="methodname">ActiveConfiguration()</code> method.
</p><p>
Control requests (always sent to the implied endpoint 0) may be initiated
using the <code class="methodname">ControlTransfer()</code> method.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774252"></a>
<code class="classname">USBConfiguration</code> (<code class="filename">usb/Configuration.cpp</code>)<br />
<code class="classname">USBInterface</code> (<code class="filename">usb/Interface.cpp</code>)<br />
<code class="classname">USBEndpoint</code> (<code class="filename">usb/Endpoint.cpp</code>)
</h4></div></div></div><p>
These classes cannot be created directly. A <code class="classname">USBDevice</code> instance will
create a <code class="classname">USBConfiguration</code> for each of its possible configurations.
<code class="classname">USBConfiguration</code> objects create
<code class="classname">USBInterface</code>s for each interface they
contain. <code class="classname">USBEndpoint</code> objects are created by
<code class="classname">USBInterface</code>s to allow access
to device endpoints. All of these classes are data containers—all the
actual work happens in <code class="classname">USBDevice</code>.
</p><p>
A configuration is a collection of interfaces. <code class="classname">USBConfiguration</code> allows
iteration over the interfaces that it contains with the <code class="methodname">CountInterfaces()</code>
and <code class="methodname">InterfaceAt()</code> methods.
</p><p>
Interfaces are a collection of <code class="classname">USBEndpoint</code> objects (which may be iterated
over using <code class="methodname">CountEndpoints()</code> and
<code class="methodname">EndpointAt()</code> methods). Details from the
Interface descriptor are available from the <code class="methodname">Class()</code>,
<code class="methodname">Subclass()</code>, <code class="methodname">Protocol()</code>,
and <code class="methodname">InterfaceString()</code> methods.
</p><p>
An endpoint is where all the action is—<code class="methodname">BulkTransfer()</code> and
<code class="methodname">InterruptTransfer()</code> initiate actual transfers.
<code class="methodname">IsBulk()</code>, <code class="methodname">IsInterrupt()</code>, and
<code class="methodname">IsIsochronous()</code> let you discover what sort of endpoint it is.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774397"></a><code class="classname">USBRoster</code> (<code class="filename">usb/Roster.cpp</code>)</h4></div></div></div><p>
The <code class="classname">USBRoster</code> is a tool that prevents you from having to wander through
<code class="filename">/dev/bus/usb/...</code> looking
for devices. The <code class="classname">USBRoster</code> takes advantage of
the node_monitor system to watch for changes in available <acronym class="acronym">USB</acronym> devices; it
was inspired by Scott Barta's FolderWatcher.
<a class="xref" href="Issue3-19.html#Engineering3-19" title="Be Engineering Insights: The Tracker Is Your Friend">Be Engineering Insights: The Tracker Is Your Friend</a>
</p><p>
Since devfs doesn't allow files to be renamed or moved, the
implementation here is much simpler. The <code class="classname">USBRoster</code> uses a private class
(<code class="classname">USBRosterLooper</code>) to actually do the work—a Looper is needed to
provide a thread to receive node monitor messages in.
</p><p>
The <code class="classname">USBRoster</code> is used by subclassing—two pure virtual methods are
provided that you must implement in your subclass:
</p><pre class="programlisting cpp">
<span class="type">status_t</span> <code class="classname">USBRoster</code>::<code class="methodname">DeviceAdded</code>(<span class="type"><code class="classname">USBDevice</code> *</span><code class="parameter">dev</code>) { <span class="comment">/* ... */</span> }
<span class="type">void</span>     <code class="classname">USBRoster</code>::<code class="methodname">DeviceRemoved</code>(<span class="type"><code class="classname">USBDevice</code> *</span><code class="parameter">dev</code>) { <span class="comment">/* ... */</span> }
</pre><p>
<code class="methodname">DeviceAdded()</code> is called when a new
<acronym class="acronym">USB</acronym> device appears on the bus (when the
<code class="classname">USBRoster</code> is first started,
<code class="methodname">DeviceAdded()</code> will be called for every device
that is already on the bus).
</p><p>
The <code class="classname">USBRoster</code> creates a new
<code class="classname">USBDevice</code> and keeps it around until unplug, as long
as <code class="methodname">DeviceAdded()</code> returns
<code class="constant">B_OK</code>. If <code class="methodname">DeviceAdded()</code>
returns anything else, the <code class="classname">USBDevice</code> is deleted
immediately and now <code class="methodname">DeviceRemoved()</code> is called.
<code class="methodname">DeviceRemoved()</code> is your warning that the
<code class="classname">USBRoster</code> is about to delete the
<code class="classname">USBDevice</code> in question because it has been removed
from the bus. When <code class="methodname">DeviceRemoved()</code> returns, the
<code class="classname">USBDevice</code> will be deleted—make sure you don't
refer to it again after this point.
</p></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774594"></a>Example 1—Waiting For The Bus</h3></div></div></div><p>
The <code class="filename">watcher.cpp</code> example creates a subclas
of <code class="classname">USBRoster</code> that simply
displays a message when a device is added or removed.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774614"></a>Example 2—Display Some Info</h3></div></div></div><p>
The <code class="filename">info.cpp</code> example is a program that takes one command line argument,
which is the name of a raw usb device (e.g.,
<code class="filename">/dev/bus/usb/0/hub</code> is the
"root hub"). The device descriptor and information about configurations,
interfaces, and endpoints are displayed.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774639"></a>Example 3—Talking To Rodents</h3></div></div></div><p>
The <code class="filename">mouse.cpp</code> example attempts to read 4-byte interrupt events from the
device specified on the command line. It doesn't do much in the way of
error checking (and it will probably do nothing meaningful if the
specified device isn't a <acronym class="acronym">USB</acronym> mouse), but it illustrates the use of an
interrupt endpoint to read data.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774662"></a>Example 4—Something Almost Useful</h3></div></div></div><p>
Cypress Semiconductor makes a chip (the CY7C6300) which can be used for
simple low-speed <acronym class="acronym">USB</acronym> devices. This is a nifty 20-pin DIP package that
requires only a 6MHz crystal and a <acronym class="acronym">USB</acronym> cable connector to work (the
remaining pins provide bidirectional IO ports). For $100 you can purchase
a "USB Starter Kit" that comes with a chip programmer, an evaluation
board with a button and a temperature sensor, two reprogrammable
CY7C6300s, and software for Windows. Unfortunately, Cypress appears
uninterested in supporting the BeOS as a development environment. Bummer.
</p><p>
In a random (and warranty-voiding) survey of eight different <acronym class="acronym">USB</acronym> mice, we
discovered that all of them used this Cypress part. Many of the designs
were surprisingly similar to the "Designing a Low Cost USB Mouse"
application note provided on their website.
</p><p>
The fourth example (<code class="filename">thermo.cpp</code>) talks to the eval board provided in this
kit. It uses a subclass of <code class="classname">USBRoster</code> to look for such boards (identifying
them by the VendorID and ProductID) and creates a <code class="classname">ThermoWatcher</code> object
for each board on bus. The <code class="classname">ThermoWatcher</code> spawns a thread to monitor both
the button and the temperature sensor via periodic control messages, as
well as flash the green
<acronym class="acronym" title="Light Emitting Diode">LED</acronym> provided.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id774732"></a>Next Stop: More Features</h3></div></div></div><p>
There are a number of interesting things that could be done with this
toolkit: a visual <acronym class="acronym">USB</acronym> Monitor to let you examine the topology and devices
of your bus; user-land interfaces to digital cameras, scanners, or other
<acronym class="acronym">USB</acronym> devices. The <acronym class="acronym">USB</acronym> Kit will continue to evolve, providing (if nothing
else) better error reporting, timeouts, and other features not present
yet. Please send me any suggestions you have—nothing is set in stone
yet. The <acronym class="acronym">USB</acronym> Bus Manager in R4.1 does not support isochronous transfers
-- there is support down in the guts of the <acronym class="acronym">USB</acronym> stack, but it's not
exposed at the driver level yet. This will be coming sometime after 4.1
(probably with the next BeOS release, sooner if things go well).
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-12-2"></a>Be Engineering Insights: Getting Connected</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Hank</span> <span class="surname">Sackett</span></span></div></div></div><p>
You've just installed the BeOS on your shiny new machine, launched
NetPositive, clicked on the link to the Be web site...and you're waiting.
What's this waiting about? Isn't Be the OS that doesn't make you wait?
Sadly, the link LED doesn't always shine on brightly.
</p><p>
If this happens to you, the first thing to do is check the connector.
You'll find a nice diagram of Category 5 RJ45 wiring at
http://www.alvin.woco.ohio.gov/cat5/ On some cables only four of the
eight conductors are populated, and will only work at 10 Megabit, not 100
MB speeds.
</p><p>
Crossover cables—the Ethernet equivalent of a null modem cable, where
the transmit and receive lines are crossed—are also something to watch
for. You can use a crossover cable to connect two machines without using
a hub. Some hubs have an "uplink" switch, which crosses or uncrosses
transmit and receive within the hub. Normally, straight wired cables are
used to connect the network interface card to the hub, and the uplink
port (with the switch set to crossover) is used with a straight wired
cable to connect to another hub. You could connect the Ethernet card from
your computer with a crossover cable and uncross it in the hub with the
uplink switch, but that's not unlike using a double negative.
</p><p>
The next thing to check is the link LED on the card, and the hub or
switch. Normally the link LED lights up when the hub and the machine are
powered up and connected. Occasionally, a BIOS setting for power
management needs to be turned on for an on-line Ethernet to power up.
Some DEC cards require the driver to load and enable the LEDs in software
before they'll light up, and some vendors save a few cents by leaving the
LEDs off. Nice vendors include lots of LEDs for link, speed (10 or 100
MB), full- or half-duplex, and transmit and receive. Often transmit and
receive are combined into one activity LED, with a red or yellow LED used
to indicate collisions.
</p><p>
Just as there are choices on each end of the wire for media, speed, and
duplex—all combinations occur—there is also what might be called
the husband and wife case. This is where the card comes up at 100 MB
speed and is connected to a 10 MB hub, effectively jamming communication
on all ports on the hub, with the collision LED blazing like a 100 watt
bulb in a 60 watt socket.
</p><p>
A happier but still troubled couple is a card that's in full-duplex mode
connected to a hub, which is by definition half-duplex. Unhappily,
upgrading to a full- duplex card that doesn't correctly detect a
half-duplex hub decreases throughput. That's because when transmits and
receives occur simultaneously they generate collisions, instead of
improving performance from two-way traffic. Higher-level protocols can
mask this behavior with retransmits, and the casual observer may miss the
problem entirely.
</p><p>
Some 3Com cards ship with a DOS utility for setting a media override
value in nonvolatile memory on the card. These settings may also be
written by Windows device configuration user interfaces. The BeOS driver
will faithfully configure the card media with the values, which may be
blessing or a curse: a curse if you've received a card from another
environment and something has set the card memory with parameters that
don't match your hub or switch, but a blessing if you need to use these
settings to make the card work with your hub or switch.
</p><p>
IEEE standards, like a marriage counselor, provide the n-way
auto-negotiate protocol and the media-independent interface (MII), which
help both sides of the wire to come up with the same speed and duplex
settings. Look for these features if you're buying network hardware, and
look for hardware with lots of LEDs, so you can check the states.
</p><p>
Reading the print on the largest chip on the LAN card or getting the
Vendor and Device ID numbers from the Devices preference will tell you if
the card has a BeOS driver. Vendors often change hardware as parts become
more available or cheaper, and supporting all the hardware is a real
chore. To understand why the entire family of DEC LAN controllers is not
yet supported, check the Linux community's description of the problem at
http://195.113.31.123/~ftp/linux/tulip/tulip-media.html
</p><p>
You say your speed and duplex LEDs and cabling look OK, but still no joy?
Connecting the serial port with a null modem cable to a terminal emulator
set to 19.2, 8-1-none to receive serial debug output may give you a clue.
When the driver is restarted from Network preferences, the debug output
will show the IRQ and Ethernet address of the card. If the IRQ is 00 or
ff, it's time to open the Devices preference and look for conflicts in
resource usage and problems in the BIOS settings. ISA PnP and jumpered
card IRQ and port settings should match those of the Network prefs
configuration.
</p><p>
To verify that your network hardware is working, enter "ping xx.xx.xx.xx"
from the Terminal application, where xx.xx.xx.xx is the IP address of a
known machine on the net; the router IP address may be a good choice. If
the ping works but other network services don't, check domain name,
Domain Name Server (DNS), and the host and login name settings in Network
preferences. Make sure that AppleTalk service is on if you're printing to
an AppleTalk printer.
</p><p>
Look for improved BeOS network drivers, including support for additional
hardware in the future, at http://www.be.com/support/updates/index.html.
You'll also find third-party drivers, which sometimes appear before Be
offers supported versions, at http://www.be.com/beware/Drivers.html.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop4-12"></a>Developers' Workshop: Updating An Old Sound Card Driver</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Marc</span> <span class="surname">Ferguson</span></span></div></div></div><p>
The new Media Kit contains a compatibility interface which lets you use a
pre-R4 sound card driver in R4 with only minor modifications to the
driver. Here is a description of those modifications, assuming that you
are starting with a driver written to the old API described in the
Newsletter article:
</p><p>
<a class="xref" href="Issue3-22.html#DevWorkshop3-22" title="Developers' Workshop: DynaDraw, Part Two">Developers' Workshop: DynaDraw, Part Two</a>
</p><p>
The most important change is that the driver must publish a "sample
clock" which allows the Media Kit to synchronize to the sound card. The
sample clock corresponds to performance time measured by the
<acronym class="acronym" title="Digital to Analogue Conversion">DAC</acronym> (or
<acronym class="acronym" title="Analogue to Digital Conversion">ADC</acronym>)
clock in microseconds. If the nominal sample rate is 44100 samples per
second then the sample clock moves at (1000000 / 44100) microseconds per
sample processed by the <acronym class="acronym">DAC</acronym> (or <acronym class="acronym">ADC</acronym>).
If the <acronym class="acronym">DAC</acronym> is actually processing
44109 samples per second than the <acronym class="acronym">DAC</acronym>'s sample clock will run slightly
faster than real-time.
</p><p>
The sample clock is returned by the driver in the <span class="type">audio_buffer_header</span>
structure which now looks like this:
</p><pre class="programlisting cpp">
typedef struct <span class="type">audio_buffer_header</span> {
  <span class="type">int32</span> <code class="varname">buffer_number</code>;
  <span class="type">int32</span> <code class="varname">subscriber_count</code>;
  <span class="type">bigtime_t</span> <code class="varname">time</code>;
  <span class="type">int32</span> <code class="varname">reserved_1</code>;
  <span class="type">int32</span> <code class="varname">reserved_2</code>;
  <span class="type">bigtime_t</span> <code class="varname">sample_clock</code>;
} <span class="type">audio_buffer_header</span>;
</pre><p>
As before, the <code class="constant">SOUND_WRITE_BUFFER</code> and <code class="constant">SOUND_READ_BUFFER</code> ioctls should
store an estimate of the <code class="function">system_time()</code> corresponding to the beginning of
the buffer in the <code class="varname">time</code> slot of the <span class="type">audio_buffer_header</span>. They should
also fill the <code class="varname">sample_clock</code> slot with the sample clock for the beginning
of the buffer.
</p><p>
To calculate the sample clock, keep track of the number of samples
processed and multiply by the sample clock rate:
</p><pre class="programlisting cpp">
<code class="varname">header</code>-&gt;<code class="varname">sample_clock</code> =
  (<code class="varname">samples_processed</code> * 1000000LL) / <code class="varname">sample_rate</code>;
</pre><p>
As long as buffers are flowing continuously, the sample clock will move
at the same rate as the performance time of the buffers. But if there is
an interruption between buffers then the sample clock must account for
the length of the interruption. One way to do this is to measure the
duration of the interruption and increment <code class="varname">samples_processed</code> by the
number of samples that would have been played during that time:
</p><pre class="programlisting cpp">
<code class="varname">samples_processed</code> += (<code class="varname">time_skipped</code> * <code class="varname">sample_rate</code>) / 1000000;
</pre><p>
There are four new ioctl codes which a driver may optionally support to
negotiate an optimal buffer size with the Media Kit. They appear at the
end of this list:
</p><pre class="programlisting cpp">
enum {
  <code class="constant">SOUND_GET_PARAMS</code> = <code class="constant">B_DEVICE_OP_CODES_END</code>,
  <code class="constant">SOUND_SET_PARAMS</code>,
  <code class="constant">SOUND_SET_PLAYBACK_COMPLETION_SEM</code>,
  <code class="constant">SOUND_SET_CAPTURE_COMPLETION_SEM</code>,
  <code class="constant">SOUND_RESERVED_1</code>,   <span class="comment">/* unused */</span>
  <code class="constant">SOUND_RESERVED_2</code>,   <span class="comment">/* unused */</span>
  <code class="constant">SOUND_DEBUG_ON</code>,     <span class="comment">/* unused */</span>
  <code class="constant">SOUND_DEBUG_OFF</code>,    <span class="comment">/* unused */</span>
  <code class="constant">SOUND_WRITE_BUFFER</code>,
  <code class="constant">SOUND_READ_BUFFER</code>,
  <code class="constant">SOUND_LOCK_FOR_DMA</code>,
  <code class="constant">SOUND_SET_CAPTURE_PREFERRED_BUF_SIZE</code>,
  <code class="constant">SOUND_SET_PLAYBACK_PREFERRED_BUF_SIZE</code>,
  <code class="constant">SOUND_GET_CAPTURE_PREFERRED_BUF_SIZE</code>,
  <code class="constant">SOUND_GET_PLAYBACK_PREFERRED_BUF_SIZE</code>
};
</pre><p>
The <code class="constant">SOUND_SET_CAPTURE_PREFERRED_BUF_SIZE</code> and
<code class="constant">SOUND_SET_PLAYBACK_PREFERRED_BUF_SIZE</code> ioctls take an (<span class="type">int32</span>) argument
containing the buffer size (without the header) that the Media Kit plans
to send. If the driver is using a circular <acronym class="acronym">DMA</acronym> buffer it may want to set
the size of the <acronym class="acronym">DMA</acronym> buffer to twice the preferred buffer size to minimize
latency.
</p><p>
The <code class="constant">SOUND_GET_CAPTURE_PREFERRED_BUF_SIZE</code> and
<code class="constant">SOUND_GET_PLAYBACK_PREFERRED_BUF_SIZE</code> ioctls
take an (<span class="type">int32*</span>) argument in
which the driver can return the current setting of the preferred buffer
size.
</p><p>
Devices supporting the above API should be published under the
<code class="filename">/dev/audio/old/</code>
directory where they will be found by the "legacy"
media add-on.
</p><p>
Adding a sample clock to your old R3 sound card driver will get it up and
running again under R4.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee4-12"></a>Where Is Your Voice?</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
A few weeks ago, I was on a teleconference discussing technology trends
with the advisory board of a Swiss investment fund. Once we were done
scratching our heads over e-stocks and the Great Kleiner Perkins Roll-Up,
handicapping the DOJ vs. Microsoft fight and the advent of the Great
Digital Convergence, the conversation drifted toward more mundane themes
such as IP telephony, a.k.a. VOIP. Experts think this is The Next Big
Thing. Not being one of the chosen, I don't know. It's not that I don't
trust the sages; it's just that I haven't had an opportunity to test any
incarnations of VOIP, to get a personal feel for the devilish details
that make or break a great idea. Ascribe this, if you will, to my own
involvement with the Newton or, more generally, to software that runs on
acetate.
</p><p>
This cautious attitude didn't endear me to one of the participants, who
challenged me in two ways. You call your BeOS a "Media OS," this person
said, and you don't even use one of the most natural media: Voice. You
have no opinion because you haven't tried the current products. I hadn't
-- I was caught with my opinion down.
</p><p>
The relationship of BeOS to VOIP wasn't obvious, but the need to answer
the Media OS challenge was clear. I went out forthwith, and bought three
of the leading products from L&amp;H, IBM, and Dragon Systems.
</p><p>
My experience with them was time consuming, and painful but instructive.
Installing the software itself was no more or less complicated than it is
for other mainstream Windows applications. This is a coded statement
meant to convey that you won't recognize your hard disk after the
fragmentation grenade has strewn .DLLs everywhere. The uninstalling
process is only partially successful, as the system appears unsure of its
ability to reverse parts of the process.
</p><p>
But that's nothing compared to the rest of the experience. First come the
microphone problems. We all remember how it feels to struggle with a
balky microphone when giving a speech. Difficulties start with the very
first link in the system: Speech recognition is very sensitive to the
quality of material it is fed; this, in turn, varies greatly with the
microphone's position.
</p><p>
Knowing this, L&amp;H and IBM have adopted the same solution: They ask you to
wear a headset that combines microphone and earphone. This ensures a
reliable, repeatable setting for the delicate "position" variable. The
version of Dragon Systems I tried added a twist: They supply you with a
neat little digital dictation recorder that you can later connect to your
PC, and transfer your voice notes to the speech recognition system.
</p><p>
All three systems demand fairly extensive training that takes up to two
hours of your time. The idea is to let the system store variations of
repeated speech patterns in the way you dictate sentences and commands.
IBM astutely uses the training exercises to explain the difficulties
involved in recognizing speech, and outlines some techniques it uses to
distinguish between similar-sounding words. This is interesting, and a
good way to set expectations. Unfortunately, with all three products,
expectations are set too high. In particular, after I had "successfully"
completed a lengthy training sequence, I expected the system to work. It
didn't. In all cases, dictation yielded too many errors—I couldn't
manage two lines of text without several errors. And error correction, in
turn, proved too error prone: I had difficulty using voice commands to do
it, and had the same problem with other application and system actions.
Of course, I suspected my French accent. I'm sure it adds to the strain
on the poor system.
</p><p>
As a result of my difficulties, I did two things: I asked around and I
thought about the problem. Asking around, I had trouble finding the kind
of happy users depicted in the IBM commercials: I talk, it types, get
your own. I talk, it balks, take mine is closer to the actual experience.
Someone pointed me to a story done by an enterprising reporter who
contacted reviewers who had sung the praises of these products a few
months before. If memory serves, none of the reviewers used the products
they had praised.
</p><p>
As for thinking, I went back to the accent problem. This is a country of
many accents, both indigenous and foreign, and a country of immigrants.
Regardless of my own "challenges," these products do not appear to be
ready to serve users in the same way the mouse did when it was
introduced. It worked immediately, reliably, and for everyone. Voice
recognition has very good specialized uses, but it's not robust enough
for general use. I'm disappointed, because it would be nice to have a
voice-enabled BeOS, but it will have to wait for a new generation of
technology.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue4-11.html">Issue 4-11, March 17, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-13.html">Issue 4-13, March 31, 1999</a> </div><div id="footerB"><div id="footerBL"><a href="Issue4-11.html" title="Issue 4-11, March 17, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue4-13.html" title="Issue 4-13, March 31, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
