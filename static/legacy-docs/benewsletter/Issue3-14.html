<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-13.html" title="Issue 3-13, April 1, 1998" /><link rel="next" href="Issue3-15.html" title="Issue 3-15, April 15, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-13.html" title="Issue 3-13, April 1, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-15.html" title="Issue 3-15, April 15, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-13.html">Issue 3-13, April 1, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-15.html">Issue 3-15, April 15, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-14"></a>Issue 3-14, April 8, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-14"></a>Be Engineering Insights: How To Be Lazy....</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Dominic</span> <span class="surname">Giampaolo</span></span></div></div></div><p>
The best programmers I know write the least amount of code.
</p><p>
Seriously, being able to bang out thousands upon thousands of lines of
code is worthless if you're constantly re-inventing the wheel. In fact,
programmers that don't know how to reuse other people's work usually get
less done.
</p><p>
This article is about how to be lazy and get other programmers to do your
work for you. Aside from being a hustler and duping unsuspecting interns
into doing your job, this form of "laziness" can take many forms.
</p><p>
The first form of laziness is to know what tools are available to you as
a programmer. That means knowing what functions are in the libraries and
how to use them. I have seen programmers re-implement such basic
functions as <code class="function">scanf()</code> or <code class="function">strtol()</code> because they didn't know that these
functions existed in the libraries. I would have written that off as an
anomaly but I've now seen it numerous times. It definitely pays to buy a
standard C library and POSIX manual and know about what functions you
have at your disposal.
</p><p>
Here are a few of my favorites:
</p><ul class="itemizedlist"><li><p>
<code class="function">strerror()</code> - returns a string that explains an error code. Instead of
popping up a dialog saying error -2147459069 occurred you can say "No
Such File or Directory." There is a string for every single BeOS error
code.
</p></li><li><p>
<code class="function">sscanf()</code> is really powerful for parsing strings. It is a little
difficult to use but it's worth the effort. <code class="function">scanf()</code> has features to
skip over optional parts of a conversion or it can only read in a
specific number of characters of a string.
</p></li><li><p>
On a related note, the <code class="function">vs<code class="function">printf</code>()</code> and <code class="function">vsscanf()</code>
forms of <code class="function">s<code class="function">printf</code>()</code>
and <code class="function">scanf()</code> can be very handy if you want to write wrappers functions
for <code class="function"><code class="function">printf</code>()</code> and <code class="function">scanf()</code> (for example, to format text that will
eventually wind up in a dialog box). Knowing how to use the var-args
versions of library functions can save you time.
</p></li><li><p>
<code class="function">strotl()</code>, <code class="function">strotul()</code>
and <code class="function">strtod()</code> - these functions convert strings to
integers or <span class="type">double</span>s in any base (decimal, octal, or hex). There are
also versions for converting to long longs.
</p></li><li><p>
<code class="function">strftime()</code> is a super-powerful way to format dates and times. The
other standard C library date &amp; time routines (localtime, difftime,
asctime, ctime, etc.) offer lots of features as well.
</p></li></ul><p>
The Be Kits also offer you features that can save you time. Nosing around
in the BeOS Support Kit turns up a few very useful classes and
convenience functions (<code class="classname">BStopWatch</code>, UTF conversion functions, error
reporting/assertion macros, <code class="classname">BAutoLock</code>, etc.). Poke around and see what
you find. It's worth it to spend an hour or two reading documentation and
header files to know what's available.
</p><p>
Beyond the standard C library and the Be Kits there are large bodies of
code available on the 'net that implement various algorithms or
protocols. Searching around with a search engine usually turns up
something. Sometimes you get what you pay for and other times you really
do find a gem that saves you weeks of time.
</p><p>
Now if all my article did was to exhort people to call <code class="function">scanf()</code> and to
look on the 'net for code, it would hardly be much of an article
(although it is late and Valérie is hanging around with the shears). So
let's dig in to the real way to be lazy: Getting other programs to do
your work for you!
</p><p>
Often times there are command line programs that do something useful but
have no UI and are difficult to use. These programs usually languish,
crying out for a graphical savior to free them from Terminal hell so that
mere mortals will use them. The unenlightened programmer will toil
tirelessly to re-implement the entire command line program with a GUI.
The lazy programmer will simply write a graphical wrapper that
emancipates the poor command line app. The lazy programmer will also be
done long before the unenlightened programmer.
</p><p>
Even full-blown Be application programmers can be lazy. For example,
there may be a command line app that performs a nifty feature you'd like
to include in your application but you don't have the time or inclination
to implement it yourself. Knowing how to run a command line program and
manipulate its output may save you time and make your product better.
</p><p>
For example, the BeOS Expander app uses <code class="function">popen()</code> to communicate with zip,
tar, and friends so that it doesn't have to parse their file formats --
and it will be a snap to add other file formats in the future.
</p><p>
Here are some other ways in which lazy command line program thievery can
be useful:
</p><ul class="itemizedlist"><li><p>
communicating with the command line ftp program to enable a "save to
server" feature
</p></li><li><p>
using a command line tool like "diff" to implement a complex
algorithm so that your app can display and modify the results in a
pretty manner
</p></li><li><p>
communicating with complex text-filtering scripts in Perl or awk
</p></li><li><p>
filtering images using the NetPBM tools
</p></li></ul><p>
Now that we've seen why you might want to be lazy, let's talk about how
to be lazy. Just as in real life, there are different levels of laziness.
The most sloth-like approach is for an app to just call the POSIX
function <code class="function">system()</code>. The function <code class="function">system()</code>
takes a string and makes the
shell execute it. You don't get any direct output from the command and in
fact all you do get is a status value as returned by the shell that
executed the program. The <code class="function">system()</code> function is handy because you can
specify a full command line (including pipes, input and output
redirection, etc.). The downside is that <code class="methodname">system()</code> is synchronous so be
sure to spawn a thread to do the dirty work.
</p><p>
The next step up the ladder of indolence is to call
<code class="function">popen()</code>. <code class="function">popen()</code> lets
you specify a full command line, just as you would with <code class="function">system()</code>, plus it
provides you with a pipe to either the input or the output of the program
you are running. For example you might ask <code class="function">popen()</code> to give you the input
pipe to a program that performs a transformation on data that you write
to the pipe. On the other end, you may want the output pipe of a program
that prints some information that is needed in your program. The <code class="function">popen()</code>
call is very powerful.
</p><p>
Climbing another notch up the scale of torpidity you may find that you
need even finer grained control over the program that <code class="function">popen()</code> launches.
This may be necessary if you want to have a button in your GUI to pause
the operation or to abort it entirely. For this you want the program you
launch to be in its own process group and you need to know the thread ID
to send the signal to.
</p><p>
The following version of <code class="function">popen()</code> provides the necessary control:
</p><pre class="programlisting c">
<span class="type">FILE *</span>
<code class="function">my_popen</code>(<span class="type">const char *</span><code class="parameter">cmd</code>, <span class="type">const char *</span><code class="parameter">type</code>, <span class="type">long *</span><code class="parameter">tid</code>)
{
  <span class="type">int</span> <code class="varname">p</code>[2];
  <span class="type">FILE *</span><code class="varname">fp</code>;
  <span class="type">char *</span><code class="varname">args</code>[4];

  if (*<code class="parameter">type</code> != 'r' &amp;&amp; *<code class="parameter">type</code> != 'w')
    return <code class="constant">NULL</code>;

  if (<code class="function">pipe</code>(<code class="varname">p</code>) &lt; 0)
    return <code class="constant">NULL</code>;

  if ((*<code class="parameter">tid</code> = <code class="function">fork</code>()) &gt; 0) { <span class="comment">/* then we are the parent */</span>
    if (*<code class="parameter">type</code> == 'r') {
      <code class="function">close</code>(<code class="varname">p</code>[1]);
      <code class="varname">fp</code> = <code class="function">fdopen</code>(<code class="varname">p</code>[0], <code class="parameter">type</code>);
    } else {
      <code class="function">close</code>(<code class="varname">p</code>[0]);
      <code class="varname">fp</code> = <code class="function">fdopen</code>(<code class="varname">p</code>[1], <code class="parameter">type</code>);
    }

    return <code class="varname">fp</code>;
  } else if (*<code class="parameter">tid</code> == 0) {  <span class="comment">/* we're the child */</span>

    <span class="comment">/* make our thread id the process group leader */</span>
    <code class="function">setpgid</code>(0, 0);

    if (*<code class="parameter">type</code> == 'r') {
      <code class="function">fflush</code>(<code class="varname">stdout</code>);
      <code class="function">close</code>(1);

      if (<code class="function">dup</code>(<code class="varname">p</code>[1]) &lt; 0)
        <code class="function">perror</code>("dup of write side of pipe failed");
    } else {
      <code class="function">close</code>(0);

      if (<code class="function">dup</code>(<code class="varname">p</code>[0]) &lt; 0)
        <code class="function">perror</code>("dup of read side of pipe failed");
    }

    <code class="function">close</code>(<code class="varname">p</code>[0]); <span class="comment">/* close since we dup()'ed what we needed */</span>
    <code class="function">close</code>(<code class="varname">p</code>[1]);

    <code class="varname">args</code>[0] = "/bin/sh";
    <code class="varname">args</code>[1] = "-c";
    <code class="varname">args</code>[2] = (<span class="type">char *</span>)<code class="parameter">cmd</code>;
    <code class="varname">args</code>[3] = <code class="constant">NULL</code>;


    <code class="function">execve</code>(<code class="varname">args</code>[0], <code class="varname">args</code>, <code class="varname">environ</code>);
  } else {         <span class="comment">/* we're having major problems... */</span>
    <code class="function">close</code>(<code class="varname">p</code>[0]);
    <code class="function">close</code>(<code class="varname">p</code>[1]);
  }

  return <code class="constant">NULL</code>;
}
</pre><p>
Now if your graphical front end wants to pause the sub-process, it could
do:
</p><pre class="programlisting c">
<code class="function">kill</code>(-<code class="varname">tid</code>, <code class="constant">SIGSTOP</code>);
</pre><p>
and that will pause all the programs in that process group (which is
everything descended from the <code class="function">fork()</code>'ed thread).
The <code class="function">kill()</code> function is
the (poorly named) way to send signals. Using the negative of a thread id
sends the signal to all threads in that process group. A process group is
defined when a thread calls <code class="function">setpgid()</code> as our example does above. A
process group is a handy way to manipulate entire groups of threads.
</p><p>
If you wanted to continue the operation after pausing it, you would use:
</p><pre class="programlisting c">
<code class="function">kill</code>(-<code class="varname">tid</code>, <code class="constant">SIGCONT</code>);
</pre><p>
If you just want to abort the whole process, you can use:
</p><pre class="programlisting c">
<code class="function">kill</code>(-<code class="varname">tid</code>, <code class="constant">SIGINT</code>);
</pre><p>
Notice that we use <code class="constant">SIGINT</code> so that we give the programs a chance to clean
up after themselves. If we used <code class="constant">SIGKILL</code> the program would be killed
unceremoniously and could leave turds around the system.
</p><p>
The function <code class="function">my_popen()</code> handles quite a number of situations where you're
communicating with a command line program. But it's not quite enough in
all cases.
</p><p>
Some heavy-duty programs like Eddie and Pe have a worksheet feature that
requires controlling both the input and output of a program. The top rung
of the lethargy ladder requires a bit more work but provides the most
control over the sub-process. With two pipes, your program can feed input
to a command-line program and at the same time, read the output from
that program. Setting this up is only moderately more complicated than
what <code class="function">my_popen()</code> does and is left as an exercise to the non-lazy reader
(those who are smart will go look at pages 442 and 443 of the Stevens
book "Advanced Programming in the Unix Environment"). Controlling both
the input and output of a command line program lets you run interactive
programs such as ftp and manipulate them to do your bidding.
</p><p>
In summary, what I've tried to present in this article are options that
are open to you as a BeOS programmer. These options are useful but not
always appropriate. There are times when you just want something to work
quickly and the methods I've suggested here can help you get there. And
then there are other times when simply running a command line app doesn't
get you the right granularity of control. You have to make the decision
based on your constraints. Regardless of your final decision, it pays to
be aware of the options.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-14"></a>Developers' Workshop: Scripting Power and Wisdom</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Douglas</span> <span class="surname">Wright</span></span></div></div></div><p>
Jan's Deli makes great meatloaf sandwiches. They also have a bunch of
random other things lying around like chips and cookies and candy bars.
Last time I was there they had a new impulse-buy-product in front of the
deli counter: Power and Wisdom bars. The Power and Wisdom bars come in
some pretty strange flavors like Orange-Ginger-Jalepeno. This is of
course the new-age aware version of the plain old chocolate Powerbar. So
what does this have to do with Scripting? Well, in order for scripting to
be a really useful tool, it needs to have both power and wisdom, but
hopefully with good taste as well.
</p><p>
A few short weeks ago, I gave an overview of our scripting architecture
and a code snippet for filling up a list with some useful information
about the scriptability of running applications:
www.be.com/aboutbe/benewsletter/volume_II/Issue10.html#Workshop
</p><p>
The power of the Be scripting architecture is its ability to control
other applications' objects. The wisdom is in the way you can find out
about what "suites" any particular object supports so that you know how
to talk to it. So as I promised, I've put together a sample app called
Scripter that fills an outline list view with running applications:
ftp.be.com/pub/samples/application_kit/Scripter.zip
</p><p>
For each app you get a listing of its windows, and for each window a
listing of its views. If you <span class="type">double</span> click on one of these objet d'app, a
dialog is opened with a list of supported suites for that object and some
controls.
</p><p>
When the dialog is opened, a <code class="classname">BMessenger</code> is constructed to point at the
object that was clicked on. The controls in the dialog allow you to enter
specifiers for a message to be sent to the object. It works much like
attribute queries in the find panel in <span class="application">Tracker</span>. You start with one
specifier, and to add more click on the add button.
</p><p>
The specifiers are added to the message in the order they appear, which
is very important to the way scripting works. As a scripting message is
passed from one object to the next, specifiers are popped off the
"specifier stack."
</p><pre class="programlisting cpp">
<code class="classname">BMessage</code> <code class="varname">suite_msg</code>(<code class="constant">B_GET_PROPERTY</code>);
<code class="varname">suite_msg</code>.<code class="methodname">AddSpecifier</code>("Suites");
<code class="varname">suite_msg</code>.<code class="methodname">AddSpecifier</code>("View", "myView");
<code class="varname">suite_msg</code>.<code class="methodname">AddSpecifier</code>("Window", "myWindow");
</pre><p>
This message will get the Supported Suites for a View named <code class="varname">myView</code> in a
Window named <code class="varname">myWindow</code>, but only if you send it to an application with a
Window named <code class="varname">myWindow</code>. If you send this message directly to a Window, you
will get a reply message that says "Specifier not understood," because
Windows don't have a specifier called "Window".
</p><p>
In order to make it easy to try this app out, I made a little app called
FIR. What is FIR for? Well, it's a simple Finite Impulse Response
low-pass filter. It attenuates frequencies above a certain cut-off
frequency. FIR has one slider in its window that controls the cut-off
frequency. <code class="classname">BSlider</code>s inherit from
<code class="classname">BControl</code> and <code class="classname">BControl</code>s have a supported
suite of type suite/x-vnd.Be-control (surprise). So you can use Scripter
to send supported messages to FIR to get or set the value of the slider
and therefore the high frequency output of the filter. <code class="classname">BControl</code>s also
support messages to change the label, so you can try that out too.
</p><p>
You can easily define your own suites of scripting messages that your
objects will understand and respond to. Scripter will come in handy for
testing scripting capabilities that you add to your own app. In an
upcoming article I will demonstrate the creation of a suite. Until then,
look out for those wacky new-age "nutrition bars"!
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-14"></a>Where is it?</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
The downloadable version of Release 3 for Intel, that is. Wouldn't it be
a good idea, since we are born on or of the Web, to deliver the product
via the Web just as we take orders for it? After all, many companies --
including Be developers—do just that.
</p><p>
ESD, Electronic Software Distribution, is an important part of our
business model. It's the great equalizer that saves software developers
from the ruinous fight for shelf space and lets small start-ups compete
on (more) equal terms with the establishment.
</p><p>
So why don't we practice what we preach?
</p><p>
There are two answers to this very sensible question. One has to do with
size, the other one with the complexity of the installation process in an
ecumenical context—on a hard disk where valuable OS, programs and even
more valuable data already exist.
</p><p>
Let's start with size. On the BeOS Release 3 CD there are two partitions,
one for BeOS tools for Windows, about 5 megabytes, the other one for the
BeOS installation, about 290 megabytes. If we look at the details, we see
seven folders:
</p><pre class="screen">
/apps       —11.4 MB
/beos       —40.7
/demos      — 2.6
/develop    — 8.6
/home       — 1.4
/preferences—0 bytes for 18 files, and...
/optional   —a mere 202 MB of sounds, movies, and GNU goodies
</pre><p>
So why not jettison the optional directory and compress the rest for a
manageable 30 MB download? After all, downloading a new 20 MB Web browser
doesn't constitute an insurmountable problem.
</p><p>
Unfortunately, there are some hidden but photodegradable assumptions
here. A browser, once you install it, immediately does something useful:
It feeds off the contents of the Web and needs nothing else. For the
BeOS, we need to create a good initial user experience, that's why we
include as much material as possible with the operating system itself. We
can't (yet) rely on a huge "web" of applications "out there." Not
everyone inside Be agrees with me, some of my colleagues think we ought
to package a simple trial download for users interested in getting a
quick taste of our product and a feel for its speed. We'll keep you
posted as we debug our thoughts on this topic.
</p><p>
The other issue is the complexity of the tasks involved in downloading
and installing into the Windows world. In the current scheme, you have to
use some Be Tools to create a BeOS partition, and then you boot from the
floppy packaged with the CD. The computer "bites" on the floppy, the
bootloader reads from a BeOS partition on the CD, and the installation
procedure is reasonably smooth.
</p><p>
The "off-the-Web" version of the story is more complicated. Again, you
have to create a BeOS partition—so far we're even—but then you have
to download another DOS or Windows program to create a floppy for the
bootloading phase. Of course, without a CD the bootloader can't work
directly with a BeOS partition. Instead, it must reconstitute the BeOS
image by translating a downloaded Windows file (or files) from the
Windows partition into the freshly made BeOS partition.
</p><p>
We feel the CD process is much simpler and safer, and much more conducive
to a happy "out-of-the-box" experience. The partitioning exercise is
trouble enough.
</p><p>
While we don't yet offer the "instant" (after a few hours on-line)
gratification of a Web download, you can order the BeOS on our Web site
or get it via snail-mail, try it, and get a cheerful—really, we can't
afford unhappy customers—refund if we don't meet your needs or
expectations.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-13.html">Issue 3-13, April 1, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-15.html">Issue 3-15, April 15, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-13.html" title="Issue 3-13, April 1, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue3-15.html" title="Issue 3-15, April 15, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
