<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 4: 1999</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume4.html" title="Volume 4: 1999" /><link rel="prev" href="Issue4-35.html" title="Issue 4-35, September 1, 1999" /><link rel="next" href="Issue4-37.html" title="Issue 4-37, September 15, 1999" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue4-35.html" title="Issue 4-35, September 1, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue4-37.html" title="Issue 4-37, September 15, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 4: 1999</div></div><div id="headerB">Prev: <a href="Issue4-35.html">Issue 4-35, September 1, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-37.html">Issue 4-37, September 15, 1999</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue4-36"></a>Issue 4-36, September 8, 1999</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Marketing4-36"></a>Business &amp; Marketing: The New Be Website, Part 1: Version 1.0</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Michael</span> <span class="surname">Alderete</span></span></div></div></div><p>
Last week, I wrote about the process we went through in redesigning the
Be web site:
</p><p>
<a class="xref" href="Issue4-35.html#Marketing4-35" title="Business &amp; Marketing: The New Be Website, Part 1: Version 1.0">Business &amp; Marketing: The New Be Website, Part 1: Version 1.0</a>
</p><p>
All told, the process took us just under 8 weeks. By way of comparison,
to do a really thoroughly researched, well tested, intelligent redesign
of a web site the size of Be's usually takes 4-6 months, with 4 months
being rushed.
</p><p>
Obviously, to meet our deadline we made compromises in the design and
execution. Some of them, as I detailed last week, we knew about
beforehand. Others we learned about as the feedback started pouring in.
And pour it did!
</p><p>
For the most part, the reaction to the new site was very positive. Around
80-90% of the people liked the new design. Many people who wrote, whether
they liked the design or not, had excellent constructive criticisms of
the new design. Some people even sent us code, which helped us fix one
minor graphic pre-loading bug we had in our JavaScript (I sent that guy a
T-shirt :-).
</p><p>
We quickly developed a list of the top 5 issues people were raising,
which covered about 80% of the complaints we received (roughly in order):
</p><div class="orderedlist"><ol><li><p>
Where is the Developer section?
</p></li><li><p>
Where is BeWare?
</p></li><li><p>
Hate not having news and announcements on front page
</p></li><li><p>
Where is the Developer Newsletter?
</p></li><li><p>
Various graphics issues
</p></li></ol></div><p>
We fixed the Developer Newsletter issue almost immediately, by adding a
link to it in the World of Be section, an entry in the Site Map, and
changing the Site Search to default to searching both the Main and
Classic web sites (instead of just the Main site). The complaints on that
quickly went away.
</p><p>
The other issues were not so easy to address. For one thing, our two
person team was down to 1 for a large chunk of time; Mike Popovic took a
week of vacation right before PCExpo, and I was out of the office for
over a month (PCExpo, wedding, honeymoon). When I returned to work, Be
had gone public, and our #1 priority was getting our Investor Relations
section online. All told, we didn't begin working on a strategy to
address the harder parts of people's feedback until the beginning of
August.
</p><p>
Taking the feedback and our own impressions on the site, we developed a
two-stage plan to make the web site better. The *second* step is to go
back, and do what we wanted to do originally, which is take the 4-6
months to research our customers', developers', partners', and employees'
needs, develop a list of services on our web site that will meet those
needs, and implement a new web site that offers those services. We're
calling that Version 2.0 of the web site.
</p><p>
To address more pressing needs, the glaring flaws in the new site, we
developed a detailed list of things we could do quickly. These high "bang
for the buck" changes became known as Version 1.1.
</p><p>
Unlike many software products, we're rolling out components of v1.1 as we
develop them. By now we've made a number of changes, primarily to the
front page. Things you're likely to have noticed (not including additions
we've made in content):
</p><div class="orderedlist"><ol><li><p>
Developers button on the front page
</p></li><li><p>
A new Headline News section on the front page with catchy graphic
</p></li><li><p>
An accompanying Headline News page with more detail
</p></li><li><p>
The "Buy Now!" button on the front page
</p></li><li><p>
Major editing of the copy on the front page (shorter, more helpful)
</p></li><li><p>
A new Software for BeOS section, for BeWare and other software links
</p></li></ol></div><p>
We have a lot more in our queue, too. I'll share a few selected bits
here. We're not publishing a specific timeline, but you should see
elements from the following list appearing over the next 2 months.
</p><ul class="itemizedlist"><li><p>
A Software for BeOS button in the blue side navigation bar (replacing
BeOS in Action, which will move to the Products section)
</p></li><li><p>
Improved section sub-navigation graphics (not grayed out)
</p></li><li><p>
Title attributes for all navigational elements (some browsers display
this as a ToolTip when you hover over that element)
</p></li><li><p>
Improved SmartTemplates, with better JavaScript and better graphics
management (will improve browser cache hits)
</p></li><li><p>
Better search results page
</p></li><li><p>
Additional front page design improvements
</p></li><li><p>
Improved graphics format / compression
</p></li><li><p>
Improved, more consistent terminology used throughout the Be site
</p></li><li><p>
New sections and additional content
</p></li><li><p>
Database-driven listings of various resources
</p></li><li><p>
Many improvements in our back-end technologies, to make publishing
new information easier
</p></li></ul><p>
The place to keep your eyes for improvements and additions to the web
site is the What's New page (which is sort of hidden in the Website
section, another thing we'd like to fix):
</p><p>
&lt;http://www.be.com/website/whatsnew.html&gt;
</p><p>
You might notice something absent from the above lists, namely,
converting more of the "classic" Be web site to the new design. That *is*
on our list, but it's proceeding slowly. The reason is, we're evaluating
every section, every piece of content, and we're not moving things that
have not been thoroughly revised and updated. With the Web Team's limited
resources, and a higher priority given to new content, upgrading classic
content will probably still be happening in the year 2000.
</p><p>
Some sections, notably BeWare and the Developers section, *are* selected
for major overhauls, and will be converted to the main site at that time.
Other parts of Be will be participating in these overhauls, and we expect
to deliver greatly improved information and services in these areas.
</p><p>
Ultimately, though, how good the Be web site is will depend on continuing
to get good feedback from our site visitors, and on how well we listen to
it. I welcome your comments and suggestions, at &lt;alderete@be.com&gt; (but if
you've already sent it to &lt;webmaster@be.com&gt;, I have it, no need to send
again :-).
</p><p>
We're also actively researching the needs of our various groups of
visitors, an activity we hope to increase considerably as a part of the
Version 2.0 design process. Don't be surprised if we ask some of you to
participate in an online survey, or a focus group, some time in the next
6 months!
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-36"></a>Be Engineering Insights: Building the Future</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Allan</span> <span class="surname">Anderson</span></span></div></div></div><p>
I'm Allan, the build guy at Be. That means that this article isn't going
to be about the kernel. I build the CDs that go directly to you folks and
to OEMs. I also make the update packages, using the venerable
PackageBuilder. This is the sort of job that takes an eye for detail and
meticulous attention to the state of your product—especially with a
project the size of the BeOS. The pieces of any project can get mixed up,
however...leaving you wondering just what build your beta testers have,
and where you put that old build. Wait, did version 0.8a12 have the same
scrumpy twidlator as 0.8b5?
</p><p>
Being organized is one solution. Being Lazy (in the Larry Wall sense) is
another.
</p><p>
The tools I use to try to keep this beast in line are many. One of the
most useful is 'setversion'. Use it. Put a line in your makefile so that
every new build gets stamped with your current revision. Tack an internal
version onto your app with a build counter. Or just stamp it with the
date until you're ready to release it. If you use the BeIDE, make a
resource, or put it in a .r file that gets dynamically updated, or put a
shell script in your project. Set a variable called <code class="code">APP_VERSION</code> or
something to use the abstruse syntax required—something like:
</p><pre class="screen">
APP_VERSION== -app 1 2 4 f 0 -short 1.2.4 -long "1.2.4
"'echo -n -e '\302\251''" 1999 The Free Software
Foundation".
</pre><p>
This tells us that gzip (in this case) has an application version number
of 1.2.4, and is a final release. (The syntax for version numbering is
major middle minor variety internal, where variety is alpha, beta, final,
etc.). The escaped characters in the echo are for the copyright (left?)
symbol, natch. Now, if I do a Get Info from Tracker, there it is all
beautiful and official looking. That's great if you want to quickly
distinguish between builds. But what about some more automation, such as
during installation? Say your app ships with a library. To make sure that
your package doesn't clobber a newer version, keep your version numbers
up to date and choose the "Replace if newer version" option in
PackageBuilder.
</p><p>
Curious how to get at the details of the version info? It would be much
more handy to have the numbers than "blah blah copyright blah blah" if
you want to check for a greater revision. Well, it's pretty simple:
</p><pre class="programlisting cpp">
<span class="type">version_info</span> <code class="varname">info</code>;
<span class="type">version_kind</span> <code class="varname">kind</code> = <code class="constant">B_APP_VERSION_KIND</code>;

<code class="classname">BFile</code> <code class="varname">file</code>("versioned app", <code class="constant">B_READ_ONLY</code>);
<code class="classname">BAppFileInfo</code> <code class="varname">appFileInfo</code>(&amp;<code class="varname">file</code>);
<code class="varname">err</code> = <code class="varname">appFileInfo</code>.<code class="methodname">GetVersionInfo</code>(&amp;<code class="varname">info</code>, <code class="varname">kind</code>);
</pre><p>
You can find a slightly more fleshed out example in this program
(suitable for shell scripts):
</p><p>
&lt;ftp://ftp.be.com/pub/samples/storage_kit/Version.zip&gt;
</p><p>
With this tool, you can extract detailed information about a system's
state (version /system/Tracker) and make intelligent choices about your
installation. Knowing that a settings file has changed places or formats
from 1.x to 2.0 means that you can massage things just right. It can be
good to have fine detail of control, and having your stuff well and
automatically versioned is one way of doing that.
</p><p>
Surely by now your project has demanded the use of some form of source
control? There are two popular methods of source control available for
the BeOS: CVS, made increasingly popular by the many open-source
repositories that have cropped up as a way to keep the latest source
easily accessible; and Perforce, which is an attempt at doing source
control "right"—faster, with different features. CVS is great. You'll
need it to get the freshest source to Bezilla. Perforce is great, too. We
use it. So do the Perl people, I'm told. Perforce costs money, if you
aren't working on an open-source project. Anyhow, set up a simple source
repository. You can make it local to your machine if you like. Then, not
only can you easily roll back the stupid changes that you made late last
night, but you can use labels (or tags) to keep track of what consists of
a version. That way, you can always go back to a previous release, even
if your coding partner went crazy and rewrote the world.
</p><p>
Is this really lazier than keeping all your code on the desktop and
zipping it all up when you want to unlease it? Yes. It'll make life
easier a version or two down the road, and you can saunter from project
to project.
</p><p>
Get CVS from &lt;http://www.ninemoons.com/GG/&gt;<br />
Get Perforce from &lt;http://www.perforce.com/&gt;
</p><p>
There are many other tools that make your software projects easier to
manage. Building the infrastructure can really help out as programs and
teams get larger.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop4-36"></a>Developers' Workshop: Please Do Not Press this Button Again</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Christopher</span> <span class="surname">Tate</span></span></div></div></div><p>
One question we field regularly in DTS is how to detect and handle
multiple mouse clicks. On the face of it, it's not entirely clear what a
poor application is supposed to do; after all, the <code class="classname">BView</code> class's
<code class="methodname">MouseDown()</code> method doesn't supply any information other than the location
of the click. That alone isn't enough to distinguish two single-clicks
from a canonical "double-click"; one needs the timing information as
well. Or does one?
</p><p>
The Interface Kit is, indeed, keeping an eye on its internal stopwatch
when it reports mouse events to your application. The user-configurable
timing threshold is compared against the time between mouse-down events;
as the user accumulates multiple clicks within that threshold, a click
count is incremented. That count is passed to your application along with
each mouse-down <code class="classname">BMessage</code>, in a field called
(naturally enough) "clicks."
</p><p>
All this begs the question of how to access the information. Mouse-down
events are handled behind the application's back, so to speak; the
<code class="methodname">MouseDown()</code> method is called invisibly from within the BWindow class's
message dispatching logic. But there is a solution! <code class="classname">BWindow</code>s are, like
all BeOS message recipients, descendants of the <code class="classname">BLooper</code> class, and that
class provides a way for its methods to inspect the <code class="classname">BMessage</code> currently
being dispatched. The way a <code class="classname">BView</code> can determine the cumulative click
count associated with a <code class="methodname">MouseDown()</code> call is to look at the current
message being handled by the view's looper—i.e., its window.
</p><p>
You can see an example of this in today's sample application, called
<span class="application">DoubleClick</span>, available at this URL:
</p><p>
&lt;ftp://ftp.be.com/pub/samples/intro/DoubleClick.zip&gt;
</p><p>
The <span class="application">DoubleClick</span> application displays a window that indicates how many
consecutive clicks it receives. That determination is easy under the
BeOS, and doesn't require any calculations or state maintenance within
the application's code. In the <code class="classname">DoubleClickView</code>'s
<code class="methodname">MouseDown()</code> method, the
following two statements occur:
</p><pre class="programlisting cpp">
<span class="type"><code class="classname">BMessage</code>*</span> <code class="varname">msg</code> = <code class="methodname">Window</code>()-&gt;<code class="methodname">CurrentMessage</code>();
<span class="type">int32</span> <code class="varname">clicks</code> = <code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("clicks");
</pre><p>
That's all! The application can now choose an action to take based on the
click count. This implies that a multiple click consists of several
distinct <code class="methodname">MouseDown()</code> events, the first of which is indistinguishable from
an ordinary single- click action. This is deliberate: multiple-click
actions must always build on their fewer-click predecessors, not replace
them. A good example is the traditional word processor click sequence.
The first click positions the insertion point, the second highlights the
word around that point, the third highlights the entire line, and the
fourth selects the entire paragraph. Each stage is an extension of the
previous one; this is good design.
</p><p>
There is other information in the mouse-down <code class="classname">BMessage</code>, such as the
identity of the button that was pressed and the click location in the
view's and the main screen's coordinate systems. This raises issues that
complicate the subject of multiple-click detection. First, does it make
sense to consider two clicks that are "far apart" on the screen to
constitute a "double-click," presumably with modified behavior? Second,
does it make sense to treat a rapid sequence of clicks by different mouse
buttons as a "multiple click?"
</p><p>
<span class="application">DoubleClick</span> doesn't address the first issue, but it does handle the
second correctly. Briefly, the Official BeOS User Interface Decree is
that a "double-click" means two clicks of the same mouse button,
uninterrupted by other mouse buttons. It turns out that supporting this
definition involves some extra bookkeeping on the application's part,
because the mouse-down messages' "clicks" fields continue to increment
even when the user presses several different buttons in quick succession.
A fast primary-secondary-primary mouse button sequence winds up with the
third mouse-down message indicating a "clicks" value of 3. This is
patently wrong; each of these clicks should be treated as a distinct
single click. A tangled situation, no?
</p><p>
The way <span class="application">DoubleClick</span> unravels this snarl is to maintain two extra pieces
of information that describe the ongoing mouse- click sequence: the
identity of the last button pressed and its own click count specifically
for that button. Whenever a new button is pressed the ongoing count is
reset to one. Similarly, if the "clicks" field in the mouse-down BMessage
is ever equal to 1, that means the multiple-click timeout has expired and
click counting should be reset. The code that implements this logic looks
like this:
</p><pre class="programlisting cpp">
<span class="type"><code class="classname">BMessage</code>*</span> <code class="varname">msg</code> = <code class="methodname">Window</code>()-&gt;<code class="methodname">CurrentMessage</code>();
<span class="type">int32</span> <code class="varname">clicks</code> = <code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("clicks");
<span class="type">int32</span> <code class="varname">button</code> = <code class="varname">msg</code>-&gt;<code class="methodname">FindInt32</code>("buttons");

<span class="comment">// is this a continuing click sequence?</span>
if ((<code class="varname">button</code> == <code class="varname">mLastButton</code>) &amp;&amp; (<code class="varname">clicks</code> &gt; 1))
{
    <code class="varname">mClickCount</code>++;
}
else <code class="varname">mClickCount</code> = 1;
<code class="varname">mLastButton</code> = <code class="varname">button</code>;
</pre><p>
At this point, <code class="varname">mClickCount</code> is the correct number of clicks of the
relevant mouse button. The application should use that value in deciding
the appropriate action.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BitByBit4-36"></a>Bit By Bit: Quitting Applications</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Stephen</span> <span class="surname">Beaulieu</span></span></div></div></div><p>
This week's installment of Rephrase 0.1d4 reveals how Rephrase knows when
to quit.
</p><p>
The code for this article is the same as last week's:
</p><p>
&lt;ftp://ftp.be.com/pub/samples/tutorials/rephrase/rephrase0.1d4.zip&gt;
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id819516"></a>Programming Concepts</h3></div></div></div><p>
Quitting an application seems simple enough. When you send the
<code class="classname">BApplication</code> a <code class="constant">B_QUIT_REQUESTED</code>
message, it walks through all of its
windows and calls their <code class="methodname">QuitRequested()</code> function. If
<code class="methodname">BWindow::QuitRequested()</code> returns <code class="constant">true</code>,
<code class="methodname">BWindow::Quit()</code> is called and the
app moves on to the next window. If <code class="methodname">QuitRequested()</code>
returns <code class="constant">false</code>, the
process stops there.
</p><p>
The real question is how to determine if it's time to quit. The answer is
straightforward in one instance: if a Quit menu item is selected, it's
sent to the app, which starts to tear everything down.
</p><p>
In general, BeOS applications should also quit whenever their last window
is closed. More specifically, they should quit when their last important
window is closed, but not all windows are important in determining
whether an app should quit.
</p><p>
About boxes and document information windows are usually considered
supporting windows. An about box is purely informational and a document
information window is less useful without the actual document window.
Document windows and some file panels, on the other hand, are very
important. When the last important window closes, the app should be told
to quit, taking any supporting windows that are still visible with it.
</p><p>
Keeping track of important windows requires extra work.
<code class="methodname">BApplication::CountWindows()</code> returns a count of all windows associated
with the app. This would include supporting windows and hidden file
panels, neither of which should prevent the app from quitting. So an
application needs another count to track important windows.
</p><p>
As important as the count itself is the methodology for incrementing and
decrementing the count. After much discussion, we've come up with these
guidelines:
</p><ul class="itemizedlist"><li><p>
The application object holds a count of important windows.
</p></li><li><p>
The count is incremented directly from the application when it
creates a window.
</p></li><li><p>
The count is decremented when a message is received that an important
window is closed.
</p></li><li><p>
Open panels need to count as important windows when they are shown.
</p></li></ul><p>
The purpose of these guidelines is to eliminate potential race
conditions. For example, if the important window count is incremented
through messaging, a race can occur if the last document window was
closed immediately after selecting a list of files from the open panel.
The new windows created in response to the open request could enqueue
their notifications after the <code class="constant">WINDOW_CLOSED</code> message for the last visible
window. This in turn would cause the app to quit almost immediately after
creating the newly opened windows.
</p><p>
An almost identical problem can occur if the open panel is not considered
an important window. In this case, the application would quit when the
last document window closes, even if the open panel was showing or had
just been used to choose additional files to open.
</p><p>
One implication of this system is that the creation of new important
windows needs to be serialized through the application object. Supporting
windows can still be created without the app's help, but to keep the
count in sync, the app needs to create all important windows.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id819664"></a>Implementation details:</h3></div></div></div><div class="orderedlist"><ol><li><p>
<code class="classname">pEdit</code> is a new subclass of <code class="classname">BTextView</code>.
Its main job is to keep track
of whether a text view has changed. It does this by marking a "dirty"
flag whenever text is inserted into or deleted from the view.
[<code class="filename">pEdit.cpp</code>:52-64]
</p></li><li><p>
Closing a phrase display window should save its content if it is in
a dirty state. A <code class="classname">pDisplay</code> checks the state of the text view and if
it's dirty, creates an alert asking the user if it wants to save.
</p><p>
If a <code class="classname">pDisplay</code> needs to save when asked to close, it sets a quitting
flag and returns the results of the <code class="methodname">Save()</code>
function. <code class="methodname">Save()</code> returns a
boolean value denoting whether the save has been completed by the time
it returns. If a save file panel needs to be shown, it returns <code class="constant">false</code>,
as the window needs to wait asynchronously for the result.
[<code class="filename">pDisplay.cpp</code>:129-162 &amp; <code class="filename">pDisplay.cpp</code>:334-350]
</p></li><li><p>
In <code class="methodname">MessageReceived()</code> the phrase display window checks for the
quitting flag when handling <code class="constant">B_CANCEL</code> messages from the save panel. If
the quitting flag is set, it posts a <code class="constant">B_QUIT_REQUESTED</code> message to
complete the closing of the window.
[<code class="filename">pDisplay.cpp</code>:190-197]
</p></li><li><p>
Rephrase increments the phrase count whenever a new phrase display
window is created. The phrase count is also incremented when the open
panel is shown, to make sure the application doesn't quit until a
response from the file panel is received.
[<code class="filename">Rephrase.cpp</code>:130-132]
</p></li><li><p>
Rephrase decrements the phrase count whenever a phrase display
window or the open panel is closed. The open panel sends a <code class="constant">B_CANCEL</code>
message when it closes. The phrase display windows send a
<code class="constant">WINDOW_CLOSED</code> message to the app from
the <code class="classname">pDisplay</code> destructor.
[<code class="filename">Rephrase.cpp</code>:137-146 &amp; <code class="filename">pDisplay.cpp</code>:126]
</p></li><li><p>
Save panels don't count as important windows, as they are
associated with a phrase window (which does count). Instead, the
phrase window is responsible for dealing with the save panel, and
doesn't send the <code class="constant">WINDOW_CLOSED</code> message until after it has the info it
needs from the panel.
</p></li><li><p>
Use the phrase count in <code class="methodname">ReadyToRun()</code> to determine if an initial
phrase display window needs to be created.
[<code class="filename">Rephrase.cpp</code>:29-38]
</p></li><li><p>
All the current sizing and resizing functionality in <span class="application">Rephrase</span> is
related to the text rect of the text view. We have moved this
functionality into the new <code class="classname">pEdit</code> class.
[<code class="filename">pEdit.cpp</code>:15-38]
</p></li><li><p>
<code class="classname">pDisplay</code> keeps track of a static variable for naming empty
documents. All windows are created without a title, but the title is
set when a phrase is loaded. If the title is still empty afterwards,
it's set to "Untitled X" where X is the current untitled count.
[<code class="filename">pDisplay.cpp</code>:104-112]
</p></li><li><p>
The Quit menu item should correctly target the app. In previous
versions this item targeted the window, causing different behavior
when using the keyboard shortcut (the app quits) and selecting the
menu item (only the window closes).
[<code class="filename">pDisplay.cpp</code>:295-297]
</p></li></ol></div></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee4-36"></a>Going Public: Part II</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
Two weeks ago, I discussed some imprudent statements I'd made—and
immediately made another one: The second part of our IPO story will
appear next week. In keeping with one of our industry's less endearing
but nonetheless enduring traditions, I slipped the schedule. My excuse
was that I wanted to attend to the PowerPC issue. Following an e-mail
barrage, I attempted in last week's newsletter to explain our position
vis-à-vis IBM's announced PPC hardware and Apple's G3 and G4 machines.
For a recap see "<a class="xref" href="Issue4-35.html#Gassee4-35" title="Chips Questions">Chips Questions</a>"
</p><p>
Now, back to our IPO story. Wes Saia, our CFO, was looking at the weather
charts. This would be his third IPO and, in his experience, summer
months, August in particular, weren't good. Events have proved him to be
almost too right. In any event, Wes put us on a forced march to draft and
file our S-1 in 21 days, close to a record for this complex process.
</p><p>
The S-1 stands for "Form S-1 Registration Statement Under the Securities
Act of 1933," a document filed with the Securities and Exchange
Commission. To mix formal and informal language, the S-1 describes the
"deal" for the investors, the pros and cons of buying the proposed
securities—a description made in a highly regulated, some would say
ritualized, fashion.
</p><p>
The most intense part of S-1 preparation occurs in marathon sessions at
"the printers." In this case, we mean financial printers, companies such
as R.R. Donnelly, who help with documents involved in various financial
transactions, mergers, acquisitions, IPOs, debt offerings, and the like.
When type was set by hand or with Linotype machines, one sat in the
printer's office and edited proofs. Printers made room in their offices
for groups of people arguing over the documents being composed. When
typesetting and printing became DTP, meeting rooms became the center of
the business.
</p><p>
The Palo Alto offices of R.R. Donnelly make that point rather eloquently.
In order to facilitate the drafting and filing process, they're open 24
hours a day, with staff and facilities the best hotels might envy.
There's valet parking, a very good cafeteria, and shaving cream, lotion,
and eye drops in the men's room. Meeting rooms have network connections,
conference telephones that work, and a staff with a pleasant can-do
attitude. Not to mention champagne and cigars (in politically correct
Palo Alto!!) for celebrations.
</p><p>
There are two ways to look at this. Either it's another effete display of
opulence or it's an extremely effective life-support system for this part
of the IPO process. As far as I'm concerned, I saw red eyes and pale
faces—and gratitude for the tools of the trade and the creature
comforts.
</p><p>
In this context, the drafting process is a strange mixture of a
collaborative and an adversarial process, involving company executives,
public accountants, investment bankers and counsel for both the company
and the bankers. Arguments range from esoteric accounting issues to
something that makes marketing people very sad: removing adjectives. We
also had to deal with what is known as Plain English, a relatively new
SEC rule requiring filings to be readable by normal humans, as opposed to
lawyers and bankers. Unsurprisingly, industry insiders aren't crazy about
this restriction. We have our way of writing these statements, and it
works—but it's also important for individual investors not to feel
shut out by language. I was impressed by the "Plain English" comments we
got back from our examiner at the SEC—good suggestions to improve
readability, without nit-picking, obviously from a very literate
individual. Not the stereotypical civil servant, especially considering
my cultural origins.
</p><p>
The requirement for complete and accurate disclosure isn't limited to
exquisitely painful accounting disquisitions; there's also what's known
as the Risk Factors. There, the logic of the process dictates spelling
out in detail everything that could go wrong. This makes for painful or
comical reading. Management could be incompetent, the technology could be
irrelevant, the market nonexistent, the competition muscular and
ruthless, the Year 2000 could kill us, and, if none of that happens,
lawyers could take us to the cleaners, to name but a few risks in the
litany.
</p><p>
Finally, on May 6th, we filed our S-1 with the SEC, expecting comments in
about 30 days. In the midst of the busiest IPO season ever, we were
fortunate to get SEC comments on schedule. About half the comments were
the "Plain English" ones already mentioned and, in total, the volume was
less than half of what is considered typical for a filing like ours. Just
as important, none of the comments raised difficult, show-stopper issues.
This in itself was a compliment to Wes and the rest of the team. Speed
had not harmed quality.
</p><p>
Now, we were faced with a decision. We could file our response and wait
for the SEC's return comments, or we could move to the next step, the
Road Show, and spend over $10,000 printing a version of our filing called
"the reds" to distribute to the investors we were going to meet. The risk
was that the SEC could raise difficult issues, material enough to force
us to print a new set of reds or, worse, raise questions in the minds of
investors. Encouraged by the initial response from the SEC, we decided to
go ahead with to the next phase, the Road Show—72 presentations to
investors in Europe and the US.
</p><p>
I had heard many Road Show horror stories. Fortunately, most proved
untrue, as I'll discuss next week in Going Public: Part III—unless
e-mail traffic decides otherwise.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue4-35.html">Issue 4-35, September 1, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-37.html">Issue 4-37, September 15, 1999</a> </div><div id="footerB"><div id="footerBL"><a href="Issue4-35.html" title="Issue 4-35, September 1, 1999"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume4.html" title="Volume 4: 1999"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue4-37.html" title="Issue 4-37, September 15, 1999"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
