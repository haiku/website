<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-18.html" title="Issue 3-18, May 6, 1998" /><link rel="next" href="Issue3-20.html" title="Issue 3-20, May 20, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-18.html" title="Issue 3-18, May 6, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-20.html" title="Issue 3-20, May 20, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-18.html">Issue 3-18, May 6, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-20.html">Issue 3-20, May 20, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-19"></a>Issue 3-19, May 13, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-19"></a>Be Engineering Insights: The Tracker Is Your Friend</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Scott</span> <span class="surname">Barta</span></span></div></div></div><p>
When I came aboard at Be in January to begin my headlong dive into the
guts of <span class="application">NetPositive</span>, I quickly learned that one of the features most
often requested was a hierarchical bookmark menu, along with better
bookmark management than what PR2 offered (which was essentially
nothing). Based on experience with other browsers and platforms, my usual
response was to stare at my shoes and mumble something about how I should
someday implement a bookmark manager <span class="foreignphrase"><em class="foreignphrase">à la</em></span>
<span class="application">Netscape</span> or <span class="application">Internet Explorer</span>.
Most people's response was, "No, use the <span class="application">Tracker</span> instead. It's the Be way
of doing things."
</p><p>
For the Release 3 release, at Pavel's prodding, I changed the bookmark data
format to use the attribute defined by the
<code class="filename">x.vnd-Be.bookmark</code> file type for storing the bookmark
<acronym class="acronym" title="Uniform Resource Locator">URL</acronym>, and made sure
that bookmarks were given this type when saved. This opened up
<span class="application">NetPositive</span> bookmarks for editing in
<span class="application">Tracker</span> windows by allowing users to display and
edit the <acronym class="acronym">URL</acronym> attribute of bookmarks in the
<span class="application">Tracker</span> list view of
<span class="application">NetPositive</span>'s
<code class="filename">Bookmarks</code> directory. In retrospect, I should
probably have modified the code to use the <code class="varname">Title</code>
bookmark attribute as well, instead of relying on the filename for the
bookmark's title, as this would have prevented a few weird quirks in
bookmark naming.
</p><p>
In my post-Release 3 work (which you'll see in the R4 release of
NetPositive, or very likely sooner in an interim release after Release
3.1), I've extended the relationship between <span class="application">NetPositive</span>
and the <span class="application">Tracker</span>
for handling bookmarks—I use NodeMonitors to keep informed of changes
to the <code class="filename">Bookmarks</code> directory so
I can update my Bookmarks menu on the fly.
I also allow the user to create hierarchies in the Bookmarks menu by
creating subdirectories in the <code class="filename">Bookmarks</code> directory.
</p><p>
Having done this work, I'm now a complete convert to using the <span class="application">Tracker</span> to
manage your data. I've found that combining file directories with custom
attributes, <span class="application">Tracker</span> management of those files, and NodeMonitors to keep
you up to date on changes, is a powerful way to manage lists of
information with minimal work on your part, while providing users with a
lot of power over that data through an already familiar interface. I plan
to extend <span class="application">NetPositive</span> to manage site passwords, cookies, and other
information in this way, without the need to come up with a new user
interface and storage format for each type of information.
</p><p>
So where should you use this sort of mechanism in your applications?
Anywhere you need user-maintained lists of information; examples include
bookmarks, recent or favorite documents (you could maintain a directory
of symlinks to do this), shortcuts, macros, plug-ins, etc. It's probably
best suited to applications where the list of information is relatively
short (i.e., dozens of items); it's not be the best way to maintain a
user spelling dictionary.
</p><p>
How is it done? Follow these steps:
</p><div class="orderedlist"><ol><li><p>
Define a file type with the custom attributes you need. For those
attributes, set up the information that will make the attributes
visible to the Tracker and editable by it. For more information on how
to do this, see Doug Fulton's article in Be Newsletter Volume 3 Issue
11, "<a class="link" href="">How To Get Tracker to See Your Attributes</a>".
</p></li><li><p>
Save those files in a directory someplace meaningful to your
application.
</p></li><li><p>
Set up a Node Monitor for that directory that will catch additions,
deletions, and name changes inside the directory.
</p></li><li><p>
Since the directory Node Monitor will not receive notifications of
attribute changes to files inside the directory, you need to set up a
separate Node Monitor for each file in the directory to do this. Since
Node Monitors are a limited system resource, this is a good reason to
use this mechanism only for relatively small lists. Whenever the
directory Node Monitor receives notification for added, deleted, and
moved files, add and remove Node Monitors for those files as
appropriate.
</p></li><li><p>
At program launch, read through the files in the directory, slurp
out their attributes, and store them in a meaningful internal
representation. When you receive notification from one of the Node
Monitors of a change, update your data and take appropriate action.
</p></li><li><p>
When you receive a Node Monitor message, munge the low-level
information it gives you into a meaningful format that you can deal
with. This is actually a pretty hard thing to do because the Node
Monitor interface is so low-level as to be an extreme pain in the neck.
</p></li></ol></div><p>
"So where's some code I can copy and paste?" you ask. I've written a
handy FolderWatcher class that does most of these tasks for you. Due to
its length (close to 1,000 lines of code), it's not included here, but
you can get it from our sample code archives at
ftp://ftp.be.com/pub/samples/storage_kit/FolderWatcher.zip
</p><p>
The sample code includes the <code class="classname">FolderWatcher</code> class and a simple application
that creates some folders in your home directory, adds a few bookmark
files to them, and then spits out any messages it gets back from the
FolderWatcher. It's a command line program and has no
<acronym class="acronym" title="Graphical User Interface">GUI</acronym>, so the
application itself isn't very useful, but it should show you how to use
the <code class="classname">FolderWatcher</code>.
</p><p>
To use this class, create a separate <code class="classname">FolderWatcher</code> instantiation for each
folder that you wish to watch. In the constructor, pass in a <code class="classname">BEntry</code> to
the directory to be observed, the file type of the file of interest, the
signature of the preferred application for the files, and the <code class="classname">BLooper</code> to
be notified when something interesting happens. If you want, the
<code class="classname">FolderWatcher</code> can create the folder if it doesn't already exist.
</p><p>
Once the <code class="classname">FolderWatcher</code> is created, call
<code class="methodname">Init()</code> on it to kick it off. It
will set up the Node Monitor on the folder, iterate through each matching
file in the folder, set a Node Monitor on it, and send your application a
FolderWatcher::FileAdded message for it so you can add it to your
internal list. <code class="methodname">Init()</code> creates a
<code class="classname">BMessageFilter</code> and inserts it into the
<code class="classname">BLooper</code>'s message loop so that it can spy on the Node Monitor messages
that come back, and convert them to a friendlier form. It should behave
itself and not eat Node Monitor messages that don't pertain to the
folders it's watching.
</p><p>
I've found that for simple cases like I'm assuming here, a <code class="classname">BMessage</code> is a
good way to represent attribute data, since <code class="classname">BMessage</code>s can contain the
type/name/value triplets that attributes use. Therefore, I use <code class="classname">BMessage</code>s
for passing attributes back and forth in the <code class="classname">FolderWatcher</code> interface.
Note, however, that <code class="classname">FolderWatcher</code> will become extremely inefficient if
you store large amounts of attribute data in these files.
</p><p>
To create new files in the folder, you can do it yourself or call
<code class="classname">FolderWatcher</code>::<code class="methodname">AddFile()</code>, passing in the
filename a <code class="classname">BMessage</code> containing
the attribute data to be put into the file. Similarly, to remove a file,
you can call <code class="methodname">RemoveFile()</code>, passing the filename; to change a file's
attribute, call <code class="methodname">ChangeFile()</code>, passing the
filename and a <code class="classname">BMessage</code>. These
functions will cause notification messages to be sent back to inform you
of the change, so be ready for it.
</p><p>
If you don't need to watch the folder anymore, delete the <code class="classname">FolderWatcher</code>
instance; it will clean up silently (without sending further messages
back to you).
</p><p>
All other communication with the <code class="classname">FolderWatcher</code> occurs as messages sent
back to your <code class="classname">BLooper</code> when something happens:
</p><ul class="itemizedlist"><li><p>
<code class="classname">FolderWatcher</code>::<code class="varname">FileAdded</code>—A new file has been added to the
directory, either due to user action in the <span class="application">Tracker</span>, or because your
application has added a file.
</p><pre class="screen">
Message data:
  "Filename" (String): The name of the file that was
    added.

  "FolderWatcher" (Pointer): The <code class="classname">FolderWatcher</code> that is
    watching this file.

  "AttrData" (BMessage): The file's attributes, stored in
    a <code class="classname">BMessage</code>.
</pre></li><li><p>
<code class="classname">FolderWatcher</code>::<code class="varname">FileRemoved</code>—A new file was removed from the
directory, either due to user action or because of your application.
</p><pre class="screen">
Message data:
  "Filename" (String): The filename of the file that was
    removed.

  "FolderWatcher" (Pointer): The <code class="classname">FolderWatcher</code> that is
    watching this file.
</pre></li><li><p>
<code class="classname">FolderWatcher</code>::<code class="varname">FileChanged</code>—An attribute of a file was changed,
either due to user action or because of your application.
</p><pre class="screen">
Message data:
  "Filename" (String): The filename of the file that was
    changed.

  "FolderWatcher" (Pointer): The <code class="classname">FolderWatcher</code> that is
    watching this file.

  "AttrData": The attributes of the file that changed.
    Since the Node Monitor doesn't actually tell you which
    attribute changed, neither do we; you get all of the
    attributes in the file.
</pre></li></ul><p>
As it is written, the class doesn't recurse into subdirectories, so that
might be a good way to modify it if you want to enhance its capabilities.
(In case you're wondering, this class was written after I implemented
hierarchical bookmarks in <span class="application">NetPositive</span>; I'm going to go back and shoehorn
in a modified version of this class later.) Another suggestion would be
to modify <code class="methodname">AddFile()</code> to let it automatically generate a filename for a
file if you don't want to do it yourself.
</p><p>
As a final warning, the code hasn't been stringently tested, so caveat
emptor. If you find problems, though, let me know and I'll fix them and
update the sample code archive. Happy coding!
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id690741"></a>Be Acquires StarCode</h2></div></div></div><p>
Be's success depends on the creation of a solid BeOS applications market
and online commerce model. We strive to give our developers the best
engineering resources and support, so they can develop the best
applications for the BeOS. Now we will also provide them with the tools
they need to successfully market their product. To this end, Be has
recently acquired <span class="orgname">StarCode</span>, Inc. of Redwood City, CA.
</p><p>
<span class="orgname">StarCode</span>'s products, <span class="application">BeDepot</span>,
<span class="application">Software Valet 1.5</span> for Intel and PPC, and
<span class="application">PackageBuilder</span> will be integrated into the line of Be products and
services. This integration will allow Be to provide developers and
end-users with software management solutions and with an online commerce
system for selling and buying BeOS applications over the web.
</p><p>
Developers will have the tools to market their BeOS applications
efficiently and conveniently, and users will have the means to easily and
quickly access a wide range of BeOS products. StarCode and Be are working
together to ensure a smooth transition and integration. Over time, Be
will incorporate these products and services into our developer program.
</p><p>
Software Valet is an installer/deinstaller technology for the Beos, and
will provide developers and users with a consistent reliable means of
installing applications, updates, drivers, and other good stuff.
</p><p>
Package Builder provides tools for creating downloadable and
installable/deinstallable applications and updates.
</p><p>
BeDepot is an online commerce system for selling applications over the
web.
</p><p>
Tune in to our web site, as more information will progressively be
available, or write to info@be.com.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-19"></a>Developers' Workshop: BeOS Programming Basics: Part 3</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Eric</span> <span class="surname">Shepherd</span></span></div></div></div><p>
Last time, we created a simple application with a menu bar that the user
could play with. We also poked a toe into the waters of the BMessage
class, but I skimmed over the details, leaving you high and dry until
this week's exciting episode. If you haven't read parts 1 and 2 of this
series, you really ought to do so:
<a class="link" href="">Issue 3-#7</a>
<a class="link" href="">Issue 3-#13</a>
</p><p>
As promised, this week we're going to delve a little more deeply into
messaging on the BeOS. In particular, we're going to add support for
multiple windows to the <span class="application">MenuWorld</span> application from last time, using
messages to keep track of how many windows are open, and to ensure that
no two untitled windows get the same name.
</p><p>
To accomplish this magnificent feat of software engineering, we're going
to extend the <code class="classname">HelloApp</code> class to serve as a registry for our windows.
Whenever a new window is opened within the <span class="application">MessageWorld</span> application, that
window tells the <code class="classname">HelloApp</code> object that a new window has been opened.
<code class="classname">HelloApp</code>, in return, lets the new window know what its name should be.
</p><p>
As always, you might want to have your Web browser aimed at the Be Book
so you can read the more detailed descriptions of the functions discussed
here; we won't be covering anything in complete detail, but just taking a
look at how things might be done, to give you a place to start.
</p><p>
We begin with the <span class="application">MenuWorld</span> application from last time. Before getting
into messaging, let's take a look at a minor change to the <code class="classname">HelloWindow</code>
constructor. It was pointed out on the BeDevTalk mailing list that
<span class="application">MenuWorld</span> was assuming that the menu bar was always going to be 20 pixels
tall, which is not a safe assumption to make.
</p><p>
Additionally, there are a couple of minor changes needed so the window
can register itself with the application object.
</p><p>
So the <code class="classname">HelloWindow</code> constructor now does the following:
</p><pre class="programlisting cpp">
<code class="classname">HelloWindow</code>::<code class="methodname">HelloWindow</code>(<code class="classname">BRect</code> <code class="parameter">frame</code>)
           : <code class="classname">BWindow</code>(<code class="parameter">frame</code>, "Untitled ", <code class="constant">B_TITLED_WINDOW</code>,
               <code class="constant">B_NOT_RESIZABLE</code>|<code class="constant">B_NOT_ZOOMABLE</code>) {
  <code class="classname">BRect</code> <code class="varname">r</code>;
  <span class="type"><code class="classname">BMenu</code> *</span><code class="varname">menu</code>;
  <span class="type"><code class="classname">BMenuItem</code> *</span><code class="varname">item</code>;

  <span class="comment">// Add the menu bar</span>

  <code class="varname">r</code> = <code class="methodname">Bounds</code>();
  <code class="varname">menubar</code> = new <code class="classname">BMenuBar</code>(<code class="varname">r</code>, "menu_bar");
  <code class="methodname">AddChild</code>(<code class="varname">menubar</code>);

  <span class="comment">// Add File menu to menu bar</span>

  <span class="comment">/* same code as last time */</span>

  <span class="comment">// Add Options menu to menu bar</span>

  <span class="comment">/* same code as last time */</span>

  <span class="comment">// Add the drawing view</span>

  <code class="varname">r</code>.<code class="varname">top</code> = <code class="varname">menubar</code>-&gt;<code class="methodname">Bounds</code>().<code class="varname">bottom</code>+1;
  <code class="methodname">AddChild</code>(<code class="varname">helloview</code> = new <code class="classname">HelloView</code>(<code class="varname">r</code>));

  <code class="methodname">Register</code>(<code class="constant">true</code>);
  <code class="methodname">Show</code>();
}
</pre><p>
The menu bar is now added using the full bounds rectangle of the window.
This is safe to do because, as described in the Be Book, the
<code class="classname">BMenuBar</code> constructor resizes the height of a menu
bar to the correct value. Then we add all the menus to the menu bar. Once
that's done, the drawing view is created. The frame rectangle of the
drawing view is determined by taking the bounds rectangle of the window,
and setting the top edge of that rectangle to one greater than the bottom
edge of the menu bar's bounds rectangle—this results in a view that
fills the remainder of the window.
</p><p>
We've also added a call to the new <code class="methodname">Register()</code> function (which we'll look
at later). This registers the new window's existence with the
application, and causes the application to assign the new window a number.
</p><p>
Note also that we've changed the title of the <code class="classname">HelloWindow</code>
to "Untitled ".
This isn't important, but it seemed like a good idea.
</p><p>
There are three basic classes in the BeOS messaging system. These are:
</p><ul class="itemizedlist"><li><p>
<code class="classname">BMessage</code>.<br />
The <code class="classname">BMessage</code> is the class that represents a bundle of
information that is sent from one place to another. This class includes
functions for adding, changing, and removing named fields of data.
</p></li><li><p>
<code class="classname">BMessenger</code>.<br />
The <code class="classname">BMessenger</code> class handles transmitting
<code class="classname">BMessage</code> objects from one place to another. Its
central function, <code class="methodname">SendMessage()</code>, does the actual
job of transmitting messages. Upon construction, the
<code class="classname">BMessenger</code>'s target (the
<code class="classname">BHandler</code> that will receive messages it transmits) is
specified. The target can't be changed.
</p></li><li><p>
<code class="classname">BHandler</code>.<br />
The <code class="classname">BHandler</code> class receives
<code class="classname">BMessage</code> objects that are sent
to it, and can optionally reply to those messages. It can't initiate a
transaction.
</p></li></ul><p>
When a message is sent, the application server delivers it to a
<code class="classname">BHandler</code> by calling that
<code class="classname">BHandler</code>'s
<code class="methodname">MessageReceived()</code> function. The message is passed
into <code class="methodname">MessageReceived()</code>, which interprets the
message and acts upon it as necessary. The <code class="classname">BHandler</code>
may choose to reply to the message by calling the message's
<code class="methodname">SendReply()</code> function, but this isn't necessary.
</p><p>
The <code class="classname">BView</code> class is derived from
<code class="classname">BHandler</code>; a view can receive and respond
to messages. That's how user commands are received—messages indicating
mouse and keyboard activity are delivered to the view, which interprets
and acts upon them.
</p><p>
If you flip through the Be Book for a while, you'll notice that
<code class="classname">BLooper</code> is derived from
<code class="classname">BHandler</code>. <code class="classname">BLooper</code> is a handy
class that establishes a thread that runs a message loop repeatedly until
the loop's Quit() function is called. But the really good stuff (at least,
as far as we're concerned today) happens when you look at some of the
classes derived from <code class="classname">BLooper</code>, such as
<code class="classname">BApplication</code> and <code class="classname">BWindow</code>.
</p><p>
A <code class="classname">BApplication</code> object is instantiated, then you call
its <code class="methodname">Run()</code> function. Once you've done that, it
doesn't return until its <code class="methodname">Quit()</code> function is
called. Its <code class="methodname">MessageReceived()</code> function, which is
inherited from <code class="classname">BHandler</code>, processes incoming
messages.
</p><p>
Likewise, a <code class="classname">BWindow</code> loops, handling incoming
messages in its <code class="methodname">MessageReceived()</code> function, until
its <code class="methodname">Quit()</code> function is called. The only difference
is that you don't call a <code class="methodname">Run()</code> function; this is
done implicitly for you. It's still a <code class="classname">BLooper</code>, and
it can still receive messages, just like anything derived from
<code class="classname">BHandler</code>.
</p><p>
So now we know that <code class="classname">BApplication</code> and
<code class="classname">BWindow</code> are both capable of handling
messages (in fact, we saw this last time, when we added code to our
<code class="classname">HelloWindow</code> class to process incoming
messages indicating that the menu
bar was being used).
</p><p>
Let's add the registry code to the <code class="classname">HelloApp</code> class.
We'll need to add the <code class="methodname">MessageReceived()</code> function,
as well as two new private variables:
</p><pre class="programlisting cpp">
class <code class="classname">HelloApp</code> : public <code class="classname">BApplication</code> {
  public:
    <code class="methodname">HelloApp</code>();
    virtual <span class="type">void</span> <code class="methodname">MessageReceived</code>(<span class="type"><code class="classname">BMessage</code> *</span><code class="parameter">message</code>);

  private:
    <span class="type">int32</span> <code class="varname">window_count</code>;
    <span class="type">int32</span> <code class="varname">next_untitled_number</code>;
};
</pre><p>
The window_count variable keep tracks of how many windows our application
has open (there's actually a <code class="classname">BApplication</code> function that does this, but
we're going to keep track of it ourselves for educational purposes).
next_untitled_number tracks the number to use when naming a new untitled
window (such as "Untitled 42"). This number always increases, so we'll
never see the same number twice.
</p><p>
The <code class="classname">HelloApp</code> constructor needs to be updated to initialize these
variables:
</p><pre class="programlisting cpp">
<code class="classname">HelloApp</code>::<code class="methodname">HelloApp</code>()
        : <code class="classname">BApplication</code>(<code class="constant">APP_SIGNATURE</code>) {
  <code class="classname">BRect</code> <code class="varname">windowRect</code>;
  <code class="varname">windowRect</code>.<code class="methodname">Set</code>(50,50,349,399);

  <code class="varname">window_count</code> = 0;      <span class="comment">// No windows yet</span>
  <code class="varname">next_untitled_number</code> = 1;    <span class="comment">// Next window is "Untitled 1"</span>
  new <code class="classname">HelloWindow</code>(<code class="varname">windowRect</code>);
}
</pre><p>
When the application is first run, there aren't any open windows, and the
first window is called "Untitled 1".
</p><p>
The window registry—the mechanism by which the application counts and
names windows—is handled entirely by accepting and responding to two
application-defined messages:
</p><pre class="programlisting cpp">
<span class="type">constuint32</span> <code class="constant">WINDOW_REGISTRY_ADD</code>    = 'WRad';
<span class="type">constuint32</span> <code class="constant">WINDOW_REGISTRY_SUB</code>    = 'WRsb';
</pre><p>
<code class="constant">WINDOW_REGISTRY_ADD</code> messages will be sent
to the <code class="classname">HelloApp</code> object when a
new window is opened and needs to be added to the registry.
<code class="constant">WINDOW_REGISTRY_SUB</code> messages will be sent to remove
a window from the registry as it's being closed.
</p><p>
The <code class="classname">HelloApp</code> needs to be able to reply
to <code class="constant">WINDOW_REGISTRY_ADD</code> messages so
that it can tell the window what number to use when giving itself a new
"Untitled" name. So we need to define a command code for this reply
message:
</p><pre class="programlisting cpp">
<span class="type">constuint32</span> <code class="constant">WINDOW_REGISTRY_ADDED</code> = 'WRdd';
</pre><p>
Now let's look at <code class="classname">HelloApp</code>'s
<code class="methodname">MessageReceived()</code> function. This will be
called by the application server whenever a message is delivered to the
HelloApp object:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="classname">HelloApp</code>::<code class="methodname">MessageReceived</code>(<span class="type"><code class="classname">BMessage</code> *</span><code class="parameter">message</code>) {
  <code class="methodname">switch</code>(<code class="parameter">message</code>-&gt;<code class="varname">what</code>) {
</pre><p>
The function begins by looking at the <code class="classname">BMessage</code>'s command code. This
32-bit value is located in the public <code class="varname">what</code>
variable in the <code class="classname">BMessage</code>
class, and specifies what type of message has been received. If it's a
<code class="constant">WINDOW_REGISTRY_ADD</code> message, we do the following:
</p><pre class="programlisting cpp">
    case <code class="constant">WINDOW_REGISTRY_ADD</code>:
      {
        <span class="type">bool</span> <code class="varname">need_id</code> = <code class="constant">false</code>;

        if (<code class="parameter">message</code>-&gt;<code class="methodname">FindBool</code>("need_id", &amp;<code class="varname">need_id</code>) == <code class="constant">B_OK</code>) {
          if (<code class="varname">need_id</code>) {
            <code class="classname">BMessage</code> <code class="varname">reply</code>(<code class="constant">WINDOW_REGISTRY_ADDED</code>);
            <code class="varname">reply</code>.<code class="methodname">AddInt32</code>("new_window_number",
                           <code class="varname">next_untitled_number</code>);
            <code class="parameter">message</code>-&gt;<code class="methodname">SendReply</code>(&amp;<code class="varname">reply</code>);
            <code class="varname">next_untitled_number</code>++;
          }
          <code class="varname">window_count</code>++;
        }
        break;
      }
</pre><p>
Before handing the <code class="constant">WINDOW_REGISTRY_ADD</code> function, we
look at the <code class="varname">need_id</code> field of the message. If it's
<code class="constant">true</code>, the window needs to be assigned an ID number
(since the window is untitled). If <code class="varname">need_id</code> is
<code class="constant">false</code>, the window doesn't need an ID. This will be
used when we add the ability to open existing documents, which will already
have names, and won't need to have an "Untitled" name.
</p><p>
If <code class="varname">need_id</code> is <code class="constant">false</code>, a new
<code class="classname">BMessage</code>, called <code class="varname">reply</code>, is
created, with the command code <code class="constant">WINDOW_REGISTRY_ADDED</code>.
This is the message we'll send back to the
<code class="classname">HelloWindow</code> object as a reply once we've processed
the <code class="constant">WINDOW_REGISTRY_ADD</code> message.
</p><p>
We then add a new field to the reply message by calling
<code class="methodname">AddInt32()</code>. The field is given the name
<code class="varname">new_window_number</code> and its value is set to the value of
<code class="varname">next_untitled_number</code>. We could add as many named fields
as we want to this message, but for now, this is all we need.
</p><p>
Then the reply is sent by calling the received
<code class="classname">BMessage</code>'s <code class="methodname">SendReply()</code>
function. This directs the reply message to the appropriate
<code class="classname">BHandler</code> object (in this case, the
<code class="classname">HelloWindow</code> that sent the
<code class="constant">WINDOW_REGISTRY_ADD</code> message).
</p><p>
Finally, the <code class="varname">next_untitled_number</code> variable is incremented, so that the
next new window's number will be one greater than the previous window's.
</p><p>
The window count is then incremented (whether a reply was sent or not),
since there's a new window registered. We always want to count up every
new window, even if it's not untitled.
</p><pre class="programlisting cpp">
    case <code class="constant">WINDOW_REGISTRY_SUB</code>:
      <code class="varname">window_count</code>--;
      if (!<code class="varname">window_count</code>) {
        <code class="methodname">Quit</code>();
      }
      break;
</pre><p>
If the message is a <code class="constant">WINDOW_REGISTRY_SUB</code> message, the window count is
decremented, thereby indicating that one less window is open. If the
count becomes zero, the application's <code class="methodname">Quit()</code> function is called. This
causes the application to terminate when there aren't any open windows
left.
</p><pre class="programlisting cpp">
    default:
      <code class="classname">BApplication</code>::<code class="methodname">MessageReceived</code>(<code class="parameter">message</code>);
      break;
  }
}
</pre><p>
All other messages are routed back to the inherited <code class="classname">BApplication</code>
<code class="methodname">MessageReceived()</code> function.
</p><p>
Now let's look at the changes needed to the <code class="classname">HelloWindow</code> class:
</p><pre class="programlisting cpp">
class <code class="classname">HelloWindow</code> : public <code class="classname">BWindow</code> {
  public:
    <code class="methodname">HelloWindow</code>(<code class="classname">BRect</code> <code class="parameter">frame</code>);
    <code class="methodname">~HelloWindow</code>();
    virtual <span class="type">bool</span>  <code class="methodname">QuitRequested</code>();
    virtual <span class="type">void</span>  <code class="methodname">MessageReceived</code>(<span class="type"><code class="classname">BMessage</code> *</span><code class="parameter">message</code>);

  private:
    <span class="type">void</span>  <code class="methodname">Register</code>(<span class="type">void</span>);
    <span class="type">void</span>  <code class="methodname">Unregister</code>(<span class="type">void</span>);

    <span class="type"><code class="classname">BMenuBar</code>   *</span><code class="varname">menubar</code>;
    <span class="type"><code class="classname">HelloView</code>  *</span><code class="varname">helloview</code>;
};
</pre><p>
The updated <code class="classname">HelloWindow</code> class needs a customized destructor, so that the
window can be automatically unregistered whenever it's closed. Two
private functions are added as well: <code class="methodname">Register()</code>, which registers the
window with the application, and <code class="methodname">Unregister()</code>, which unregisters the
window.
</p><p>
The destructor is really simple—it just calls the
<code class="methodname">Unregister()</code> function:
</p><pre class="programlisting cpp">
<code class="classname">HelloWindow</code>::<code class="methodname">~HelloWindow</code>() {
  <code class="methodname">Unregister</code>();
}
</pre><p>
The <code class="methodname">Register()</code> function sends a
<code class="constant">WINDOW_REGISTRY_ADD</code> message to the
<code class="classname">HelloApp</code> object. To accomplish this, we need to
create a <code class="classname">BMessenger</code> object to deliver messages to
the application. This is done by passing the application's signature to the
<code class="classname">BMessenger</code> constructor; this creates a
<code class="classname">BMessenger</code> that delivers messages to the
<code class="classname">HelloApp</code>.
</p><p>
The <code class="constant">WINDOW_REGISTRY_ADD</code> message is created on the
stack, and the <code class="varname">need_id</code> argument is added to it by
calling <code class="methodname">AddBool()</code>. The message is then sent to the
application by calling <code class="methodname">BMessenger::SendMessage()</code>.
</p><p>
<code class="methodname">SendMessage()</code> lets you specify the handler to
which replies should be directed. Since we want replies sent to the
<code class="classname">HelloWindow</code> object, we specify the object
(<code class="varname">this</code>) as the reply handler; by default, replies are
sent to the <code class="classname">BApplication</code> object, which isn't what we
want.
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="classname">HelloWindow</code>::<code class="methodname">Register</code>(<span class="type">bool</span> <code class="parameter">need_id</code>) {
  <code class="classname">BMessenger</code> <code class="varname">messenger</code>(<code class="constant">APP_SIGNATURE</code>);
  <code class="classname">BMessage</code>   <code class="varname">message</code>(<code class="constant">WINDOW_REGISTRY_ADD</code>);

  <code class="varname">message</code>.<code class="methodname">AddBool</code>("need_id", <code class="parameter">need_id</code>);
  <code class="varname">messenger</code>.<code class="methodname">SendMessage</code>(&amp;<code class="varname">message</code>, <code class="varname">this</code>);
}
</pre><p>
The <code class="methodname">Unregister()</code> function is nearly identical,
except that it sends a <code class="constant">WINDOW_REGISTRY_SUB</code> message,
and, since no replies are expected, it doesn't specify a reply handler.
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="classname">HelloWindow</code>::<code class="methodname">Unregister</code>(<span class="type">void</span>) {
  <code class="classname">BMessenger</code> <code class="varname">messenger</code>(<code class="constant">APP_SIGNATURE</code>);
  <code class="varname">messenger</code>.<code class="methodname">SendMessage</code>(new <code class="classname">BMessage</code>(<code class="constant">WINDOW_REGISTRY_SUB</code>));
}
</pre><p>
<code class="classname">HelloWindow</code>'s
<code class="methodname">MessageReceived()</code> function needs to be augmented a
bit. We're going to implement the <span class="guimenuitem">New</span>,
<span class="guimenuitem">Close</span>, and <span class="guimenuitem">Quit</span>
options in the <span class="guimenu">File</span> menu, and we need to handle the
<code class="constant">WINDOW_REGISTRY_ADDED</code> message (as you recall, this is
the reply sent by the <code class="classname">HelloApp</code> object when a window
is successfully registered).
</p><p>
Here are the constants for the message codes we're adding support for:
</p><pre class="programlisting cpp">
<span class="type">constuint32</span> <code class="constant">MENU_FILE_NEW</code>    = 'MFnw';
<span class="type">constuint32</span> <code class="constant">MENU_FILE_CLOSE</code>  = 'MFcl';
<span class="type">constuint32</span> <code class="constant">MENU_FILE_QUIT</code>   = 'MFqu';
</pre><p>
The code is as follows:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="classname">HelloWindow</code>::<code class="methodname">MessageReceived</code>(<span class="type"><code class="classname">BMessage</code> *</span><code class="parameter">message</code>) {
  switch(<code class="parameter">message</code>-&gt;<code class="varname">what</code>) {
    case <code class="constant">WINDOW_REGISTRY_ADDED</code>:
      {
        <span class="type">char</span> <code class="varname">s</code>[22];
        <span class="type">int32</span> <code class="varname">id</code> = 0;
        if (<code class="parameter">message</code>-&gt;<code class="methodname">FindInt32</code>("new_window_number",
                               &amp;<code class="varname">id</code>) == <code class="constant">B_OK</code>) {
          <code class="function">sprintf</code>(<code class="varname">s</code>, "Untitled %ld", <code class="varname">id</code>);
          <code class="methodname">SetTitle</code>(<code class="varname">s</code>);
        }
      }
      break;
</pre><p>
When a <code class="constant">WINDOW_REGISTRY_ADDED</code> message is received, we
extract the window's number from the message's
<code class="varname">new_window_number</code> field by calling
<code class="methodname">FindInt32()</code>. This value is passed to the ANSI C
<code class="function">s<code class="function">printf</code>()</code> function to create a string to be used as
the window's title, such as "Untitled 1" or "Untitled
42". That string is then passed to the window's
<code class="methodname">SetTitle()</code> function to change the window's title.
This ensures that every window has a unique name.
</p><pre class="programlisting cpp">
    case <code class="constant">MENU_FILE_NEW</code>:
      {
        <code class="classname">BRect</code> <code class="varname">r</code>;
        <code class="varname">r</code> = <code class="methodname">Frame</code>();
        <code class="varname">r</code>.<code class="methodname">OffsetBy</code>(20,20);
        new <code class="classname">HelloWindow</code>(<code class="varname">r</code>);
      }
      break;
</pre><p>
The <span class="guimenu">File</span> menu's <span class="guimenuitem">New</span>
option creates a new <code class="classname">HelloWindow</code>, whose frame
rectangle is the same as the current window's, but offset by 20 pixels
down and to the left. This staggering effect helps keep the windows
orderly on the screen (although in real life you want to be sure the
windows don't eventually creep off the bottom or right edge of the
screen!).
</p><pre class="programlisting cpp">
    case <code class="constant">MENU_FILE_CLOSE</code>:
      <code class="methodname">Quit</code>();
      break;
</pre><p>
The <span class="guimenuitem">Close</span> option simply calls the
<code class="classname">HelloWindow</code>::<code class="methodname">Quit()</code> function to close the window.
Because the <code class="classname">HelloWindow</code> destructor calls
<code class="methodname">Unregister()</code>, the
window will be unregistered from the application (thereby reducing the
window count).
</p><pre class="programlisting cpp">
    case <code class="constant">MENU_FILE_QUIT</code>:
      <code class="varname">be_app</code>-&gt;<code class="methodname">PostMessage</code>(<code class="constant">B_QUIT_REQUESTED</code>);
      break;
</pre><p>
The <span class="guimenuitem">Quit</span> option posts a
<code class="constant">B_QUIT_REQUESTED</code> message to the application
object. This causes the application to close all the windows and
terminate itself.
</p><pre class="programlisting cpp">
    case <code class="constant">MENU_OPT_HELLO</code>:
      <span class="comment">/* this is the same as last time */</span>
      break;

    default:
      <code class="classname">BWindow</code>::<code class="methodname">MessageReceived</code>(<code class="parameter">message</code>);
      break;
  }
}
</pre><p>
The rest of the code in <code class="classname">HelloWindow</code>::<code class="methodname">MessageReceived()</code>
is unchanged since last time.
</p><p>
Finally, because we don't want closing the window to automatically quit
the application, we rewrite the <code class="classname">HelloWindow</code>::<code class="methodname">QuitRequested()</code> function to
simply return <code class="constant">true</code>—it's always okay to close the window. We no longer
want to request that the application quit as well:
</p><pre class="programlisting cpp">
<span class="type">bool</span> <code class="classname">HelloWindow</code>::<code class="methodname">QuitRequested</code>() {
  return <code class="constant">true</code>;
}
</pre><p>
This has been a very brief overview of messaging on the BeOS. Because
messaging is so pervasive throughout the entire operating system, we'll
learn more about it as we go on. But this will give you the background
needed to follow along as we continue to explore. Try adding code to
insert more data into the registration messages, or make the
<code class="constant">WINDOW_REGISTRY_SUB</code> message send a reply.
</p><p>
Although this sample project's messages are mostly transmitted within the
application, there's no reason you can't write two applications and send
messages back and forth between them (try this—just remember to use
the appropriate signature when creating a <code class="classname">BMessenger</code>
object for sending messages to the other application).
</p><p>
You can download the source code for this week's project &gt;from the Be FTP
site: ftp://ftp.be.com/pub/samples/intro/messageworld.zip
</p><p>
In about six weeks, we'll try making the <code class="classname">HelloWindow</code>
class do something more useful than simply display a string in a window.
We'll look at the <code class="classname">BTextView</code> class and start down the
road toward turning our sample application into a text editor.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-19"></a>StarCode</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
Last week, we executed the closing documents to finalize Be's acquisition
of StarCode. It is a great pleasure to welcome Carlin Wiegner and his team
into Be. Their pioneering spirit and their achievements have been an
inspiration and, in more ways than one, that's precisely why the deal got
done.
</p><p>
It shouldn't come as news for those (few) who read the original Be business
plan that we believe in electronic distribution of software. A section of
that plan explains how we'd create a dedicated Be BBS, knitting together
the community of Be developers, Be customers, and the company itself. This
was written in 1991, when you could buy a few phone lines, an inexpensive
PC, and software from Mustang or Galacticom. With a Mac you needed a really
nice product aptly called FirstClass, and you were in business. You had
your own little Compuserve, your petit MoiOnLine.
</p><p>
There were over 10,000 BBS in the country. The reference magazine for the
BBS trade was Boardwatch—still one of the best reads, nicely converted
to the Internet under its erudite and opinionated editor-in-chief Jack
Rickard http://www.boardwatch.com/.
</p><p>
These BBS systems were, ahem, scalable. The largest one linked over 100 PCs
via a Novell network—very messy, but very inexpensive.
</p><p>
McAfee, then reigning king of anti-virus software, used such a contraption
for electronic delivery of its software; as a result, its IPO prospectus
listed as a major risk the fact only one individual knew how to run the
thing.
</p><p>
So, we were going to build such an electronic community, alert our
customers every week to new and improved application, utility, game, or
even system software available. Developers would advertise their wares on
our BBS. The weekly Newsletter would ask politely if we could deposit demo
software and updates on their disk.
</p><p>
The word "push" hadn't been invented yet. If customers liked the
sampleware, they could call the developer, order with a credit card, and
receive the software electronically or via snail mail. Not very
sophisticated but, at the time, it was judged a little futuristic and
risky. Customers might balk at the idea of having software loaded on their
machines without having full control over the process. Cookies hadn't been
invented either.
</p><p>
Jump to 1996. Carlin works at Be as a summer intern and starts a company
called StarCode, a site called BeDepot, and a product called Software
Valet. BeDepot sells and delivers software over the Web. The Web is a
still-evolving contraption, but a ubiquitous and inexpensive one. Software
Valet sits in your BeOS system, where it downloads, installs, and registers
software; it also notifies you of updates. StarCode practiced what we
preached.
</p><p>
Two more factors made StarCode attractive to Be: the people and the
e-commerce infrastructure. With this in mind, and wanting to make life easy
for customers and profitable for developers, the make vs. buy analysis was
fairly straightforward. Carlin, his team, and their technology provide us
with a better and faster way to build a BeOS software community and,
therefore, the Be platform.
</p><p>
Mere implementation details remain...which is a way to say we have much to
do to realize the potential this reunion represents, but at least we are
started on the right path.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-18.html">Issue 3-18, May 6, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-20.html">Issue 3-20, May 20, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-18.html" title="Issue 3-18, May 6, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue3-20.html" title="Issue 3-20, May 20, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
