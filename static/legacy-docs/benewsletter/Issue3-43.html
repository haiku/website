<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-42.html" title="Issue 3-42, October 21, 1998" /><link rel="next" href="Issue3-44.html" title="Issue 3-44, November 4, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-42.html" title="Issue 3-42, October 21, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-44.html" title="Issue 3-44, November 4, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-42.html">Issue 3-42, October 21, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-44.html">Issue 3-44, November 4, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-43"></a>Issue 3-43, October 27, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-43"></a>Be Engineering Insights: Mastering Your Own BeOS Demo CD</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Ming</span> <span class="surname">Low</span></span></div></div></div><p>
A few months ago, Be released the BeOS Demo CD as an inexpensive and
uncomplicated way for people to try the BeOS without having to
paritition/initialize their disk or purchase the full version.
</p><p>
The BeOS Demo CD is a bootable CD. It boots into a version of BeOS
Release 3.2 which is fully functional except for the ability to partition
or initialize a BFS partition, preventing the user from saving their
work. Although some features' performance is affected, everything works,
and you can even save preferences onto a floppy, preserving settings
across rebooting.
</p><p>
The BeOS Demo CD has since been used by people to try systems at computer
stores to see if they are BeOS compatible, for Be enthusiasts to give
friends a quick demo of the BeOS on their system, and even to show off
what the BeOS can do at their local computer stores. Internally we have a
variation of the Demo CD that turns our Window 98 systems into a gaming
station: booting from the CD directly into a game such as Quake, Doom, or
ATetris, just by turning on the machine with the CD in the drive.
</p><p>
The usefulness of the BeOS Demo CD has stirred interest from third-party
developers who want to see demo versions of their products on the Demo
CD. We're working on making that happen—the next Demo CD (with R4)
will include third-party demonstration apps. Other developers have
wondered about the possibility of making their own demo CDs, which boot
the BeOS but only include demonstrations of their own products. Marketing
says, "Interesting idea!"
</p><p>
The purpose of this article is to explain how we made the BeOS Demo CD,
because it was an interesting technical challenge. Before you use this as
a recipe for your own demo CDs, though, if you are planning to distribute
a CD that includes the BeOS, you need to obtain a license to distribute
it. Contact our guy in charge of licensing, Bart Adao, at &lt;bart@be.com&gt;
for details.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id750462"></a>Making the CD Bootable into BeOS</h3></div></div></div><p>
To make the CD bootable, you need to create an ISO track on it by
following the PC
<a class="ulink" href="http://en.wikipedia.org/wiki/El_Torito_(CD-ROM_standard)">El Torito Specification</a>
for creating a bootable CD. This
ISO track or partition must contain a special <code class="filename">zbeos</code> boot image and a boot
catalog file plus some boot information for the CD's Boot Volume
Descriptor. The special <code class="filename">zbeos</code> image essentially mimics a BeOS Intel boot
floppy.
</p><p>
The BeOS needs to boot off the CD from a 2.88 MB boot image. Some
commercial software will create a bootable CD but only from a 1.44 MB
floppy. One commercial CD-burning package that supports creating a 2.88
MB boot image is <a class="ulink" href="http://www.ahead.com/">Ahead Software's Nero</a>.
</p><p>
If your toasting software can't create a bootable CD from a 2.88 MB
image, you can still do it manually using your existing software. Good
step-by-step documentation that walks you through creating the bootable
ISO track manually is available on the web, at
http://www.nikko.simplenet.com/goldentime/bootcd1b.htm.
</p><p>
I tested the manual process for creating a bootable BeOS CD and it works,
mostly. You need to change the setting from 02 (1.44 MB bootable floppy
disk image) to 03 (2.88 MB bootable floppy disk image) on the section
that describes the bootable media type. If you want additional
information on the El Torito Bootable CD Specification, a copy is
available for download from Phoenix Technology LTD at
</p><p>
<a class="ulink" href="http://www.phoenix.com/NR/rdonlyres/98D3219C-9CC9-4DF5-B496-A286D893E36A/0/specscdrom.pdf">http://www.phoenix.com/NR/rdonlyres/98D3219C-9CC9-4DF5-B496-A286D893E36A/0/specscdrom.pdf</a>.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id750537"></a>Creating the 2.88 MB BeOS Boot Image</h3></div></div></div><p>
Here's how to create the 2.88 MB BeOS boot image. You start by creating a
2.88 MB file that contains all zeros. You can do this with the dd command:
</p><pre class="screen">
$ dd if=/dev/zero of=zerofile bs=1024 count=2880
</pre><p>
Then merge the <code class="filename">/boot/beos/system/zbeos</code> file with
the <code class="filename">zerofile</code> using the
<code class="command">cat</code> command:
</p><pre class="screen">
$ cat /boot/beos/system/zbeos zerofile &gt; zbeos.tmp
</pre><p>
Finally, chop off any excess bytes over 2.88 MB. You use the <code class="command">dd</code> command
again to do this:
</p><pre class="screen">
$ dd if=zbeos.tmp of=zbeos.boot count=2880 bs=1024
</pre><p>
The <code class="filename">zbeos.boot</code> file is the BeOS boot image that makes your CD bootable.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id750597"></a>Creating the BFS Partition</h3></div></div></div><p>
To create the BeOS track for the bootable CD, first make a partition on
your hard disk that's big enough to contain the
<code class="filename">/boot/beos</code> files and
the other files you want on your demo CD. The partition should be smaller
than 650 MB, minus the size of your ISO track and the gap between the
tracks. A safe partition size would be 600 MB or smaller.
</p><p>
After you select your partition size, initialize the partition with a
block size of 2048 bytes or greater (remember, the BeOS defaults to
creating partitions with a block size of 1024 bytes). You need to do this
because the BeOS won't recognize volumes with a block size smaller than
the device's minimum block size, which on a CD-ROM is 2048 bytes. If you
forget to do this you end up with a nice coaster or something to use for
a microwave light show (yes, we do that here at Be).
</p><p>
If you want to have your demo CD boot into the <span class="application">Tracker</span> on startup (like
the BeOS Demo CD), you need to copy the following files from your
<code class="filename">/boot/home/config/settings/</code> directory over to your BeOS CD partition:
</p><pre class="screen">
Desktop_settings
Key_map
Keymap
Keymap_Data
MIMEPrefs_settings
Tracker
beos_mime
fonts_list
fonts_status
</pre><p>
You may also want to copy over the <code class="filename">Screen_data</code>
and <code class="filename">Screen_settings</code> to
retain your current screen resolution, refresh rate, and color bit-depth.
If you want the CD to use your current network settings (say, configured
to use <acronym class="acronym" title="Dynamic Host Configuration Protocol">DHCP</acronym>)
then you need to copy the Network settings file. After you
copy all the settings files you're ready to tailor the system boot
process.
</p><p>
Below is a sample <code class="filename">Bootscript</code> you can use for your CD partition. This
script doesn't do everything the standard <code class="filename">Bootscript</code> does; i.e., it does
not load the variables in the <code class="filename">beos/system/boot/SetupEnvironment</code>. You
should tailor this <code class="filename">Bootscript</code> to load the system you want and replace the
one that's in your CD partition.
</p><pre class="programlisting sh">
# -------------------------------------------------------
# This is a special CD Bootscript for demo CDs.
# It manages starting up all the necessary servers
# and ensuring a sane system state.
#

# ++++++++++
#  function: launch exectuable_path [ thread_to_wait_for ]
# ++++++++++

launch () {
  if [ -f "/fd/$1" ]
  then
    echo Launching "/fd/$1"
    "/fd/$1" &amp;
    [ "$2" != "" ] &amp;&amp; waitfor "$2"
    return 1
  else
    if [ -f "/boot/$1" ]
    then
      echo Launching "/boot/$1"
      "/boot/$1" &amp;
      [ "$2" != "" ] &amp;&amp; waitfor "$2"
      return 1
    else
      echo There is no "$1"
    fi
  fi
  return 0
}

# ++++++++++
#  function: launchscript script_path
# ++++++++++

launchscript() {
  if [ -f "/fd/$1" ]
  then
    echo Executing "/fd/$1"
    . "/fd/$1"
  else
    if [ -f "/boot/$1" ]
    then
      echo Executing "/boot/$1"
      . "/boot/$1"
    fi
  fi
}

#
# First we set up a bunch environment variables that
# we'll need later.
#

export PATH=:/bin:/boot/beos/apps:/boot/beos/preferences
export HOME=/boot/home
export SHELL=/bin/sh
export USER=demo
export GROUP=group
SCRIPTS=beos/system/boot
SERVERS=beos/system/servers

#
# Start the Boot of servers
#

launch $SERVERS/app_server picasso  # launch app_server
launch $SERVERS/registrar _roster_thread_  # launch registrar
launch $SERVERS/debug_server        # we hate crashing
launch beos/system/Tracker          # start the Tracker

launch beos/system/Deskbar          # launch DeskBar
launch $SERVERS/audio_server        # we like it noisy
launch $SERVERS/print_server        # we own paper stocks

sleep 2     # let things settle down a bit and then
            # continue

launchscript $SCRIPTS/Netscript     # start up networking
# -------------------------------------------------------
</pre><p>
To create a BeOS CD that boots straight into an application such as <span class="application">Quake</span>
for the BeOS, you can simplify the above <code class="filename">Bootscript</code> by removing the
following lines:
</p><pre class="programlisting sh">
launch $SERVERS/debug_server # we hate crashing
launch beos/system/Tracker   # start the Tracker
launch beos/system/Deskbar   # launch DeskBar
launch $SERVERS/print_server # we own paper stocks

## Remove these two lines if you don't need networking

sleep 2    # let things settle down a bit and then continue
launchscript $SCRIPTS/Netscript # start up networking
</pre><p>
If you have a Matrox Video card, you may want to increase the performance
by installing the fast_video driver from the BeOS R3.1 CD,
<code class="filename">/optional/experimental/drivers/kernel/fast_video</code>. Once you've installed
the drivers you can add the following lines to the Bootscript to make
this into a bootable BeOS Game CD:
</p><pre class="programlisting sh">
##  This assuming the fastvid was installed
##  into /boot/home/config/bin.

/boot/home/config/bin/fastvid set # Speed up for
                                  # Matrox video card

/boot/quake/Quake                 # Launch Quake

shutdown -r -d 4 &amp;            # Reboot the machine when
                                  # the user quits the game
</pre></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id750753"></a>Creating a Floppy for Saving Settings</h3></div></div></div><p>
The BeOS Demo CD lets you save preference settings files to a floppy. You
do this is by renaming the actual config directory on the CD from
<code class="filename">/boot/home/config</code> to
<code class="filename">/boot/home/config2</code>. It then creates a symlink for
<code class="filename">/boot/home/config</code> to point to
<code class="filename">/config</code>. Using this round about way, you
can change the symlink at
<code class="filename">/config</code> to point to either the config directory
on the floppy or the
<code class="filename">/config2</code> on the CD, depending on whether the floppy
exists.
</p><pre class="programlisting sh">
## Add the following lines before the app_server is launched
## to determine if it should use the cd or the fd config
## directory
##
mkdir /fd                      # create the fd mount point
mount /dev/disk/floppy/raw /fd # try and mount floppy


if [ $? -eq 0 ]                # check to see if the floppy
                               # was mounted successfully
then
  ln -s /fd/home/config /config  # point the link from the
                                 # floppy to the cd
  launchscript Bootscript.fd     # if you need it,
                                 # launch Bootsript.fd
else
  ln -s /boot/home/config2 /config # create the cd link
fi
</pre><p>
By using this technique, you can save high scores from your Bootable Game
CD or give all your kids a personal settings floppy so they won't change
yours....
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-43-2"></a>Be Engineering Insights: SCSI From UserLand</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Brian</span> <span class="surname">Swetland</span></span></div></div></div><p>
BeOS R4 adds a new driver (<code class="filename">scsi_raw</code>) which allows programs to send
arbitrary commands over the
<acronym class="acronym" title="Small Computer Systems Interface">SCSI</acronym> bus from userspace, without having to
write a device driver for every little thing. What's this good for, you
might ask? Not every <acronym class="acronym">SCSI</acronym> device has a simple interface easily wrapped
with a device using the
<acronym class="acronym" title="Portable Operating System Interface">POSIX</acronym>-style
open/close/read/write model of IO.
This works great for disks, CD-ROMs, and other "simple" devices, but
sometimes it's nice to be able to send the <acronym class="acronym">SCSI</acronym> commands you need without
having a special driver for that device—maybe for a utility program or
a CD-R authoring tool. Or maybe just to muck about with the raw bus to
find out what makes it go.
</p><p>
That's where the <code class="filename">scsi_raw</code> device fits in. <code class="filename">scsi_raw</code> publishes device
entries that look like <code class="filename">/dev/bus/scsi/1/4/0/raw</code>—where the first number
is the controller (in this case 1, the second controller), the second
number is the target or <acronym class="acronym">SCSI</acronym> ID (device 4 in this case), and the third
number is the logical unit number (0 in this case). Many systems only
have one <acronym class="acronym">SCSI</acronym> bus (so the first number is often zero) and most <acronym class="acronym">SCSI</acronym>
devices have no logical units, CD changers and such being the exception
(so the last number is often zero as well).
</p><p>
This naming scheme is used for all <acronym class="acronym">SCSI</acronym> devices in R4—what was
<code class="filename">/dev/disk/scsi/000/raw</code> is now
<code class="filename">/dev/disk/scsi/0/0/0/raw</code>, and so on. We
suggest that tape devices be named in a similar fashion as well. The
major reason for this renaming is to allow wide <acronym class="acronym">SCSI</acronym> to work without
confusion—wide device IDs can be greater than 9, which would cause
problems in the old scheme. <code class="filename">/dev/disk/scsi/1120/raw</code> is more likely cause
confusion than <code class="filename">/dev/disk/scsi/1/12/0/raw</code> where you can clearly see the
division between path, target, and lun.
</p><p>
Raw <acronym class="acronym">SCSI</acronym> devices can be opened or closed,
but not read from or written to. The only operation that can be done
on a raw <acronym class="acronym">SCSI</acronym> device is an <code class="function">ioctl</code>
call of the form
</p><pre class="programlisting c">
<code class="function">ioctl</code>(<code class="varname">fd</code>, <code class="constant">B_RAW_DEVICE_COMMAND</code>, &amp;<code class="varname">rawdevcmd</code>,
      <code class="function">sizeof</code>(<span class="type">raw_device_command</span>))
</pre><p>
This <code class="function">ioctl</code> is also supported by
<acronym class="acronym" title="AT Attachment Packet Interface">ATAPI</acronym>
drives on the <acronym class="acronym" title="Integrated Drive Electronics">IDE</acronym> chain (since
<acronym class="acronym">ATAPI</acronym> devices speak <acronym class="acronym">SCSI</acronym> commands over
the <acronym class="acronym">IDE</acronym> bus). The raw device
command data structure appears here and is explained below:
</p><pre class="programlisting c">
<span class="comment">/* raw device commands - from be/devices/scsi.h */</span>

typedef struct {
  <span class="type">uint8</span>   <code class="varname">command</code>[16];
  <span class="type">uint8</span>   <code class="varname">command_length</code>;
  <span class="type">uint8</span>   <code class="varname">flags</code>;
  <span class="type">uint8</span>   <code class="varname">scsi_status</code>;
          <span class="comment">/* SCSI Status Byte */</span>
          <span class="comment">/* (0 = success, 2 = check cond, ... */</span>
  <span class="type">uint8</span>   <code class="varname">cam_status</code>;
          <span class="comment">/* CAM_* status conditions from CAM.h */</span>
  <span class="type">void   *</span><code class="varname">data</code>;
  <span class="type">size_t</span>  <code class="varname">data_length</code>;
  <span class="type">void   *</span><code class="varname">sense_data</code>;
          <span class="comment">/* buffer to return mode sense data in */</span>
  <span class="type">size_t</span>  <code class="varname">sense_data_length</code>;
          <span class="comment">/* size of optional buffer for mode sense */</span>
  <span class="type">bigtime_t</span>  <code class="varname">timeout</code>;
} <span class="type">raw_device_command</span>;

enum {
  <code class="constant">B_RAW_DEVICE_DATA_IN</code>          = 0x01,
  <code class="constant">B_RAW_DEVICE_REPORT_RESIDUAL</code>  = 0x02,
  <code class="constant">B_RAW_DEVICE_SHORT_READ_VALID</code> = 0x04
};
</pre><ul class="itemizedlist"><li><p>
<code class="varname">command</code>—this field contains the <acronym class="acronym">SCSI</acronym>
command (aka CDB) that will be issued.
</p></li><li><p>
<code class="varname">command_length</code>—the length of the <acronym class="acronym">SCSI</acronym>
command in bytes (6, 10, and 12 are valid).
</p></li><li><p>
<code class="varname">flags</code>—one of the three flags described below, logically or'd
together:
</p><ul class="itemizedlist"><li><p>
<code class="constant">B_RAW_DEVICE_DATA_IN</code>—after the command is issued, data is read from
the bus to the buffer provided. If this flag is not set, data is written
to the bus instead.
</p></li><li><p>
<code class="constant">B_RAW_DEVICE_REPORT_RESIDUAL</code>—this flag requests that the residual
(amount of data NOT transferred) be reported in the same fields that were
used to issue the request (e.g., <code class="varname">data_length</code> will contain the residual
data_length upon return).
</p></li><li><p>
<code class="constant">B_RAW_DEVICE_SHORT_READ_VALID</code>—this flag indicates that a short read
(the entire provided buffer is not filled) will not be considered an
error condition.
</p></li></ul></li><li><p>
<code class="varname">scsi_status</code>—the SCSI bus status is reported here upon return. 0 =
success, 2 = check condition, etc. Consult your favorite SCSI reference
for more detail
</p></li><li><p>
<code class="varname">cam_status</code>—this status field reports the success or failure of the
transaction. <code class="constant">CAM_REQ_CMP</code> indicates successful completion (scsi_status = 0
is implied), <code class="constant">CAM_REQ_CMP_ERR</code> indicates an error occurred, etc. CAM.h
provides definitions of these and several other result codes, though the
two listed here are most common. If an error occurred and sense data was
read into the sense buffer, <code class="constant">CAM_AUTOSNS_VALID</code> (0x80) will be or'd with
the cam_status byte.
</p></li><li><p>
<code class="varname">data</code>—a pointer to a block of data to send or a data buffer to
receive into. If the <code class="constant">B_RAW_DEVICE_DATA_IN</code> flag is set, this buffer is
used to read from the bus. Otherwise, this buffer is sent over the bus
after the command. If <code class="varname">data_length</code> is 0, no data transaction occurs.
</p></li><li><p>
<code class="varname">data_length</code>—the amount of data to send or size of the receive
buffer. If the <code class="constant">B_RAW_DEVICE_REPORT_RESIDUAL</code> flag is set, this field will
contain the number of bytes NOT read or written upon return.
</p></li><li><p>
<code class="varname">sense_data</code>—a buffer to receive sense
data (<acronym class="acronym">SCSI</acronym> error information) if an error occurs.
</p></li><li><p>
<code class="varname">sense_data_length</code>—the size of the sense buffer. If the
<code class="constant">B_RAW_DEVICE_REPORT_RESIDUAL</code> flag is set, this field will contain the
number of bytes NOT read upon return (but only if the sense buffer was
read into due to a check condition).
</p></li><li><p>
<code class="varname">timeout</code>—this field specifies a timeout in microseconds. It only has
meaning when used with an <acronym class="acronym">ATAPI</acronym> device on an <acronym class="acronym">IDE</acronym> bus.
</p></li></ul><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id751634"></a>A Word Of Caution</h3></div></div></div><p>
Be aware that the <code class="filename">/dev/bus/scsi/...</code> device entries allow you to send
arbitrary commands to any <acronym class="acronym">SCSI</acronym> device in your system. This is very
powerful and also can be quite dangerous if you're not careful. Mucking
around with things like disks that have mounted file systems on them can
be unwise if you don't know exactly what you're doing.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id751658"></a>Example: SCSIProbe for the command line</h3></div></div></div><p>
The following simple program walks the <acronym class="acronym">/dev/bus/scsi/...</acronym> hierarchy and
issues an inquiry command to every listed device, spitting the
information out in a simple table. It's a C++ app because it uses some
Storage Kit classes to do the directory walking, but everything else is
vanilla C code.
</p><pre class="programlisting cpp">
<span class="comment">/* inquiry.cpp - SCSIProbe for the command line, more or less
**
** PPC:    cc -o inquiry inquiry.cpp
** Intel: gcc -o inquiry inquiry.cpp -lbe
*/</span>

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;Directory.h&gt;
#include &lt;Entry.h&gt;
#include &lt;Path.h&gt;
#include &lt;scsi.h&gt;
#include &lt;CAM.h&gt;

<span class="comment">/* table with textual descriptions of the inquiry data's
** device type
*/</span>
char *<code class="varname">devtype</code>[] = {
  "Disk   ", "Tape   ", "Printer", "CPU    ", "WORM   ",
  "CD-ROM ", "Scanner", "Optical", "Changer", "Comm   ",
  "Unknown"
};

<span class="comment">/* open a raw device, issue an inquiry command, print the
** results (and a header if it's the first time).
*/</span>
<span class="type">void</span> <code class="function">inquiry</code>(<span class="type">const char *</span><code class="parameter">dev</code>)
{
  static <span class="type">int</span> <code class="varname">header</code> = 1;
  <span class="type">int</span> <code class="varname">fd</code>,<code class="varname">e</code>;
  <span class="type">int</span> <code class="varname">path</code>,<code class="varname">targ</code>,<code class="varname">lun</code>,<code class="varname">type</code>;
  <span class="type">raw_device_command</span> <code class="varname">rdc</code>;
  <span class="type">uchar</span> <code class="varname">data</code>[36], <code class="varname">sense</code>[16];


  if(!<code class="function">strncmp</code>("/dev/bus/scsi/",<code class="varname">dev</code>,14)){
    <code class="function">sscanf</code>(<code class="parameter">dev</code>,"/dev/bus/scsi/%d/%d/%d/raw",
           &amp;<code class="varname">path</code>,&amp;<code class="varname">targ</code>,&amp;<code class="varname">lun</code>);
  } else {
    <code class="varname">path</code> = <code class="varname">targ</code> = <code class="varname">lun</code> = 0;
  }

  <span class="comment">/* fill out our raw device command data */</span>
  <code class="varname">rdc</code>.<code class="varname">data</code> = <code class="varname">data</code>;
  <code class="varname">rdc</code>.<code class="varname">data_length</code> = 36;
  <code class="varname">rdc</code>.<code class="varname">sense_data</code> = <code class="varname">sense</code>;
  <code class="varname">rdc</code>.<code class="varname">sense_data_length</code> = 0;
  <code class="varname">rdc</code>.<code class="varname">timeout</code> = 1000000;
  <code class="varname">rdc</code>.<code class="varname">flags</code> = <code class="constant">B_RAW_DEVICE_DATA_IN</code>;
  <code class="varname">rdc</code>.<code class="varname">command_length</code> = 6;
  <code class="varname">rdc</code>.<code class="varname">command</code>[0] = 0x12;
  <code class="varname">rdc</code>.<code class="varname">command</code>[1] = 0x00;
  <code class="varname">rdc</code>.<code class="varname">command</code>[2] = 0x00;
  <code class="varname">rdc</code>.<code class="varname">command</code>[3] = 0x00;
  <code class="varname">rdc</code>.<code class="varname">command</code>[4] = 36;
  <code class="varname">rdc</code>.<code class="varname">command</code>[5] = 0x00;

  if((<code class="varname">fd</code> = <code class="function">open</code>(<code class="parameter">dev</code>,0)) &lt; 0) return;
  <code class="varname">e</code> = <code class="function">ioctl</code>(<code class="varname">fd</code>, <code class="constant">B_RAW_DEVICE_COMMAND</code>, &amp;<code class="varname">rdc</code>, sizeof(<code class="varname">rdc</code>));
  <code class="function">close</code>(<code class="varname">fd</code>);
  if((<code class="varname">e</code> != 0) || (<code class="varname">rdc</code>.<code class="varname">cam_status</code> != <code class="constant">CAM_REQ_CMP</code>)) return;

  if(<code class="varname">header</code>){
    <code class="function">printf</code>("Bus ID  LUN  Type    Vendor   Device           Rev \n"
           "--- --- ---  ------- -------- ---------------- ----\n");
    <code class="varname">header</code> = 0;
  }

  <code class="varname">type</code> = <code class="varname">data</code>[0] &amp; 0x1F;
  if(<code class="varname">type</code> &gt; 9) <code class="varname">type</code> = 10;
  <code class="function">printf</code>("%3d %3d %3d  %7s %8.8s %16.16s %4.4s\n",
    <code class="varname">path</code>, <code class="varname">targ</code>, <code class="varname">lun</code>, <code class="varname">devtype</code>[<code class="varname">type</code>], <code class="varname">data</code> + 8, <code class="varname">data</code> + 16,
    <code class="varname">data</code> + 32);
}

<span class="comment">/* recursively wander down from a path, looking for "raw"
** devices to call inquiry on.
*/</span>
<span class="type">void</span> <code class="function">walkpath</code>(<span class="type">const char *</span><code class="parameter">path</code>)
{
  <code class="classname">BDirectory</code> <code class="varname">dir</code>(<code class="parameter">path</code>);
  if(<code class="varname">dir</code>.<code class="methodname">InitCheck</code>() == <code class="constant">B_OK</code>){
    <code class="classname">BEntry</code> <code class="varname">entry</code>;
    while(<code class="varname">dir</code>.<code class="methodname">GetNextEntry</code>(&amp;<code class="varname">entry</code>) &gt;= 0) {
      <code class="classname">BPath</code> <code class="varname">name</code>;
      <code class="varname">entry</code>.<code class="methodname">GetPath</code>(&amp;<code class="varname">name</code>);
      if(<code class="varname">entry</code>.<code class="methodname">IsDirectory</code>()) {
        <code class="function">walkpath</code>(<code class="varname">name</code>.<code class="methodname">Path</code>());
      } else if(!strcmp(<code class="varname">name</code>.<code class="methodname">Leaf</code>(),"raw")){
        <code class="function">inquiry</code>(<code class="varname">name</code>.<code class="methodname">Path</code>());
      }
    }
  }
}

<span class="comment">/* handle a command line arg or just walk the directory
** tree looking for devices
*/</span>
<span class="type">int</span> <code class="function">main</code>(<span class="type">int</span> <code class="parameter">argc</code>, <span class="type">char *</span><code class="parameter">argv</code>[])
{
  if(<code class="parameter">argc</code> != 2) {
    <code class="function">walkpath</code>("/dev/bus/scsi");
  } else {
    <code class="function">inquiry</code>(<code class="parameter">argv</code>[1]);
  }
  return 0;
}
</pre></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-43"></a>Developers Workshop: Getting a Grip on BJoystick</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Eric</span> <span class="surname">Shepherd</span></span></div></div></div><p>
The <code class="classname">BJoystick</code> class is getting a major overhaul for BeOS Release 4. In
earlier versions of BeOS, <code class="classname">BJoystick</code> was limited to supporting a simple
two-axis, two-button analog stick. But in this age of games with
complicated moves, high-realism flight simulations, and the like, this
just isn't enough. The new, improved <code class="classname">BJoystick</code> class gives you access to
modern digital game controllers (such as the Logitech Wingman Extreme
Digital, the Microsoft Sidewinder, and others). As always, the warning
goes (come on, you can say it along with me): "BeOS R4 isn't final, and
this is all subject to change."
</p><p>
These sticks often have a half-dozen buttons or more, thumb hats (those
little direction knobs on top of the main stick), and additional axes,
such as rotational controls or throttles. Game players want to use these
controls to their maximum potential, and the new <code class="classname">BJoystick</code> class lets you
do just that.
</p><p>
The old <code class="classname">BJoystick</code> mechanism still works, but I'm not going to talk about
it, because the old API doesn't support these advanced features. Note,
however, that enhanced joysticks don't work on the BeBox's built-in game
port hardware—all you can get are two-axis, two-button joysticks.
</p><p>
This article is based on the sample project StickIt. StickIt lets you
pick a joystick (previously configured using the new Joysticks preference
application), then presents a window showing all the buttons, hats, and
axes provided by that joystick, providing instant feedback as the
joystick is manipulated. Only key portions of the code will be shown
here; you can download the complete source code at
</p><p>
ftp://ftp.be.com/pub/samples/device_kit/stickit.tgz.
</p><p>
On R4 Intel, you can use the following command in a <span class="application">Terminal</span> window to
compile and link the program:
</p><pre class="screen">
cc -o StickIt main.cpp japplication.cpp jwindow.cpp -lbe -ldevice
</pre><p>
On R4 PowerPC, this command compiles and links the program:
</p><pre class="screen">
cc -o StickIt main.cpp japplication.cpp jwindow.cpp
</pre><p>
Note that I use the term "joystick," but I mean "any BeOS-compatible game
controller." There are supported game pads as well.
</p><p>
Let's begin by looking at how to figure out what joysticks are available,
and how to open them. Take a look at the <code class="methodname">PickJoystick()</code> function in
StickIt's <code class="filename">main.cpp</code> file. This function presents,
in the <span class="application">Terminal</span> from
which StickIt was launched, a list of joysticks, and lets the user pick
the one they want to play with.
</p><p>
It begins by calling <code class="code"><code class="classname">BJoystick</code>-&gt;<code class="methodname">CountDevices()</code></code>,
which returns the number
of devices connected (this isn't technically the same thing as the number
of joysticks connected, since "devices" really refers to game ports, and
it's possible for multiple devices to be chained to one game port,
although none of the drivers provided in R4 support this). If there
aren't any devices available, an error message is printed, and
<code class="methodname">PickJoystick()</code> returns <code class="constant">false</code>.
</p><p>
Otherwise, a loop prints out the names of the joysticks the user has
configured for each game port:
</p><pre class="programlisting cpp">
for (<code class="varname">i</code>=0; <code class="varname">i</code>&lt;<code class="varname">numDevices</code>; <code class="varname">i</code>++) {
  if (<code class="varname">stick</code>-&gt;<code class="methodname">GetDeviceName</code>(<code class="varname">i</code>, <code class="varname">devName</code>) != <code class="constant">B_OK</code>) {
    <code class="function">printf</code>("*** Error while reading controller list.\n");
    return <code class="constant">false</code>;
  }
  if (<code class="varname">stick</code>-&gt;<code class="methodname">Open</code>(<code class="varname">devName</code>, <code class="constant">true</code>) &lt; <code class="constant">B_OK</code>) {
    <code class="function">printf</code>("%4d. No controller on %s.\n", <code class="varname">i</code>+1, <code class="varname">devPath</code>);
  }
  else {
    if (<code class="varname">stick</code>-&gt;<code class="methodname">GetControllerName</code>(&amp;<code class="varname">name</code>) != <code class="constant">B_OK</code>) {
      <code class="function">printf</code>("*** Can't get name of controller %s.\n",
        <code class="varname">devPath</code>);
      return <code class="constant">false</code>;
    }
    <code class="function">printf</code>("%4d. %s\n", <code class="varname">i</code>+1, <code class="varname">name</code>.<code class="methodname">String</code>());
    <code class="varname">stick</code>-&gt;<code class="methodname">Close</code>();
  }
}
</pre><p>
This begins by obtaining the device name of the joystick that's
configured for the port (calling
<code class="methodname">GetDeviceName()</code>
with an index number indicating which port to check). <code class="methodname">BJoystick::Open()</code>
is then called to open the joystick device. If this fails, an error
message is displayed and the loop continues (in case there are empty or
unconfigured game ports, but others may be valid).
</p><p>
Once the device is open, <code class="methodname">GetControllerName()</code> is called to get the name of
the joystick. The returned name is the same as the name indicated by the
Joysticks preference application. This name is then displayed as the
option for the user to select, and the joystick is closed. This loop
continues until the entire menu is displayed on the terminal.
</p><p>
<code class="methodname">PickJoystick()</code> then lets the user select the
joystick they want to use, and then the device is opened, using code very
similar to the code above: first the device name is obtained by calling
<code class="methodname">GetDeviceName()</code>, then the Open() function is used
to actually open the device. <code class="methodname">Open()</code> returns the
file descriptor of the joystick's device driver (which you don't really
need to know), or a negative number if an error occurred while opening the
device).
</p><p>
<code class="methodname">PickJoystick()</code> returns with the
<code class="classname">BJoystick</code> object open and ready to use.
</p><p>
StickIt's <code class="function">main()</code> function is fairly simple. It calls
<code class="methodname">PickJoystick()</code> to
get a joystick to use, then instantiates a
<code class="classname">JWindow</code>
, in which the instant joystick feedback is presented.
</p><p>
<code class="classname">JWindow</code> is a very simple class and we won't dwell on it—it just sets
up the <code class="classname">JView</code>, which does all the real work, and sets the pulse rate to
100,000 microseconds.
</p><p>
Let's just skim on to the <code class="classname">JView</code> class, where all the cool stuff is done.
The constructor creates labels for the various displays in the view, and
resizes the view and the window, vertically, so it's the right size for
the controls provided by the joystick it's displaying).
</p><p>
At the top of the window, in a nice large font, the joystick's name is
displayed:
</p><pre class="programlisting cpp">
<code class="varname">stick</code>-&gt;<code class="methodname">GetControllerName</code>(&amp;<code class="varname">name</code>);
<code class="varname">stickName</code> = new <code class="classname">BStringView</code>(<code class="classname">BRect</code>(5,5,350,25),
                  "stickname", <code class="varname">name</code>.<code class="methodname">String</code>());
<code class="varname">stickName</code>-&gt;<code class="methodname">SetFontSize</code>(18);
<code class="methodname">AddChild</code>(<code class="varname">stickName</code>);
</pre><p>
We've seen how <code class="methodname">GetControllerName()</code> works already,
in <code class="methodname">PickJoystick()</code>, so
we skip on to the labels for the buttons:
</p><pre class="programlisting cpp">
<code class="varname">numButtons</code> = <code class="varname">stick</code>-&gt;<code class="methodname">CountButtons</code>();
<code class="varname">r</code>.<code class="methodname">Set</code>(5,50,100, 64);
for (<code class="varname">i</code>=0; <code class="varname">i</code>&lt;<code class="varname">numButtons</code>; <code class="varname">i</code>++) {
  <code class="varname">stick</code>-&gt;<code class="methodname">GetButtonNameAt</code>(<code class="varname">i</code>, &amp;<code class="varname">name</code>);
  <code class="varname">name</code>.<code class="methodname">Append</code>(":");
  <code class="varname">sview</code> = new <code class="classname">BStringView</code>(<code class="varname">r</code>, "buttonlabel", <code class="varname">name</code>.<code class="methodname">String</code>());
  <code class="varname">sview</code>-&gt;<code class="methodname">SetAlignment</code>(<code class="constant">B_ALIGN_RIGHT</code>);
  <code class="varname">sview</code>-&gt;<code class="methodname">SetFont</code>(<code class="varname">be_bold_font</code>);
  <code class="methodname">AddChild</code>(<code class="varname">sview</code>);
  <code class="varname">r</code>.<code class="varname">top</code> += 18;
  <code class="varname">r</code>.<code class="varname">bottom</code> += 18;
}
</pre><p>
<code class="methodname">CountButtons()</code> returns the number of buttons the joystick provides. The
buttons are numbered from 0 to <code class="varname">numButtons</code>-1.
The <code class="classname">BRect</code>, <code class="varname">r</code>, is initialized
to the rectangle of the first button's label, and then we enter the for
loop.
</p><p>
In the loop, each button's name is retrieved by calling
<code class="methodname">GetButtonNameAt()</code>, which returns the name (as specified by the joystick's
driver) for the specified button number. The name is returned in a
<code class="classname">BString</code> object. We append a colon to the name (which makes it look like a
label, instead of just random text displayed in a window), then we create
a <code class="classname">BStringView</code> using the name as the label. Alignment and font settings
are tweaked as appropriate, and the rectangle is adjusted so that the
next button will be created 18 pixels further down in the window.
</p><p>
A similar procedure is done to create the labels for the hats, which are
displayed in the same column as the buttons. <code class="methodname">CountHats()</code> is called to get
the number of hats, and the labels are generated in the same way (except
that the hat displays are larger, so each hat is displayed 40 pixels
below the previous one, instead of just 18 pixels).
</p><p>
The right-hand column is dedicated to displays for the axes. The topmost
display is a two-dimensional display for the X and Y axes, and a "Stick:"
label is displayed there, under the assumption that all joysticks have an
X/Y axis pair.
</p><p>
Below this are created labels for any other axes, such as throttles,
twist controls, and the like. This is done just like the button labels
(except that
<code class="methodname">CountAxes()</code>
is called to get the number of axes available). Note that axes 0 and 1
are the X and Y axes (this is standard), and all axes above that are
treated as one-dimensional axes.
</p><p>
Finally, the view and window are resized so the height of the view and
window is just a bit higher than needed to display the taller of the two
columns. This makes the window look nice, without a lot of wasted space
on the screen.
</p><p>
The <code class="methodname">Pulse()</code> function just locks the window and
calls <code class="methodname">Draw()</code> to refresh
the display.
</p><p>
The <code class="methodname">Draw()</code> function actually handles drawing the joystick's movements
interactively. It begins by getting the numbers of buttons, hats, and
axes, and by allocating buffers for the axis and hat values:
</p><pre class="programlisting cpp">
<code class="varname">numButtons</code> = <code class="varname">stick</code>-&gt;<code class="methodname">CountButtons</code>();
<code class="varname">numHats</code> = <code class="varname">stick</code>-&gt;<code class="methodname">CountHats</code>();
<code class="varname">numAxes</code> = <code class="varname">stick</code>-&gt;<code class="methodname">CountAxes</code>();
<code class="varname">axes</code> = (<span class="type">int16 *</span>) <code class="function">malloc</code>(sizeof(<span class="type">int16</span>) * <code class="varname">numAxes</code>);
<code class="varname">hats</code> = (<span class="type">uint8 *</span>) <code class="function">malloc</code>(<code class="varname">numHats</code>);
</pre><p>
The axes and hats arrays will be used when we call <code class="methodname">GetAxisValues()</code> and
<code class="methodname">GetHatValues()</code>; these functions fill these arrays with the values of each
of the axes and hats on the joystick.
</p><p>
Then, <code class="classname">BJoystick</code>::<code class="methodname">Update()</code> is called. This tells the joystick driver to
look at the state of the joystick and record the current values. Now we
can actually retrieve the values and do something with them.
</p><p>
We begin by drawing the state of the buttons. Each button is represented
by a box next to the corresponding label. If the button is pressed, a
solid black box is drawn. If the button isn't pressed, a hollow box is
drawn. This is done in a loop, as follows:
</p><pre class="programlisting cpp">
<code class="varname">r</code>.<code class="methodname">Set</code>(105,50,115,60);
<code class="varname">buttons</code> = <code class="varname">stick</code>-&gt;<code class="methodname">ButtonValues</code>();
for (<code class="varname">i</code>=0; <code class="varname">i</code>&lt;<code class="varname">numButtons</code>; <code class="varname">i</code>++) {
  if (<code class="varname">buttons</code> &amp; (1 &lt;&lt; <code class="varname">i</code>)) {
    <code class="methodname">FillRect</code>(<code class="varname">r</code>, <code class="constant">B_SOLID_HIGH</code>);
  }
  else {
    <code class="varname">r</code>.<code class="methodname">InsetBy</code>(1,1);
    <code class="methodname">FillRect</code>(<code class="varname">r</code>, <code class="constant">B_SOLID_LOW</code>);
    <code class="varname">r</code>.<code class="methodname">InsetBy</code>(-1,-1);
    <code class="methodname">StrokeRect</code>(<code class="varname">r</code>, <code class="constant">B_SOLID_HIGH</code>);
  }
  <code class="varname">r</code>.<code class="varname">top</code> += 18;
  <code class="varname">r</code>.<code class="varname">bottom</code> += 18;
}
</pre><p>
The <code class="methodname">ButtonValues()</code> function returns a <span class="type">uint32</span> that contains bitmapped
flags, one for each button (so <code class="classname">BJoystick</code> supports up to 32 buttons per
joystick). The low-order bit represents button 0, the next bit is button
1, and so forth. If the bit is set to 1, the button is pressed, otherwise
it's not.
</p><p>
This code loops through, once for each button, and looks to see whether
that button is pressed or not. If it's pressed, the rectangle is filled
solid with the high color; otherwise, the interior of the rectangle is
cleared to the low color and the frame is refreshed in the high color.
</p><p>
The states of the hats are obtained by calling <code class="methodname">GetHatValues()</code>, passing in
a pointer to the hats array we allocated at the beginning of the
function. On return, each byte in the array is filled in with the state
of the corresponding hat. Each direction the hat might be pointing is
represented by a different value:
</p><ul class="itemizedlist"><li><p>
0 Centered
</p></li><li><p>
1 Up
</p></li><li><p>
2 Up and Right
</p></li><li><p>
3 Right
</p></li><li><p>
4 Down and Right
</p></li><li><p>
5 Down
</p></li><li><p>
6 Down and Left
</p></li><li><p>
7 Left
</p></li><li><p>
8 Up and Left
</p></li></ul><p>
These nine values represent nine different positions, which can be nicely
displayed in a three-by-three grid of squares. I won't go into the
specifics of how the code that draws this grid works (this article is
getting long already), but we fill in the appropriate square given the
value of each hat, and make sure the others are all cleared.
</p><p>
We read the axes by calling <code class="methodname">GetAxisValues()</code>. This works just like
<code class="methodname">GetHatValues()</code>—we pass in a pointer to an array of
<span class="type">int16</span>s that will
contain the values of each axis on return. Each of these values may range
from -32,768 to 32,767.
</p><p>
Next, the X and Y axes (which we're treating as a two-dimensional field)
are drawn. This code isn't very smart, but it does the job. It simply
scales the X and Y values into the range needed to draw the dot, and
draws a red, filled circle to represent the stick's position.
</p><p>
The rest of the axes are drawn as a horizontal slider-type display, with
a black box and a red oblong indicating the value of the axis.
</p><p>
Download StickIt and have a look at the code. When you get R4, give it a
try. The new <code class="classname">BJoystick</code> class should make it much easier to provide
powerful control in games.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-43"></a>Notes From the Road</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
I'm in Europe—actually, in Paris, France. In the old days, the idea of
Europe was just that, an idea cherished by citizens with memories of the
bad old days and hopes for a better future. In those times, one could not
freely move one's person or belongings or profession from one country to
another.
</p><p>
Half a century later, preparing for landing at the Charles de Gaulle
airport, the airline attendant mentions the "Schengen Space," the set of
countries we can all move freely between, citizens of the European Union
or not. And talk freely between—your GSM cell phone works everywhere.
Not the same frequency of GSM as the one timidly offered in the US, but
multistandard phones are becoming available and, voilà , a world-wide
cell phone (almost, no GSM in Japan, if memory serves).
</p><p>
So, slowly, with all the difficulties involved in mediating cultural
differences, with the danger lurking in an additional layer of civil
servants, the occasionally reviled eurocrats, the shining idea of a
united Europe is becoming a dented reality.
</p><p>
This seems to generate many opportunities for the PC industry. PC sales
are growing everywhere, even in the midst of economic uncertainty. On a
country by country basis, growth rates range from 18% in the UK to more
than 21% in France. Compaq still leads and Dell registers the strongest
growth, almost doubling unit sales last quarter (possibly a response to
its sending a seed team of elite troops to one country after another to
firmly implant its methods, in reaction to its problematic first
efforts). On the surface, with the possible exception of Siemens, major
European brands don't have much market presence any more.
</p><p>
In a world of standard products based on Windows and Intel Architecture
processors, in theory, there is little technological advantage available
to any one player. What follows, still in theory, is that European
companies have a more level playing field than with IBM proprietary
mainframe architectures. Instead, they are leveled not by technology but
by strong corporate cultures, although this is only partly true. In the
US, a good 25% of all PCs are no-name systems assembled to order by
aggressive local retailers who manage to "out price" and "out service"
the big guys. In Europe, each sizeable city enjoys such an active core of
small companies who, according to a local study, serve an even higher
percentage of the market than in the US.
</p><p>
Conversations here put less emphasis on the Y2K problem, rightly or
wrongly, than on opening markets to competition in fields such as
telecommunications. Local monopolies no longer control the field and,
what do you know, the just opened market consumes so much more of the
newly competitive services that the old monopolies prosper more than
ever, along with their new competitors. This, in turn, has removed
obstacles that used to stand in the way of Internet development. What was
seen as yet another invasion of American culture is now embraced by both
the new blood who see the future on the Net, and the old guard who know
they must follow or die.
</p><p>
For the software industry, the emerging new Europe offers an interesting
mix of opposing trends. On one hand, we have the obvious: the easier
circulation of goods, services, people, and even professions (your
professional degree is now recognized in more places) all make it easier
to sell more product in more places. On the other, but not opposed, hand,
Europeans are used to different, fragmented cultures. This makes it easy
for us to promote what in other places is sometimes perceived as a
"fragmenting" product.
</p><p>
In other less politically correct words, Microsoft is a lesser god in
Europe than in the US. Where the common US view is "there is no other
Microsoft but Microsoft," Europe is not so monotheistic. As a result,
BeOS enjoys proportionally higher acceptance with software developers and
distribution channels, as well as with the general and professional
media. This is in line with what happened with the VCR and audio CDs, or
even the Macintosh—they all first gained traction in Europe.
</p><p>
In conclusion, and in contradiction with some of the above, if the story
is that the US favors standardization and Europe accepts more diversity,
how do I explain five or six incompatible cellular telephone systems in
the US vs. Europe-wide (and beyond) GSM?
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-42.html">Issue 3-42, October 21, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-44.html">Issue 3-44, November 4, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-42.html" title="Issue 3-42, October 21, 1998"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue3-44.html" title="Issue 3-44, November 4, 1998"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
