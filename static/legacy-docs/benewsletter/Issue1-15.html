<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 1: 1995–1996</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Be Newsletters" /><link rel="up" href="volume1.html" title="Volume 1: 1995–1996" /><link rel="prev" href="Issue1-14.html" title="Issue 1-14, March 13, 1996" /><link rel="next" href="Issue1-16.html" title="Issue 1-16, March 27, 1996" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue1-14.html" title="Issue 1-14, March 13, 1996"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume1.html" title="Volume 1: 1995–1996"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue1-16.html" title="Issue 1-16, March 27, 1996"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 1: 1995–1996</div></div><div id="headerB">Prev: <a href="Issue1-14.html">Issue 1-14, March 13, 1996</a>  Up: <a href="volume1.html">Volume 1: 1995–1996</a>  Next: <a href="Issue1-16.html">Issue 1-16, March 27, 1996</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue1-15"></a>Issue 1-15, March 20, 1996</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering1-15"></a>Be Engineering Insights: craw, shex, and script: Excuse Me?</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Steve</span> <span class="surname">Horowitz</span></span></div></div></div><p>
On the BeBox, as on other platforms, developers are always looking for
little tools that make their work easier or help to automate repetitive
processes. <span class="application">craw</span>, <span class="application">shex</span>,
and <span class="application">script</span> are just these kinds of tools. They're
not very complicated, they don't write your application for you, but they
do help in small ways to make the application development process a
little easier. A number of people have been asking about these tools, so
this article explains what they are and how to use them.
</p><p>
<span class="application">craw</span>, <span class="application">shex</span>, and
<span class="application">script</span> live in the <code class="filename">/bin</code>
folder on the BeBox. You can use
them in the <span class="application">Terminal</span> application, which provides the command line for the
Be shell, bash. You can also use <span class="application">craw</span>,
<span class="application">shex</span>, and <span class="application">script</span> in shell scripts.
Each of these tools has a completely different purpose, but when you
combine them with each other or with other shell tools, they can be
remarkably useful.
</p><p>
The <span class="application">craw</span> tool converts 24-bit image files created on other systems to
formats that are useful in Be applications. The <span class="application">shex</span> tool is pretty
simple: It's just an application that allows you to run a script file by
double-clicking it. The <span class="application">script</span> tool sends simple commands to Be
applications, such as telling them to quit.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id477268"></a>The Raw Image Converter: craw</h3></div></div></div><p>
The <span class="application">craw</span> tool makes it easy to include images from other systems in your
Be applications. It converts raw, 24-bit, RGB images to the 8-bit or
24-bit color formats Be applications can use.
</p><p>
Release 1.1d6 of the Be OS only supports 8-bit graphics (that is, images
that include 8 bits of color information for each pixel, allowing up to
256 colors on the screen at one time). Release 1.1d7 will support both
8-bit and 24-bit graphics at multiple resolutions. In release 1.1d7, you
set the bit depth you want with the <span class="application">Screen</span> preferences application. (In
fact, release 1.1d7 supports 32-bit graphics—24 bits of color
information for each pixel, allowing millions of colors on the screen at
one time, plus 8 bits of "transparency" information per pixel. However,
working with transparency is beyond the scope of this article—and the
current version of <span class="application">craw</span>.)
</p><p>
If you're using release 1.1d6, <span class="application">craw</span> only converts raw files to 8-bit
format. But if you're using release 1.1d7, <span class="application">craw</span> converts raw files to the
same bit depth as the screen—8 or 24 bits per pixel, as set with the
<span class="application">Screen</span> application. You can use <span class="application">craw</span> to save converted images as
resources or as byte arrays. In either case, you can use the data in a
call to <code class="methodname">BBitmap::SetBits()</code> to create the image inside your Be application
and to render it in a view.
</p><p>
To use <span class="application">craw</span> you need a raw image in 24-bit, RGB, interleaved format. You
can use the Macintosh version of Photoshop to save image files in this
format. First, use Photoshop's Image Size command to make sure the width
of the image, in pixels, is a multiple of 4. Then choose Save As, select
the Raw format, name the file, and click OK. Finally, in the Raw Options
dialog box, make sure the Interleaved Order option is checked and click
OK again.
</p><p>
After transferring the image file to the BeBox (using ftp or tar), use
the <span class="application">Screen</span> application to make sure the screen is set to the bit depth
you want <span class="application">craw</span> to convert your image to (remember, the bit depth option in
the <span class="application">Screen</span> application is only available in release 1.1d7). Then start up
the <span class="application">Terminal</span> application and to convert, for example, an image file named
<code class="filename">MyImage</code> that's 64 pixels wide by 40 pixels high, simply enter "<code class="command">craw 64
40 MyImage</code>". <span class="application">craw</span> creates a file named
<code class="filename">iconfile</code>, which is a text file
that contains an array of unsigned chars named after the file you
converted. You can copy this array into your source code and use it as
the source buffer when calling <code class="methodname">BBitmap::SetBits()</code>.
The call to <code class="methodname">SetBits()</code>
should use the char array as the source buffer followed by the size in
bytes of the buffer. You can compute the size parameter by multiplying
the width of your image (64 in our example) by the number of BYTES per
pixel (1 BYTE for 8-bit color, 3 BYTES for 24-bit color) and multiplying
the result by the height of the image (40 in our example). You then pass
0 as the offset parameter and set the <code class="parameter">color_space</code> parameter according to
the bit depth of the screen at the time the image was converted. The
resulting bitmap can then be drawn in any <code class="classname">BView</code>.
</p><p>
Another option when using <span class="application">craw</span> is to add the word "res" at the end when
you invoke the tool (for example, "<span class="application">craw</span> 64 40 MyImage res"). This creates
a resource file named <code class="filename">icon_res</code> instead of the <code class="filename">iconfile</code> text file. You
can use the <span class="application">listres</span> tool to view the contents of this resource file,
where you will find either PICT, ICON, or MICN resources. <span class="application">craw</span> creates
these three different types of resources simply based on the size of the
raw image: ICON resources are created for images that are 32-by-32
pixels, MICN for images that are 16-by-16 pixels, and PICT for images
that are any other size. You can then use the resource file API to read
in these resources and set up bits in bitmaps just like the byte arrays.
(Note that in release 1.1d6 of the Be OS, you can add only 1 resource of
each type to the <code class="filename">icon_res</code> file. If you try to add more,
<span class="application">craw</span> reports an
error. In release 1.1d7 you can add as many as you like. The text-based
technique allows as many images as you like in both releases.)
</p><p>
I hope you'll find it's easy to use <span class="application">craw</span> to dress up your Be applications.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id477475"></a>The Shell Script Executer: shex</h3></div></div></div><p>
This tool is actually pretty simple and doesn't require any special
knowledge. In fact it will probably go away in future releases of the Be
OS when our shell (bash) incorporates its functionality. But for now this
is the tool that becomes the "owner" of text files you create when you
use the Edit application's "Convert to Script File" command. Once <span class="application">shex</span>
owns a script text file, you can simply double-click the script file to
invoke bash and run the script. When you double-click a script file, <span class="application">shex</span>
also opens a status window that tells you the name of the shell script
it's currently running. When you combine <span class="application">shex</span> with the script tool, you
can automate some of the more common and repetitive build procedures.
I'll give you an example a little later.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id477510"></a>The Script Command Sender: script</h3></div></div></div><p>
The <span class="application">script</span> tool is a handy utility for sending script commands, in the
form of <code class="classname">BMessages</code>, to running Be applications. For example, from the
shell you can send a <code class="constant">B_QUIT_REQUESTED</code> message to a running application to
tell the application to quit.
</p><p>
To control an application with the <span class="application">script</span> tool, you create a text file in
the <code class="filename">/system/script</code>
folder that contains the commands you want to use to
control that application. The text file must have the same name as the
signature of the application you want to control. For example, to create
a text file that contains commands for controlling the Magnify
application, you'd name the file "MAGN". You can include any command in
the file that the application will respond to, including standard system
messages. The format of each command of the file is basically the
typeable name of the command you want to send (such as "cmdQUIT"),
followed by a single-quoted, four-character command constant (such as
'_QRQ' for the <code class="constant">B_QUIT_REQUESTED</code> message). If you used the preceding
example, you could make the Magnify application quit by simply typing
"script MAGN cmdQUIT" in a Terminal window.
</p><p>
A sample file (in the <code class="filename">/system/script</code>
folder) to control an application
might contain the following commands:
</p><pre class="screen">
cmdQUIT                 '_QRQ'
cmdSHOW_ABOUT_BOX       '_ABR'
cmdOPEN_UNTITLED        'ount'
</pre><p>
Each of these commands can be sent directly to the BApplication object
inside your application in the form of a BMessage, so any commands your
application understands can be included in this scripting definition
file. Note that the script tool is not a replacement for a full, powerful
scripting system on the BeBox. It's just a simple tool for controlling
applications in basic ways.
</p><p>
You can combine the script tool with double-clickable scripts to do some
pretty handy things. For example, if you're using a Macintosh to develop
a Be application, you can create a single double-clickable script file
that quits your running application, uses ftp to get a new copy, and
starts up the new copy. Here's how to make a script that does just that:
</p><p>
Assume your application's signature is 'asig' and assume your Macintosh
has an IP address of XXX.XX.X.X. Your Macintosh must be running an ftp
server, such as FTPd. Also assume your application is called "MyApp" and
that it lives at the root of your BeBox's boot disk. Use Edit to create a
text file that contains the following four lines, but don't include the
comments—the ##s and the text that follows them in each line—and
only include the chmod line if you're using release 1.1d7:
</p><pre class="programlisting bash">
script asig cmdQUIT          ## quit your app
ftp XXX.XX.X.X  from_mac     ## get a new copy
chmod +x MyApp               ## make it executable in 1.1d7
/boot/MyApp &amp;                ## run your app
</pre><p>
Use Edit's "Convert to Script File" command to make the file a
double-clickable script. In order for this script to work, of course, you
have to have created your scripting control file, named "asig" in the
/system/script folder, to control your app. The other thing this script
relies on is a text file to feed ftp to make the transfer happen. This
text file should be named "from_mac" and contain the following lines
(again, don't include the comments):
</p><pre class="programlisting">
Steve                     ## your ftp login name
password                  ## your password
cd "/HardDisk/folder"     ## the path to your app
lcd /                     ## put app at the BeBox root
bin                       ## use binary transfer mode
get MyApp                 ## get your app
get MyApp._rsc            ## necessary in 1.1d6 ONLY
get MyApp.xMAP            ## get it's debugging symbols
quit
</pre><p>
Put this ftp helper file in the same folder as your double-clickable
script file.
</p><p>
Once all these things are in place, you can simply double-click your
script file to quit your application, bring over a new copy from the
Macintosh, and start up the new copy.
</p><p>
This is just a small sample of what you can do by combining some simple
Be tools. You could also use these tools to automate testing, to send
commands to multiple applications running at the same time, and for many
other purposes. I hope this article has given you a feel for some of the
helpful BeBox tools that make application development a little easier.
Better yet, perhaps these tools will help you create even more powerful
tools as we all help to get this new platform off the ground and make
developing on the BeBox a rewarding experience.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevProfile1-15"></a>Be Developer Profile: Jim Menard</h2></div></div></div><p>
To be successful, most computing platforms aim to attract both "big guys"
(see the Adobe Systems Developer Profile in the January 24, 1996, "Be
Newsletter") and "little guys." But most often it's the "little guys" who
bring innovation and breakthrough products to a platform. They're also
the ones who provide solutions for vertical markets. Jim Menard, a Be
developer and musician based in Boston, is a great example.
</p><p>
Jim is a one-person development shop whose been designing MIDI software
and serving the music marketplace for over ten years. MIDI (Musical
Instrument Digital Interface) is a standard for how musical instruments,
computers, and other devices exchange music data. For example, using the
common MIDI communications protocol, a performer can daisy-chain several
synthesizers together in a way that makes it possible to create a
"layering" of sounds (much like recording multiple tracks in a music
studio), in real time in a live setting .
</p><p>
Jim's product, The KeyMaster, is real-time MIDI performance software. At
the stomp of a footswitch during a performance (or any other MIDI event),
it allows a performer to totally reconfigure his or her MIDI setup. A
performer can split controlling keyboards, layer and transpose MIDI
channels, send program changes and system-exclusive messages, limit
controller and velocity values, and much more. The KeyMaster can also be
used for MIDI studio control, lighting control, and other
music/performance applications. The first incarnation of the product was
on a Commodore 64, followed by a port to the Atari ST. Currently, Jim's
porting it to the Macintosh, and plans to port it to the BeBox later this
year.
</p><p>
Why is Menard targeting the Be platform? Like many early Macintosh
developers, he says he isn't doing it to get rich quick (though he
wouldn't be averse to the idea). While he definitely sees a business
opportunity for the BeBox down the road, he's developing for it now
because he "believes in Be's vision of the marketplace and its software
distribution model." Not only that, but the BeBox's architecture boasts
many capabilities that are especially appealing to him as a MIDI
developer: Built-in MIDI hardware and real-time software support, audio,
multitasking and multithreading, easy hooks into real-time sound
manipulation, and simple inter- and intra-application communications, to
name a few.
</p><p>
"I hope the BeBox becomes the next Macintosh," Menard says. "It's new,
it's fun, and Be's done most everything the right way—including being
responsive to developers' ideas." Jim is so excited about the BeBox he
tells us he's working nights and weekends to bring The KeyMaster to the
BeBox. After that? He's got lots of future product plans, including a
MIDI sequencer and a MIDI librarian.
</p><p>
For more information on The KeyMaster, including a list of features and
future directions, visit Jim's web site:
http://www.io.com/~jimm/keymaster.html. Or send him e-mail at jimm@io.com.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee1-15"></a><acronym class="acronym">PPCP</acronym>, <acronym class="acronym">MLD</acronym>/<acronym class="acronym">LERD</acronym>, and Other Permutations</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
I came in early this morning, straight from the school bus pick-up where
I drop my son Paul around 7 am. As always, I was late writing this column
and I wanted some time before the phone started ringing. I was going to
write about <acronym class="acronym">PPCP</acronym> (the PowerPC Platform), my hopes for it, some concerns
too. That was before I read the story in the March 19 "San Francisco
Chronicle" discussing the new Macintosh Licensing Design, <acronym class="acronym">MLD</acronym> for short,
also called <acronym class="acronym">LERD</acronym> (Low End Reference Design) in other publications. This
new licensing design sheds an entire new light on the future of <acronym class="acronym">PPCP</acronym> or,
as some critics are already pointing out, confirms their long-held
suspicions that Apple wasn't as committed to <acronym class="acronym">PPCP</acronym> (nee CHRP, itself nee
PREP) as claimed earlier.
</p><p>
We'll discuss the <acronym class="acronym">PPCP</acronym> theory, then implementation questions and
implications of the <acronym class="acronym">MLD</acronym> announcement. But first: Why do we care?
</p><p>
We care because a unified hardware platform propelled by Apple, Motorola,
and to some degree IBM could reach critical mass, attract followers,
cloners if you wish, suppliers, third-party hardware augmenters,
developers and, at the beginning of the food chain, customers. Be, in
turn, would have a stable, credible platform upon which to base a
multiprocessor version of the BeBox. Also, the Be OS could run in
single-processor mode on the millions of <acronym class="acronym">PPCP</acronym> boxes out there. Be heaven.
</p><p>
In short, <acronym class="acronym">PPCP</acronym> was designed to be the PC/AT of the PowerPC world. In the
Wintel space, you buy spare parts, chipsets, processors, <acronym class="acronym">BIOS</acronym>, and the
like and you design your own clone. Differentiation is limited. In some
cases it's only marketing, just like cigarettes. When you buy an Intel
motherboard, a case and power supply, a Seagate drive, and a Mitsumi
floppy, there isn't much room for difference. And you have a stable
platform, one that runs many operating systems besides Windows and
Windows NT. It'll run OS/2, Linux, and various expensive or free variants
of UNIX. And I must be missing one or two interesting systems. There are
glitches here and there, <acronym class="acronym">BIOS</acronym> and other compatibility problems but, by
and large, the market trusts the platform. And trust is the operative
word.
</p><p>
With this in mind, how does the <acronym class="acronym">PPCP</acronym> consortium create a self-fulfilling
prophecy? How does the market get to trust that, yes, there is such a
thing as a real PowerPC platform, and, as a result, an industry arises
and creates a stable life form around the PowerPC? Before this morning,
our concerns were of two kinds: Chips and human beings.
</p><p>
On the silicon side the vagueness of some technical specifications
concerned us and we didn't quite like the dreaded "third-party
opportunity" used to describe some support chips. In our business,
"third-party opportunity" is a code word, now over-used and transparent.
It refers to products the main player doesn't have the will, the money,
or the brains to make. In a world where the other processor vendor also
makes full chipsets and complete motherboards, I believe trust in the
platform will be enhanced if the PowerPC suppliers also supply the
complete set of building blocks. Mac <acronym class="acronym">ROM</acronym>s are supposed to come from Apple
and "third-party vendors," the chip with Apple-specific I/O, code-named
Hydra, also from Apple, the processors from IBM and Motorola, one support
chip from Motorola, and less noble I/O chips are the "third-party
opportunities" already mentioned.
</p><p>
Turning to the human beings issue, with so many cooks, you always end up
with politics, which isn't really a synonym for trust. And as Richard
Brandt mentioned in this month's "Upside," in all these delicate
standard-building activities (he was referring to <acronym class="acronym">HTML</acronym>), you always run
the risk of someone making a last-minute, conscious or unconscious,
proprietary move. Imagine this: Your OS depends on a <acronym class="acronym">BIOS</acronym>. And the <acronym class="acronym">BIOS</acronym>
supplier happens to be Microsoft, instead of independents such as Phoenix
or AMI. How would you feel?
</p><p>
Now we hear there's yet another platform for the Mac OS: <acronym class="acronym">MLD</acronym> or <acronym class="acronym">LERD</acronym>.
With the usual caveats, this is recent and perhaps incomplete
information. <acronym class="acronym">PPCP</acronym> is supposed to be a multi-OS platform. But it's deemed
too expensive for the low end. The new <acronym class="acronym">MLD</acronym> is a simpler platform, it will
only run the MacOS. There is no disputing the merit of the least
expensive Mac design possible. Several questions arise, however. First,
what's this MacOS-only story? Perhaps a Be-biased question. Today, I can
buy a PC/AT clone system with hard disk, monitor, and so on, for prices
ranging from $700 to $7000 retail, more or less. They can all run
Windows, Windows NT, and all the other operating systems mentioned
earlier. Why can't the <acronym class="acronym">LERD</acronym> run all manner of system software? What's
there to gain by such a limitation? How trustworthy will it feel? It
seems the <acronym class="acronym">LERD</acronym> was born because the <acronym class="acronym">PPCP</acronym> didn't scale down very well,
perhaps a result of the Apple/Motorola/IBM politics driving the design
process. If that's a correct assumption, then the viability of the <acronym class="acronym">PPCP</acronym>
platform is questionable. With IBM on the sidelines, offering no
high-volume designs, the PowerPC camp is already divided. It can't afford
more fragmentation. If the <acronym class="acronym">LERD</acronym> is really a good, manufacturable design,
cloners will take it, pervert it, augment it, and make it perform the
unnatural acts that signify success in our industry. And if that includes
running Windows NT on it, great—as long as there's only one reference
platform, the necessary but not sufficient condition for a PowerPC
industry to arise.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue1-14.html">Issue 1-14, March 13, 1996</a>  Up: <a href="volume1.html">Volume 1: 1995–1996</a>  Next: <a href="Issue1-16.html">Issue 1-16, March 27, 1996</a> </div><div id="footerB"><div id="footerBL"><a href="Issue1-14.html" title="Issue 1-14, March 13, 1996"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="volume1.html" title="Volume 1: 1995–1996"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="Issue1-16.html" title="Issue 1-16, March 27, 1996"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div></body></html>
